------------------------------------------------------------------------
--
-- File:            tpcompletecheck.pmlfnc
--   Type:          Function Definition
--   Group:         Piping Branch Table
--     Keyword:     PIP
--   Module:        DES
--   Replaces:
--
-- Author:          A. Saudemont
-- Created:         January 31 2020
-- Owner:           TECHNIP FMC
--
-- Description:
-- Function pour comparer les TEE ou OLET du model
-- avec le fichier XML de SPMat pour les "Branch Table"

-- Historique de la forme appliquée à la fonction si besoin
	-- 1.0   28/10/2019 Initial release by AS.
	-- 1.1 - 28/10/2019 Ajout dans le fichier config.xml d'un tri pour extraire que les SITE ayant à la fin de leur nom
	--                  la "value" à la fin de la section "SiteName" 
	-- 1.2 - 30/01/2020 Ajout de la méthode ".savedetailsToCsv()" permettant de lancer l'extraction de la grille
	--                  dans un fichier au format .csv
	-- 1.3 - 18/05/2020 Ajout de 2 colonnes pour inserer les ident
	-- 1.4 - 15/07/2020 Recherche de l'identcode en faisant la recherche dans la 
	--                  nouvelle version du fichier XML ayant un champs "identcode".

------------------------------------------------------------------------
--
-- Function Type:   Function/Procedure
-- Arguments:
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------

-- Define function
define function !!tpcompletecheck()

	-- dll import pour le lecture du fichier XML
	var !banner banner

	if matchwild(!banner,'*Everything3D Design Mk2*') then
		!dll = |C:\AVEVA\dll-E3D\PMLXmlDocumentE3D2|
	else
		return
	endif

	import '$!dll'
	handle (1000,0)
		-- already loaded
	endhandle

	-- Namespace
	using namespace |PMLXmlDocument.PMLXmlDocument|

	-- on définit le format pour les INCH
  	!inchformat = object format()
	!inchformat.units = 'INCH'

	-- récupère le code du projet
	!project = current project
	!projectcode = !project.code()

	-- initialise le fichier XML pour les branch table
	!branchtablexmldoc = object PMLXmlDocument()
	!dfltsfile = object file(|%| & !projectcode & |DFLTS%\TPBranchtable\Spec_Branch.xml|)
	!branchtablexmldoc.load(!dfltsfile.fullname())

	-- initialise le fichier XML pour la config
	!configxmldoc = object PMLXmlDocument()
	!dfltsfile = object file('%' & !projectcode & 'DFLTS%\TPBranchtable\Config.xml')
	!configxmldoc.load(!dfltsfile.fullname())


    -- Gestion des unités
	var !UNITS UNITS
	if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
		var !unittext |mm|
	else
		var !unittext |in|
	endif

	-- Démarrage Chrono
	Clock init

	-- On collecte les TEE et OLET du model
	!allmem = object collection()
	!types = |TEE OLET|
	!allmem.types(!types.split())

	-- Filtre le purpose du site
	!purp    = !configxmldoc.selectnodes(|//Setting[@name='SitePurp']|)
	
	!SiteNam = !configxmldoc.selectnodes(|//Setting[@name='SiteName']|)
	!purpval = |PURPOSE OF SITE EQ '| & !purp[1].value('@value') & |' and matchwild ( name of site, '*| & !SiteNam[1].value('@value') & |')|
	
	!expression = object expression(!purpval)
	!allmem.filter(!expression)

	!allmems = !allmem.results()
	-- q var !allmems

	!Rows = object array()

	do !memobj values !allmems
		-- !memobj = object DBREF(!mem)
		!b = array()

		-- Site Name
		!b.append(!memobj.owner.owner.owner.owner.name)
		-- Zone Name
		!b.append(!memobj.owner.owner.owner.name)
		-- Pipe Name
		!b.append(!memobj.owner.owner.name)
		-- Branch Name
		!b.append(!memobj.owner.name)
		-- Tee/Olet Refno
		!b.append(!memobj.name)
		-- Type
		!b.append(!memobj.type)
		-- Status
		!b.append('')
		-- Specification
		if badref(!memobj.spown) then
			!sprefname = 'nulref'
		else
			!sprefname = !memobj.spown.name
		endif
		!b.append(!sprefname)
		-- header bore
		!headerbore = !memobj.ppbore[1].string().before(!unittext)
		!b.append(!headerbore)
		-- branch bore
		!branchbore = !memobj.ppbore[3].string().before(!unittext)
		-- spref s'applique aux composants
		!b.append(!branchbore)
		-- Current Type
		!b.append(!memobj.stype.before('_'))
		handle any
			!b.append(|Unset|)
		endhandle
		
        --AS Début Modif 1.3 - Ajout de l'ident
		-- Current Ident
		!b.append(!memobj.spref.:TP-IDENT)
        --AS Fin Modif 1.3 - Ajout de l'ident
		
		-- on gère les unités : MARIAN ne travaille qu'en INCH
		if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
			-- le projet est en mm
			!tpcurbore = object bore()
			!tpcurbore.bore(!headerbore.real())
			!headermm   = !tpcurbore.string()
			!headermm   = !headermm.replace('.50','.5').replace('.00','').replace('0.','.')

			!headerbore = !tpcurbore.string(!inchformat)
			!headerbore = !headerbore.replace('.50','.5').replace('.00','').replace('0.','.')

			!tpcurbore.bore(!branchbore.real())
			!branchmm   = !tpcurbore.string()
			!branchmm   = !branchmm.replace('.50','.5').replace('.00','').replace('0.','.')

			!branchbore = !tpcurbore.string(!inchformat)
			!branchbore = !branchbore.replace('.50','.5').replace('.00','').replace('0.','.')
		else
			-- le projet est en inches
			!headerbore = !headerbore.replace('.50','.5').replace('.00','').replace('0.','.')
			!branchbore = !branchbore.replace('.50','.5').replace('.00','').replace('0.','.')
		endif

		-- on retrouve le STYPE target
		!spec = !memobj.spown.namn

		-- récupère le noeud pipename dans le XML branch table
		!specnode = !branchtablexmldoc.selectnodes(|//BranchTable[@value='| + !spec + |']|)
		if not !specnode.size() gt 0 then
			!stype = |Not found#Spec | + !spec + | not found in branch table file|
			golabel /suite
		endif

		-- récupère le noeud diametre collecteur
		!diamheadernode = !specnode[1].selectnodes(|DiamHeader[@value='| + !headerbore + |']|)
		if not !diamheadernode.size() gt 0 then
			!stype = |Not found#Header diameter | + !headerbore + | not found in branch table file for spec | + !spec
			golabel /suite
		endif

		-- récupère le noeud diamètre sortie
		!diamoutnode = !diamheadernode[1].selectnodes(|DiamBranch[@value='| + !branchbore + |']|)
		if not !diamoutnode.size() gt 0 then
			!stype = |Not found#Branch diameter | + !branchbore + | not found in branch table file for header diameter | + !headerbore + | for spec | + !spec	
			golabel /suite
		endif

		!stype = !diamoutnode[1].value('@stype')
		label /suite
		-- !stype = !this.getStype(!spec,!headerbore,!branchbore)
		!errormsg = !stype.after('#')
		
		-- Ajout du Target Styp
		!b.append(!stype.before('#'))


					-- AS Début Modif 1.3 - Ajout de l'ident
					-- on retrouve le IDENT target
					-- if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
					-- 	!headerdia = !headermm
					-- 	!branchdia = !branchmm
					-- else
					-- 	!headerdia = !headerbore
					-- 	!branchdia = !branchbore	
					-- endif

		!TargStype = !stype.before('#')
					-- !specnam = |/| & !spec
	
		if !TargStype.eq('Not found') then
			!b.append(|N/A|)
		else
			-- AS Début Modif 1.4 - Ajout de l'ident extrait du fichier .xml
			!TargStype = !diamoutnode[1].value('@idencode')
			if !TargStype.eq(||) then
				!TargStype = |No Ident in XML|
			endif
			-- Ajout du Target Ident
			!b.append(!TargStype)
			--AS Fin Modif 1.4 - Ajout de l'ident
		
		endif

					-- else
					
						-- !CollBran = object collection()
						-- !CollBran.scope(!specnam.dbref())
						-- !CollBran.type(|SPCO|)
						-- !SpcoSearch = |styp eq '| & !stype & |' and p1bore eq | & !headerdia & | and p3bore eq | & !branchdia
						-- !expression = object expression(!SpcoSearch)
						-- !CollBran.filter(!expression)
						-- 
						-- !SpcoList = !CollBran.results()
						-- if !SpcoList.size().gt(0) then
						-- 	!TargStype = !SpcoList[1].:TP-IDENT
						-- else
						-- 	!TargStype = |??|
						-- endif
						
						-- Ajout du Target Ident
						-- !b.append(!TargStype)
					-- endif
					--AS Fin Modif 1.3 - Ajout de l'ident

		-- Ajout du message d'erreur
		!b.append(!stype.after('#'))

	    !Rows.append(!b)
	enddo

	-- on reparcours la liste et on met le status
	-- Numéro des colonnes a traiter
	!Stat = 7
	!Curr = !Stat + 4
	!Targ = !Stat + 6
	!Erro = !Stat + 8

	!rownum = 0

	do !row values !Rows
		!rownum = !rownum + 1
		!mem = object DBREF(!row[1])
		-- on ne fait rien pour les PIPE et les BRAN
		if not !mem.type eq 'PIPE' and not !mem.type eq 'BRAN' then
				-- on va comparer les STYPE
				if !row[!Curr] ne !row [!Targ] then
					!row[!Stat] = |Failed|
					if !row[!Erro] eq '' then
						!row[!Erro] = |Current styp and target stype are different|
					endif
				else
					!row[!Stat] = |Passed|
				endif
		endif
	enddo

	!dflts = !projectcode & |DFLTS|
	var !dirdflts evar $!dflts

	-- dans repertoire xxx-report\piping	
	!RepDir    = !dirdflts.replace(|dflts|,|-report|)
	!RepDirPip = !RepDir & |\piping|

	!RepDirect    = object file(!RepDir)
	!RepDirectPip = object file(!RepDirPip)

	if !RepDirect.exists() then
		if !RepDirectPip.exists().not() then
			!command = |syscom 'mkdir | & !RepDirPip & |'|
			$!command		
		endif
	else
		!command = |syscom 'mkdir | & !RepDir & |'|
		$!command
		!command = |syscom 'mkdir | & !RepDirPip & |'|
		$!command
	endif

	-- Create headings
	!heading = |Site Name;Zone Name;Pipe Name;Branch Name;Tee/Olet Name;Type;Status;Piping Specification;Header Diameter;Branch Diameter;Current Stype;Current Ident;Target Stype;Target Ident;Error Message|
	!liste = object array()
	!liste.append(!heading)
	
	-- Nom du fichier CSV
	!FileCsv = object file(|$!RepDirectPip\CheckBranchTableComplete.csv|)

	-- Création des lignes du fichier CSV avec séparateur ";" 
	do !row index !Rows
		!ligne = ||
		do !i index !Rows[!row]
			!ligneadd = !Rows[!row][!i] & |;|
			!ligne = !ligne & !ligneadd
		enddo
		!liste.append(!ligne)
	enddo

	-- Ecriture du fichier .CSV
	!FileCsv.writefile(|OVERWRITE|,!liste)

	-- Arret du Chrono
	$p Time to Fill the GRID
	Clock read elapsed  
	
endfunction
