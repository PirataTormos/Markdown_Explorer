
define function !!tpchoosecalccomp(!element is dbref)
	-- for each component we have to choose the calculated SPRE and LSTU or LSTU
    -- on reselectionne le composant que si le projet est "à calculer"
	var !tpwtactive evar TPWTACTIVE
	if !tpwtactive.neq(||) then
		if boolean(!tpwtactive.upcase()) then
			-- on est à caluler
			-- gestion des unités
			var !UNITS UNITS
			if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
				var !unittext |mm|
			else
				var !unittext |in|
			endif
	
			-- initialise le fichier XML pour la config s'il n'existe pas
			if Undefined(!!configxmldoc) then
				-- dll import pour le lecture du fichier XML
				import |C:\Aveva\DLL\PMLXmlDocumentE3D2|
				handle (1000,0)
					-- already loaded
				endhandle
				-- namespace
				using namespace 'PMLXmlDocument.PMLXmlDocument'
				!!configxmldoc = object PMLXmlDocument()
				-- récupère le code du projet
				!project = current project
				!projectcode = !project.code()
				!dfltsfile = object file('%' & !projectcode & 'DFLTS%\TPBranchtable\Config.xml')
				!!configxmldoc.load(!dfltsfile.fullname())
				-- récupère les noeuds settings dans le XML config
				!expression = !!configxmldoc.selectnodes(|//Setting[@name='Expression']|)
				!!exp = !expression[1].value('@value')
			endif
			
			-- récupère le nom du pipe à calculer
			var !pipename PIPE
			-- converti le pipename
			var !newpipename $!!exp
	
			-- on va avoir besoin de "methodes" de la forme "tpcheckbranchtable", on la charge le cas échéant
			if not defined(!!tpcheckbranchtable) then 
				pml load form !!tpcheckbranchtable
				-- appel du constructeur
				--!!tpcheckbranchtable.tpcheckbranchtable()
			endif
			
			-- selon que le CE est une branche ou non, on gère le HSTU ou bien le SPRE et le LSTU
			if not !element.type eq 'BRAN' then
				-- on s'occupe du SPRE : on essaye de trouver le SPRE calculé
				!newspref = !!tpcheckbranchtable.getnonegenericspco(!element.spref,!newpipename)
	
				if not !newspref.before('#') eq 'Target not found' then
					-- on a trouvé le spre
					!newsprefobj = object dbref(!newspref)
					!element.spref = !newsprefobj
				else
					-- message à l'utilisateur
					!!alert.error('The calculated piping component could not be selected, the generic one will be left (' + !newspref.after('#').after('#') + ')')
				endif
				
				-- on s'occupe du LSTU : on essaye de trouver le LSTU calculé
				!newlstu = !!tpcheckbranchtable.getnonegenericspco(!element.lstu,!newpipename)
				if not !newlstu.before('#') eq 'Target not found' then
					-- on a trouvé le spre
					!newlstuobj = object dbref(!newlstu)
					!element.lstu = !newlstuobj
					--q var !newlstuobj.name
				else
					-- message à l'utilisateur
					!!alert.error('The calculated piping tube could not be selected, the generic one will be left (' + !newlstu.after('#').after('#') + ')')
				endif
			else
				-- on s'occupe du HSTU : on essaye de trouver le HSTU calculé
				!newhstu = !!tpcheckbranchtable.getnonegenericspco(!element.hstu,!newpipename)
				if not !newhstu.before('#') eq 'Target not found' then
					-- on a trouvé le spre
					!newhstuobj = object dbref(!newhstu)
					!element.hstu = !newhstuobj
				else
					-- message à l'utilisateur
					!!alert.error('The calculated piping tube could not be selected, the generic one will be left (' + !newhstu.after('#').after('#') + ')')
				endif
			endif
		endif
	endif
endfunction
