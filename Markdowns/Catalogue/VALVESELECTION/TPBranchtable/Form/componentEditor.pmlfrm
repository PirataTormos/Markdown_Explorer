------------------------------------------------------------------------
--
-- Copyright 1974 to current year. AVEVA Solutions Limited and its subsidiaries. All rights reserved in original code only.
--
-- File:            componentEditor.pmlfrm
--   Type:          Form Definition
--   Group:         Piping Application
--
--     Keyword:     PIPING
--   Module:        design
--   Replaces:
--
-- Author:          Tony Martin
-- Created:         09/07/2012 08:34:04
--
--
-- Description:
-- Pipe component creation form
--
-- Author:          Bibin Jose
-- Created:         02/01/2023 08:34:04
--
-- Description:
-- Updated Pipe component creation form to filter Valves, gaskets and Flanges as per Fluid codes
------------------------------------------------------------------------
--
-- Methods defined:
--
--  Method call                      Return              Description
--  ===========                      ======              ===========
--  adjacent()                       -                   Set the adjacent elements for the component
--  adjacent(DBREF,BOOLEAN)          ARRAY               Set the adjacent elements for the component
--  adjacentBores(DBREF,BOOLEAN)     ARRAY               Returns the adjacent bores to the passed component, dependent
--  adjacentClear()                  -                   Clear the adjacent component list
--  adjacentDirection(DBREF,BOOLEAN) DIRECTION           Returns the adjacent direction to the passed component
--  adjacentPosition(DBREF,BOOLEAN)  POSITION            Returns the adjacent position to the passed component
--  adjacentSelect()                 -                   Select different specRef for component type in adjacent created components
--  adjacentType()                   -                   Setup form for selected type
--  alignSpecList()                  -                   resets the current spec to the spec of the current element
--  angleGadgets(STRING)             ARRAY               Returns the angle used for setting the radius of the passed
--  appendRestricted(DBREF)          -                   insert a dummy specification at the top of the spec list
--  applyLstu()                      -                   Apply the changes to selected Lstu
--  applySlopeDirection(DIRECTION)   -
--  arriveLeave(REAL,REAL,STRING)    -
--  arriveLeaveSetup(ANY)            -                   The Arrive/Leave information for the current component
--  assemblyVisibility(BOOLEAN)      -                   Sets component attributes to from specification
--  autoRoute()                      -                   Calls Router and completes or routes the current branch
--  branchHasMoved()                 BOOLEAN
--  calculateRadius(REAL)            -                   Calculates radius of a bend using N*OD option
--  changeAngle()                    -                   Change angle for Component
--  changeComponentType()            -                   Change Component Type
--  changeEditAngle()                -
--  changeSpecConfirm(STRING)        -                   This is called when the insulation or tracing is selected
--  checkAlignment(LINE,POSITION)    REAL                test to see if a given position lies on a line between two positions
--  checkComponents(STRING)          BOOLEAN
--  checkForCurrentComponent()       BOOLEAN
--  choices(BORE,STRING)             ARRAY
--  close()                          -                   Close form
--  combineIconTexts(STRING,STRING)  ARRAY               used to build the iconList array
--  componentDirection(DBREF,BOOLEAN) DIRECTION           Returns the direction to the passed component
--  componentEditor()                -                   Constructor
--  componentGadgets(BOOLEAN)        -                   Shows/Hides the gadgets associated with the create task
--  componentPosition(DBREF,BOOLEAN) POSITION            Returns the position of the passed component
--  componentSpecification()         -                   Setup using components specification
--  componentSpecification(DBREF)    DBREF               Get component specification
--  configureArriveLeave()           -                   this method is the result of clicking the fixed point toggle
--  connect()                        -
--  connect(ARRAY)                   BOOLEAN             Connects the passed components to the previous item
--  connect(ARRAY,BOOLEAN)           BOOLEAN             Connects the passed components to the from up or down stream item
--  connect(DBREF)                   BOOLEAN             Tries to connect passed component to previous item,
--  connect(DBREF,ARRAY)             BOOLEAN             Connects the passed components about the passed component
--  connectAdjacent(DBREF,ARRAY,DBREF) ARRAY               Creates and connects adjacent components for both side
--  connectionChoices(DBREF,DBREF,BOOLEAN) ARRAY
--  create(BOOLEAN)                  BOOLEAN             Create component
--  create3DPosition()               -                   Instigate an EDG event to position the components
--  create3DPosition(ARRAY)          -                   instigate creation based on a passed 3D pick
--  createAdjacent(DBREF,ARRAY,DBREF) ARRAY               Creates the adjacent items on both sides of the passed item
--  createAdjacent(DBREF,ARRAY,DBREF,BOOLEAN) ARRAY               Creates the first adjacent item to the passed component
--  createAtPosition()               -                   Instigate an EDG event to position the components
--  createAtPosition(EDGPOSITIONDATA,BOOLEAN) -                   Create component
--  createConnected(DBREF,STRING,DBREF,BOOLEAN) DBREF               Creates the passed element type and connects to the passed
--  createCopy()                     -                   creates a copy of the current component and positions it
--  createFirstConnected(DBREF,STRING,DBREF,BOOLEAN) DBREF               Creates the first adjacent item to the passed component
--  direct(STRING)                   -
--  directButtons(STRING)            -
--  directionControlModeChange()     -                   changes the directioncontrol
--  displayAssembly()                -                   Sets component attributes to from specification
--  displayBores()                   -                   Display the currently available bores
--  displayChoices(STRING)           -
--  displayStypes()                  -                   Display the currently available stypes
--  displayTubes(DBREF,STRING)       -                   Called to display the lstu gadget and call functions
--  drawDimension()                  -                   could be called as part of the filmStrip to dimension
--  editFilterChoices(ANY)           ARRAY               Filter available components by stype and current settings
--  editSelectBore(GADGET,STRING)    -
--  editTest()                       -                   test if current element has been moved
--  elementIsComponent(DBREF)        BOOLEAN
--  elementIsComponentOrBranch(DBREF) BOOLEAN
--  errors()                         -                   Check for errors
--  executeCommand(STRING)           -                   This method adds an undo for a lot of button actions
--  filmStrip()                      -
--  filterChoices()                  -                   Filter available components by stype and current settings
--  filterComponents(STRING)         -
--  filterSubType(STRING,STRING)     -                   Select sType for Components
--  findNearest(ARRAY)               -                   find the nearest component to the atta position and reorder it
--  findWallVal(BORE,DBREF)          -
--  flip()                           -                   Flip current created components
--  flow(BOOLEAN)                    -                   Set creation flow for component (forwards/backwards)
--  getAlternateWall(DBREF)          REAL                gets the arrive or leave tube wall thickness for PTAPS
--  getArriveLeaveData(DBREF,DBREF)  -
--  getBranch(DBREF)                 DBREF               Returns branch from passed element
--  getComponentDetail(DBREF)        -
--  getComponentText(STRING)         STRING              This method gets the extended component type from
--  getConnectedElements()           -                   gets the brconnect elements for the reconnect button
--  getDirectionChangeType()         STRING
--  getLeaveDirection(DBREF)         ARRAY
--  getPickedPosition(DBREF,POSITION,REAL,ANY) -                   sets !this.pickedPosition
--  getSpecomWall(DBREF)             -

-- code JFH-AS
	-- getStype(STRING,STRING,STRING) STRING             extract the STYP from Marian XML file - TECHNIP-FMC
	
--  getVectorPositions(DBREF)        POINTVECTOR         gets the position and direction of the next point
--  graphicSelection()               -                   Define graphic selection of current components
--  initialiseCreation()             -                   Initialise the relevant variables and gadgets for creation
--  insulationSpecification()        -                   Set insulation spec of component
--  isItFlanged(DBREF)               BOOLEAN
--  isValidBranch(ARRAY)             BOOLEAN             Check validity of branch before we continue
--  laserPipeCentre(POSITION)        ARRAY               Wrapper to the LFM extension interface to find a pipe centre.
--  limits(DBREF)                    -
--  loadChoices(STRING)              -                   Load the choices for the current selection
--  loadComponents(STRING)           -                   Load component choice
--  loadGadgets(DBREF,STRING,STRING) -                   Loads component gadgets in select/reselect modes.
--  loadTubes(GADGET,BORE,DBREF,STRING) REAL
--  machineTest(DBREF)               REAL
--  modifyGadgets(BOOLEAN)           -                   Shows/Hides the gadgets associated with the modify task
--  modifyMode()                     -                   Reinstates the model editor mode if was previously active
--  moveToComp(STRING)               -
--  otherSpecifications()            -                   get the insu and tracing specs
--  pickDirection()                  -                   uses edg to pick a position to direction component towards
--  pickDirection(EDGPOSITIONDATA,DBREF) -
--  pickPosition()                   -
--  pickPosition(EDGPOSITIONDATA,DBREF) -
--  positionDistance(REAL)           -                   called by the distance and clearance buttons to ensure
--  positionThrough(DBREF,POSITION)  -                   this method is called to position an element through a passed
--  processMultiple(ARRAY)           -                   reorder multiple attas after a component
--  questionsAndAnswers(ANY)         ARRAY               Returns a 2D array of questions and answers for the passed
--  readOptions()                    -                   Write options to users file
--  reconnect(BOOLEAN)               -                   Re-establish connections of adjacent components
--  removeActiveTask()               -                   Clear the current active task before setting a new one
--  removeRestricted()               -                   remove a dummy specification at the end of the spec list
--  reorder(DBREF,DBREF)             -
--  reorderList(ARRAY)               ARRAY
--  reselectAdjacent()               BOOLEAN             Setup form for reselection of adjacent
--  reselectionChoice()              -
--  resetSpec()                      -
--  resumeTask()                     -                   Revert to current task after a warning
--  reviseTube(DBREF,BORE,DBREF)     DBREF
--  rotateByBoltSpacing()            -                   turns off or turns on rotations that are constrained to bolt hole rotation angles
--  roundToOrthogonal(DIRECTION,REAL) DIRECTION           this method rounds each component of direction to E/N/U if within tolerance given
--  selectAlternativeSpec(DBREF)     -                   Select alternative specification
--  selectBore(GADGET,STRING)        -                   Select a check bore for the component type
--  selectChoice()                   -                   Select the current choice and setup other gadgets
--  selectCurrentComponent()         -                   Select Current Component Information
--  selectIcon(STRING)               STRING
--  selectOptions()                  -                   Select Stype and Bore options for selected component
--  selectPoint(STRING)              -
--  selectRadius(REAL)               -
--  selectcomponentType()            -                   Select Component Type
--  setActiveComponent(DBREF)        -
--  setAlternativeSpec()             -                   Use alternative specification
--  setBendGadgetExtra(STRING)       -
--  setBendRadius(DBREF)             -
--  setBranch(DBREF)                 -                   Setup form for current branch
--  setBranchGadgets(BOOLEAN)        -
--  setBranchHeadingText()           -
--  setDirectionControlElement(DBREF) -
--  setDistanceText()                -                   called by the distance and clearance buttons to ensure
--  setFlangeAllowance(DBREF)        -                   Called to test if a radius can be machine defined
--  setFlow(BOOLEAN,STRING)          -
--  setFromIcon(STRING)              -
--  setIconList()                    -
--  setIconTypeVisibility(ARRAY)     -                   sets the active property of the creation icons
--  setInsulationAndTracing(DBREF)   -                   sets the insulation and tracing spec to those on the
--  setIsoMode()                     -                   allows the direction control iso mode to be saved to the defaults value held in !!pipingSettings
--  setMode(BOOLEAN,BOOLEAN)         -
--  setModifyGadgets(BOOLEAN)        -
--  setOffLineFlag(DBREF)            -
--  setOption(STRING)                -                   Set creation of adjacent components
--  setReselectBoreGadget(DBREF)     STRING              returns a string of the current components bore values
--  setRlocFixed(ARRAY,REAL)         -                   goes through the list of components and sets the rloc
--  setSelectComponentTask()         -                   set select component task actions
--  setSelectComponentTask(STRING)   -                   set select component task using a passed type
--  setSelectTypeTask()              -                   set type tab task actions
--  setSlopeGadgets()                -                   activates or deactivates the modify slope Gadgets
--  setSpecAttributes(DBREF)         -                   Sets component attributes to from specification
--  setSpecMode()                    -                   resets the spec text
--  setSpecText(BOOLEAN)             -                   toggles spec text so that the current spec settings are maintained.
--  setSpecification()               -                   Set the active specification
--  setSpecificationTask()           -                   set specification task actions
--  setSpecifications(DBREF,DBREF,DBREF) -
--  setTask(STRING)                  -                   Switch the relevant panels in and out for passed task
--  setup()                          -                   Setup form on show for current element
--  setupOptions()                   -                   Setup options frame to current settings
--  showEDG()                        -                   called as the continuation to the 3D position pick packet
--  showPipeEditor()                 -
--  skipConnected()                  -                   Set skip connected flag
--  slopeChange()                    -                   this method is called if the user selects a new slope
--  sortAttas(ARRAY,ARRAY,ARRAY)     -                   given a set of inline attas we need to work out which ones are in order
--  specGadgets(BOOLEAN)             -                   Shows/Hides the gadgets associated with the spec task
--  tabSelect(GADGET,STRING)         -
--  tag()                            -                   Tag current position
--  tagBranchHeadTail(DBREF,BOOLEAN) -                   adds or removes tags from the current branch head and tail
--  tagChanges()                     -                   Tag change components
--  tagReselect()                    -                   Tag re-select components
--  testBendRadius(DBREF,ARRAY,ARRAY) REAL                Test the bend radius against machines and the spec
--  testForComponentErrors(DBREF)    -
--  testForGasketConnection(DBREF)   BOOLEAN             tests the passed component for a gasket arrive and leave
--  tidy()                           -                   Tidy reference data
--  tidyAtta()                       -
--  tracingSpecification()           -                   Set insulation spec of component
--  track()                          -                   Track Current Element
--  track(DBREF)                     -                   Track with respect to passed element
--  track(STRING)                    -
--  trackBranch()                    -                   calls the direction control element tracking
--  trackModify(DBREF)               -                   Track with respect to passed element
--  trackReselect(DBREF)             -
--  tubeChoice(STRING)               -                   Called to display the lstu gadget and call functions
--  typeGadgets(BOOLEAN)             -                   Shows/Hides the gadgets associated with the select type task
--  undoAdd(STRING)                  -
--  updateComponent()                -                   Update components, modified by external means
--  warning(ARRAY,BOOLEAN)           -                   Set warning task and message
--  warning(STRING,BOOLEAN)          -                   Set warning task and message
--  warningGadgets(BOOLEAN)          -                   Shows/Hides the gadgets associated with the spec task
--

-- code JFH-AS
-- ===================================================================== --
-- ===================================================================== --
-- Ajout des méthodes pour les Branch Table
-- Client: TECHNIP-FMC
-- Auteurs: Jean François Houen - AVEVA
--          Alain Saudemont
-- Date : Novembre 2019
-- ===================================================================== --
-- ===================================================================== --
-- setbranConn(BOOLEAN)              -                   Hide the icon TEE and OLET to Unhide the BRANCONN icon
-- setbranConnFromIcon()             -                   Construct the list from XML File
-- ===================================================================== --
-- ===================================================================== --

------------------------------------------------------------------------

--setup form !!componentEditor resize
--layout form !!componentEditor dialog dock right
layout form !!componentEditor dialog dock right
  
  import 'directionControl'
  handle ANY
    --q var !!error
  endhandle

	-- code JFH-AS
	-- import 'D:\01-Customers\Technip\dev\PMLXmlDocumentE3D2\PMLXmlDocument\bin\Release\PMLXmlDocument'
	import |C:\AVEVA\dll\PMLXmlDocumentE3D2|
	handle (1000,0)
		-- already loaded
	endhandle

  !this.iconTitle = 'Components'
  !this.formTitle = 'Piping Component Editor - TP Rev:1.0'
  !this.callback  = '!this.setup()'
  !this.formRevision  = ' $Revision: 1.14 $ '
  track 'DBCHANGED' call '!this.track(|DB|)'
  track 'DESICE'  call '!this.track(|Navigate|)'

  -- Branch information
  paragraph .branchTag  at xmin ymin  text 'Branch :' width 5.5
  button .branchName  linklabel  at xmax ymin-0.2      width 25 line 1 callback '!this.showPipeEditor()' tooltip 'Modify Pipe Attributes'

  -- Specification information
  paragraph .specTag  at xmin.branchTag ymax+0.2  text 'Spec :'
  path right hdist 0.2
  --button .currentSpec  anchor left + top at xmax ymin-0.2 callback '!this.resetSpec()' linklabel tooltip 'Reset selection to branch specification'
  button .currentSpec  anchor left + top at xmax ymin-0.1 callback '!this.setBranch(!!ce)' linklabel tooltip 'Reset selection to branch specification' width 22

  paragraph .boreTag  anchor left + top at xmin.specTag ymax.currentSpec  text 'Bore :' width 5
  paragraph .currentBore at xmax.boreTag ymin  anchor left + right + top  width 18

  paragraph .slopeTag at xmin.boreTag ymax.boreTag+0.1 text 'Branch Slope :'
  paragraph .slopeName at xmax.slopeTag ymin   anchor left + right + top             width 20

  -- Set branch
  button  .selectBranch 'Set Branch' pixmap "AvevaSharedIcons>ID_BRAN>32" anchor top + left at xmax form+size  ymin form tooltip 'Reset the current branch'  callback '!this.setBranch(!!ce)'  tooltip 'Set working branch'

  -------------------- Warning pane
  paragraph .warningTag anchor left + top at x0 ymin.slopeTag+1  text 'Warning:'
  line .wLine anchor top + left + right at xmin.boreTag ymax horizontal width 39

  paragraph .warningIcon  at xmin .boreTag ymax pixmap width 32 heigh 32
  paragraph .warning  anchor left + right + top at xmax+3 ymin  width 28 lines 6
  button    .warningDone  '  Done  '   anchor right + top   at xmax.wLine-size    ymax+0.5            callback '!this.resumeTask()'

  -- Select alternative specification
  paragraph .outSpecName  anchor left + right + top at x0 ymax.boreTag+1  width 14 lines 1


  --all piping components
  --ELBO BEND TEE OLET CROS REDU FLAN FBLI LJSE GASK VALV VTWA VFWA CAP COUP UNIO FTUB ATTA WELD INST PCOM VENT SHU CLOS TRAP FILT ASSY

  option .specList anchor left + top at xmin.outSpecName ymax.outSpecName callback '!this.selectAlternativeSpec(!this.specList.selection(|rText|).dbRef())' width  12

  -- Insulation
  option .insulation    at xmax ymin  Callback |!this.changeSpecConfirm('INSU')|  width 10
  option .tracing       at xmax ymin  Callback |!this.changeSpecConfirm('TRACE')| width 7
  paragraph .insulationText at xmin.insulation ymin.outSpecName  text 'Insulation' width 10 lines 1
  paragraph .tracingText at xmin.tracing ymin text 'Tracing' width 7 lines 1

  path down
  frame .componentTabs tabset at xmin form ymax.insulation+0.2 anchor left + top
    frame .componentFrame 'Standard Components'  width 28
      button .flangeType     pixmap "AvevaSharedIcons>ID_FLAN>32"    tooltip 'Flange'       callback |!this.setFromIcon('FLAN')|
      path right hdist 1
      button .elbowType     pixmap "AvevaSharedIcons>ID_ELBO>32"    tooltip 'Elbow'       callback |!this.setFromIcon('ELBO')|
      button .teeType       PIXMAP "AvevaSharedIcons>ID_TEE>32"         tooltip 'Tee'        callback |!this.setFromIcon('TEE')|
	  --button .branchTableType       PIXMAP "AvevaSharedIcons>ID_TEE>32"   width 0      tooltip 'Branch table'        callback ||
      button .reduType      PIXMAP "AvevaSharedIcons>ID_REDU>32"  width 32 height 32 tooltip 'Reducer'      callback |!this.setFromIcon('REDU')|
      button .valveType     PIXMAP "AvevaSharedIcons>ID_VALV>32"  width 32 height 32 tooltip 'Valve'        callback |!this.setFromIcon('VALV')|
      button .attaType       PIXMAP "AvevaSharedIcons>ID_ATTA>32"  width 32 height 32 tooltip 'Attachment'     callback |!this.setFromIcon('ATTA')|
      button .pcomType       PIXMAP "AvevaSharedIcons>ID_PCOM>32"  width 32 height 32 tooltip 'Pcom'     callback |!this.setFromIcon('PCOM')|

      button .aWeldType at xmin.flangeType ymax PIXMAP "AvevaSharedIcons>ID_WELD>32" width 32 height 32 tooltip 'Weld'       callback |!this.setFromIcon('WELD')|
      button .bendType       PIXMAP "AvevaSharedIcons>ID_BEND>32"  width 32 height 32 tooltip 'Pipe Bend'       callback |!this.setFromIcon('BEND')|
      button .oletType      PIXMAP "AvevaSharedIcons>ID_OLET>32"  width 32 height 32 tooltip 'Olet'        callback |!this.setFromIcon('OLET')|
      button .coupType       PIXMAP "AvevaSharedIcons>ID_COUP>32"  width 32 height 32 tooltip 'Coupling'        callback |!this.setFromIcon('COUP')|
      button .instType      PIXMAP "AvevaSharedIcons>ID_INST>32"  width 32 height 32 tooltip 'Instrument'     callback |!this.setFromIcon('INST')|
      button .capType           PIXMAP "AvevaSharedIcons>ID_CAP>32" width 32 height 32 tooltip 'Cap'        callback |!this.setFromIcon('CAP')|
      button .gasketType      PIXMAP "AvevaSharedIcons>ID_GASK>32" width 32 height 32 tooltip 'Gasket'       callback |!this.setFromIcon('GASK')|
    exit
    frame .additionalComponents  |Additional Components|
      button .afilttype PIXMAP "AvevaSharedIcons>ID_FILT>32"  width 32 height 32 tooltip 'Filter'        callback |!this.setFromIcon('FILT')|
      path right hdist 1
      button .aCrossType PIXMAP "AvevaSharedIcons>ID_CROS>32" width 32 height 32 tooltip 'Cross'       callback |!this.setFromIcon('CROS')|
      button .aUnionType PIXMAP "AvevaSharedIcons>ID_UNIO>32"  width 32 height 32 tooltip 'Union'        callback |!this.setFromIcon('UNIO')|
      button .aVTWAtype PIXMAP "AvevaSharedIcons>ID_VTWA>32"  width 32 height 32 tooltip 'Three Way Valve'     callback |!this.setFromIcon('VTWA')|
      button .aClosType PIXMAP "AvevaSharedIcons>ID_CLOS>32"  width 32 height 32 tooltip 'Closure'       callback |!this.setFromIcon('CLOS')|
      button .fbliType  PIXMAP "AvevaSharedIcons>ID_FBLI>32" width 32 height 32 tooltip 'Blind Flange' callback |!this.setFromIcon('FBLI')|
      button .aTrapType PIXMAP   "AvevaSharedIcons>ID_TRAP>32"  width 32 height 32 tooltip 'Trap' callback |!this.setFromIcon('TRAP')|

      button .aLJSEtype at xmin.afilttype ymax PIXMAP "AvevaSharedIcons>ID_LJSE>32"  width 32 height 32 tooltip 'Lap Joint Stub End' callback |!this.setFromIcon('LJSE')|
      button .aFTUBpe  PIXMAP   "AvevaSharedIcons>ID_FTUB>32"  width 32 height 32 tooltip 'Fixed Length Tube' callback |!this.setFromIcon('FTUB')|
      button .aVFWApe  PIXMAP   "AvevaSharedIcons>ID_VFWA>32"  width 32 height 32 tooltip 'Four Way Valve' callback |!this.setFromIcon('VFWA')|
      button .aSHUype  PIXMAP   "AvevaSharedIcons>ID_SHU>32"  width 32 height 32 tooltip 'SHU' callback |!this.setFromIcon('SHU')|
      button .aPLATType PIXMAP  "AvevaSharedIcons>ID_PLAT>32"  width 32 height 32 tooltip 'Plate' callback |!this.setFromIcon('PLAT')|
      button .aVENTType PIXMAP  "AvevaSharedIcons>ID_PIPE_VENT>32"  width 32 height 32 tooltip 'Vent' callback |!this.setFromIcon('VENT')|
      button .aASSYType PIXMAP  "AvevaSharedIcons>ID_ASSEMBLY>32"  width 32 height 32 tooltip 'Assembly ' callback |!this.setFromIcon('ASSY')|
    exit
  exit
  frame .extra panel anchor all at xmin.componentTabs ymax.componentTabs+0.2 anchor left + top
    path down
    frame .tabs tabset at xmin.componentFrame ymax.componentTabs width to max.additionalComponents
      ------------------ Current component type
      -- Component types selection
      frame .selectComponents  'Select' anchor left + top at x0  ymax

        paragraph .typelabel  at xmin ymin anchor left+top  text 'Component Type:'
        paragraph .componentType  at xmax ymin  width 8  lines 1
        ------------------ Component selection
        frame .fLine panel  anchor left + top + right at x0 ymax
          -- Available sTypes
          option .sTypes 'SType Filter' anchor left + top + right at xmin  ymax  callback '!this.filterSubType(|comp|,|create|)'  tooltip 'Available sub-types for component' width 10
          list .choices  anchor top + left + right at xmin ymax  callback '!this.selectChoice()' columns single width 32 lines 8
          ------------------ Creation Options
          paragraph .createTag at xmin ymax width 34 lines 1
        exit
        path down
        ------------------ Bend Data
        frame .componentBendFrame 'Bend Information'  anchor right + left + top    width to max .choices

          -- Radius
          option .bendRadiusOption 'Radius' at x1  ymax callback '!this.componentData.selectRadius()' width 8
          path down
          halign right
          text .bendRadius  callback '!this.componentData.selectRadius()' width 10 is REAL format !!distanceFmt

        exit
        ------------------ End of Bend Data

        ------------------ Elbow Data
        frame .componentElbowFrame 'Elbow Information'  anchor right + left + top  at xmin.choices ymax.createTag+0.2   width to max .choices

          -- Angle
          path right
          paragraph .angleLabel text 'Angle'  width 8
          text .angle callback '!this.changeAngle()' width 8 is REAL format !!angleFmt
          paragraph .minAngleLabel at x0 ymax text 'Min' width 8
          text .minAngle  width 8 is REAL format !!angleFmt
          paragraph .maxAngleLabel at x0 ymax text 'Max' width 8
          text .maxAngle  width 8 is REAL format !!angleFmt
        exit
        ------------------ End of Elbow Data

        -- Reducer Data
        frame .componentReduFrame 'Reducer Information' anchor right + left + top  at xmin.choices ymax.createTag+0.2   width to max .choices
          option .reduBore 'Leave Bore'   callback '!this.selectBore(!this.reduBore, ||)'  tooltip 'Permissible Leave Bores' width 10
          path down
          paragraph .reduArrive text 'Config.'
          path right
          -- Leave Bore 'Arrive major bore, leave minor bore'
          button .reduA1L2 at xmax + 1 ymin toggle pixmap "AvevaSharedIcons>ID_DECREASE_BORE>32"  callback '!this.arriveLeave(1,2,|create|)' tooltip 'Arrive major bore, leave minor bore'
          button .reduA2L1 at xmax + 2 ymin toggle pixmap "AvevaSharedIcons>ID_INCREASE_BORE>32" callback '!this.arriveLeave(2,1,|create|)' tooltip 'Arrive minor bore, leave major bore'
        exit
        -- End of Reducer Data

        -- Tee Data
        frame .componentTeeFrame 'Connection Information' anchor right + left + top  at xmin.choices ymax.createTag+0.2  width to max .choices

          -- Connection Bore
		 -- Début code JFH-AS
          option .teeBore  'Conn. Bore' at x.2 ymax  callback '!this.selectBore(!this.teeBore, ||)'  tooltip 'Permissible connection bores'  width 10
		  paragraph .BranTxt at xmax+0.8 ymin+0.2 text |Select outlet Dia.| width 11
		  -- path down
          -- halign right
          button .teeA3L2 toggle pixmap "AvevaSharedIcons>ID_ARRIVE_BY_CONNECTION>32" callback '!this.arriveLeave(3,2,|create|)' tooltip 'Arrive by connection' at x17 ymax+0.2
		 -- Fin code JFH-AS
          path left
          hdistance 0
          button .teeA1L3 toggle pixmap "AvevaSharedIcons>ID_LEAVE_BY_CONNECTION>32"  callback '!this.arriveLeave(1,3,|create|)' tooltip 'Leave by connection'
          button .teeA1L2 toggle pixmap "AvevaSharedIcons>ID_FLOW_THROUGH_TEE>32"  callback '!this.arriveLeave(1,2,|create|)' tooltip 'Flow through tee'
          valign centre
          paragraph .teeArrive  text 'Config.'
        exit
        -- End of Tee Data


        ------------------ Modification Frame
        paragraph .modifyTag  at xmin.choices ymin.selectComponents   text 'Modify Components:'
        line .mLine  at xmin ymax horizontal width 26
        path down
        list .adjacentType 'Components with Alternatives' at xmin.mLine ymax.mLine callback '!this.adjacentType()' width 30 lines 5
        list .adjacentSelect 'Available Alternatives' at xmin.adjacentType ymax  callback '!this.adjacentSelect()'  columns single width 30 lines 7

        halign right
        button .modifyDone  '  Done  '   callback '!this.setTask(|selectComponent|)'
        ------------------ End of Modification Frame

        frame .assemblyFrame  panel  at x0  y0  width 21 height 16

          -- Available sTypes
          hdist 0
          option .assemblyTypes '' anchor left + top + right  callback '!this.filterSubType(|ASSY|,|create|)' tooltip 'Available sub-types for component' width 30
          hdist 1
          path down
          -- List of available elements (similar to choose)
          --  list .choices  anchor all at x ymax+0.1  callback '!this.selectChoice()' columns single width 26 lines 7
          list .assemblyChoices  anchor  left + right + top at x1 ymax  callback '!this.selectChoice()' columns single width 31 lines 6

          ------------------ View Data For assemblies
          frame .vframe panel  at x0 ymax.assemblyChoices width 33 height 1

            view .localView GIVOLUME

              -- Input Modes
              -- Navigate
              inmode create _navi type |DES_NAVIGATE|
              -- Standard Element Pick
              inmode create _pick type |DES_PICK|
              -- Pick Any (Element, Ppoint, Pline)
              inmode create _pAny type |DES_PICK_ANY|
              -- Plines
              inmode create _pLine  type |DES_PICK_PLINE|
              -- Ppoints
              inmode create _point  type |DES_PICK_POINT|
              -- Screen Position
              inmode create _screen type |DES_3D_LINE|
              -- Laser Model rays
              inmode create _pickXGeom  type |DES_PICK_XGEOM|
              -- Default (Navigation)
              inmode create _pickDetail type |DES_PICK_DETAIL|
              -- Default (Navigation)
              inmode create _default  type |DES_NAVIGATE|

              height 8 width 32
            exit
          exit
        exit

        frame .lstuFrame 'Leave Tube:' at  x1 ymax.componentElbowFrame width to max .choices
          option .lstu  anchor left+right  callback '!this.tubeChoice(!this.lstu.selection(|rText|))' tooltip 'Leave tube specification' width 28.5
        exit

        frame .standardComponentFrame 'Create Mode' at xmin ymax.lstu+0.3 width 12
          -- Creation Flow Head-Tail or Tail-Head
          button  .toTail toggle    pixmap "AvevaSharedIcons>ID_CREATE_WITH_FLOW>32" height 32 width 32 tooltip 'Create components in the flow direction' callback '!this.setFlow(true,|std|)'
          path right hdist 1
          button  .toHead toggle   pixmap "AvevaSharedIcons>ID_CREATE_AGAINST_FLOW>32" height 32 width 32  tooltip 'Create components against the flow direction' callback '!this.setFlow(false,|std|)'
          --paragraph .toHeadTag   text 'Against Flow'
        exit
        frame .createActions 'Create Components' at xmax.standardComponentFrame+1  ymin width to max .lstuFrame
          path right hdist 1
          button .create  ' Connect '  pixmap "AvevaSharedIcons>ID_CONNECT_COMPONENT>32"  tooltip 'Create component connected to previous' callback '!this.create(true)'
          button .createPick  ' Place... ' pixmap "AvevaSharedIcons>ID_PLACE>32"  tooltip 'Create component in line at picked position' callback '!this.createAtPosition()'
          button .createPick3D  ' Place... ' pixmap "AvevaSharedIcons>ID_CREATECOMPONENT_AT3D_PICKPOINT>32"  tooltip 'Create component at 3D picked position' callback '!this.create3DPosition()'
          button .flip 'Flip Components'   pixmap "AvevaSharedIcons>ID_FLIP_COMPONENT>32" callback '!this.flip()' tooltip 'Flip orientation of new components'
        exit

        path down
        toggle .createAdjacent at xmin.toTail ymax 'Auto Create'   callback '!this.setOption(|createAdjacent|)'
        path right
        toggle .adjacentSpec    'Select adjacent out of spec.'   callback '!this.setOption(|adjacentSpec|)'
        toggle .skipConn  'Skip Connected Comps'  at xmin.createAdjacent ymax callback '!this.setOption(|skipConnected|)'
		-- code JFH-AS
		toggle .branConn  'Use Bran Conn'  at xmin.skipConn ymax callback '!this.setBranConn(!this.branConn.val)'

        frame .assemblyComponentFrame  'Create Mode' at xmin.lstuFrame ymax.vframe+1.5 width 12
          button  .atoTail toggle    pixmap "AvevaSharedIcons>ID_CREATE_WITH_FLOW>32" height 32 width 32 tooltip 'Create components in the flow direction' callback '!this.setFlow(true,|assembly|)'
          path right hdist 1
          button  .atoHead toggle   pixmap "AvevaSharedIcons>ID_CREATE_AGAINST_FLOW>32" height 32 width 32  tooltip 'Create components against the flow direction' callback '!this.setFlow(false,|assembly|)'
        exit
        frame .createAssemblyActions 'Create Assemblies' at xmax.assemblyComponentFrame+1  ymin width to max .lstuFrame
          button .acreate      ' Connect '  pixmap "AvevaSharedIcons>ID_CONNECT_COMPONENT>32"  tooltip 'Create Assembly connected to previous' callback '!this.create(true)'
          path right hdist 1
          button .acreatePick  ' Place... ' pixmap "AvevaSharedIcons>ID_PLACE>32"  tooltip 'Create assembly at picked position' callback '!this.createAtPosition()'
        exit
      exit

      frame .modifyComponents 'Modify'
        frame .positioning 'Position Through' at x0 ymax
          path right
          hdist 1
          button .tHead        |Head  |     pixmap "AvevaSharedIcons>ID_HEAD>32" tooltip 'Position through branch head'  callback '!this.directButtons(|Head|)'
          button .tPrevious    |Previous|   pixmap "AvevaSharedIcons>ID_PREV_COMPONENT>32" tooltip 'Position through previous element' callback '!this.directButtons(|Previous|)'
          button .tCE          |CE|  pixmap  "AvevaSharedIcons>ID_THROUGH_CURRENT_ELEMENT>32"     tooltip 'Position through current element (align with previous)'       callback '!this.directButtons(|CE|)'
          button .tNext        |Next  |    pixmap "AvevaSharedIcons>ID_NEXT_COMPONENT>32" tooltip 'Position through next component' callback '!this.directButtons(|Next|)'
          button .tTail        |Tail  |     pixmap "AvevaSharedIcons>ID_TAIL>32" tooltip 'Position through branch tail' callback '!this.directButtons(|Tail|)'
          button .tCursor      |Cursor| pixmap  "AvevaSharedIcons>ID_PICK>32"   tooltip 'Position through a cursor pick' callback '!this.directButtons(|Cursor|)'

          button .dist toggle at xmin.tHead ymax   pixmap  width 32 height 32 callback |!this.setDistanceText()|
          !this.dist.addPixMap('AvevaSharedIcons>ID_DISTANCE2>32','AvevaSharedIcons>ID_SPOOL>32')
          text   .distance at xmax+0.1 ymin+0.2  callback |!this.positionDistance(!this.distance.val)| width 11 is REAL format !!distanceFmt
          --Movement Mode
          button .repeat 'Copy CE'at xmax ymin.dist pixmap "AvevaSharedIcons>ID_REPEAT_COMPONENT_CREATION>32" tooltip 'Copy current component' callback |!this.createCopy()|
          button .connect1 'Connect' pixmap "AvevaSharedIcons>ID_CONNECT_COMPONENT>32" tooltip 'Connect to previous component' callback |!this.connect()|
          button  .mode  toggle  pixmap  tooltip 'Forwards/Backwards mode' callback |!this.setMode(!this.mode.val,TRUE)|
          !this.mode.addPixMap('AvevaSharedIcons>ID_BACKWARD_MODE>32','AvevaSharedIcons>ID_FORWARDS_MODE>32')

        exit

        frame .dirContFrame || anchor left+top+right at xmin.positioning ymax height 8.5  wid 33
          -- PML Container to host .net control
          container .netdirContFrame NOBOX PMLNETCONTROL || at DOCK FILL
        exit


        paragraph .directionText  at xmin.positioning ymax.dirContFrame+0.2 width 17
        !this.directionText.val = 'Direction'
        paragraph .slopeText  at xmax+ 4  ymin text 'Current Slope'
        text   .direction ' ' at xmin.positioning ymax.directionText call|!this.directionControlActions.direction(| width 20 is STRING
        option .pipeSlopeList  ' ' at xmin.slopeText ymin call |!this.slopeChange()| width 10
        paragraph .currentSlopeText at xmin.positioning ymax+0.2 width 34
        toggle .pointDirection 'Multi Slope' at xmin.positioning ymax tooltip |select a ppoint from the list and set a direction.| call |!this.configurearriveleave()|
        option .points 'Current Point' at xmax ymin call |!this.selectPoint(!this.points.selection())|  width 11


        frame .modifyTab 'Orientation'  at xmin.positioning ymax.points+0.2

          hdist 1
          path right
          button .dtonext pixmap "AvevaSharedIcons>ID_NEXT_COMPONENT>32" tooltip 'Direction towards next' call  |!this.executeCommand( 'direct to next')|
          button .dtoprev pixmap "AvevaSharedIcons>ID_PICK>32"  tooltip 'Direction towards pick' callback |!this.pickDirection()|
          button .dtohead pixmap "AvevaSharedIcons>ID_HEAD>32"  tooltip 'Direction towards head' call | !this.executeCommand('direct to ph')|
          button .dtotail pixmap "AvevaSharedIcons>ID_TAIL>32"  tooltip 'Direction towards tail' call | !this.executeCommand( 'direct to pt')|


          button .oRI |Ori| at xmin .dtonext ymax pixmap "AvevaSharedIcons>ID_ORIENTATE_COMPONENT>32" tooltip 'Orientate current component' call |CALLP MROTATE ORI|
          -- could be "AvevaSharedIcons>ID_P_ORIENTATE_COMPONENT>32"
          button .fLIPa |Flip|pixmap "AvevaSharedIcons>ID_FLIP_COMPONENT>32" tooltip 'Swap arrive and leave points(flip)' call |CALLP MROTATE FLIP|
          -- Re-align selection
          button .alignComponent   tooltip 'Align selection/component'    pixmap "AvevaSharedIcons>ID_P_ALIGN_COMPONENT>32"    callback | !this.executeCommand( '!!alignComponent()' )|
          button .directComponent  tooltip 'Direct selection/component'   pixmap  "AvevaSharedIcons>ID_DIRECT_TOWARDS_NEXT>32" callback | !this.executeCommand( '!!directComponent()' )|

        exit

        frame .others 'Other' at xmax.modifyTab+1 ymin.modifyTab
          path right
          button .tpod   |Drag|  pixmap "AvevaSharedIcons>ID_ADVANCED_DRAG>32" tooltip 'Advanced positioning Drag'   callback '!!dragMoveForm(true,||)'
          button .tpom   |Move|  pixmap "AvevaSharedIcons>ID_ADVANCED_MOVE>32" tooltip 'Advanced positioning Move'   callback '!!dragMoveForm(false,||)'

          button .changeflow |change Flow|  at xmin .tpod ymax pixmap "AvevaSharedIcons>ID_LEAVE_BY_CONNECTION>32" tooltip 'Change flow through component' callback |show !!cdcompalp|
          button .tpo   |Advanced...|  pixmap "AvevaSharedIcons>ID_P_PIPE_ROUTER>32"  tooltip 'Auto complete'   callback '!this.autoRoute()'
        exit


      exit

      frame .reselectComponents 'Reselect'
        frame .editComponentFrame     'Components'    anchor right + left + top at xmin ymin width 26

          -- Current Component
          valign centre
          paragraph .editComponentName  anchor left + right + top   at xmin  width 34 lines 1
          -- Component/branch specification
          paragraph .editCurrentSpec at xmin ymax  width 26 lines 1
          paragraph .editBoreTag      anchor left + top                 at xmin               ymax         text 'Bore :'
          paragraph .editCurrentBore   anchor left + right + top at xmax  ymin           width 10
          -- List of possible change types for component
          option .editComponentList 'Type' at xmin.editBoreTag  ymax  callback '!this.changecomponentType()' width 17

          -- Available sTypes
          option .editSTypes 'Sub-Types'  anchor left + top  at xmin.editComponentList  ymax callback '!this.filterChoices()'  tooltip 'Available sub-types for component' width to max .editComponentList

          -- List of available elements (similar to choose)
          list   .editChoices    anchor all at xmin.editComponentList ymax  callback '!this.reselectionChoice()' single zeroSelection width 30 lines 7

          -- Bend Data
          frame .editComponentBendFrame 'Bend Information'  anchor right + left + bottom at xmin.editChoices    ymax  width to max.editChoices

            -- Radius
            option .editBendRadiusOption 'Radius' at x1 ymax callback |!this.editComponentData.selectRadius(!this.editBendRadiusOption.selection('dtext'))|  width 6
            path down
            halign right
            text   .editBendRadius      callback '!this.editComponentData.setRadius()'  width 10 is REAL format !!distanceFmt

          exit
          -- End of Bend Data

          ------------------ Elbow Data
          frame .editElbowFrame 'Elbow Information'  anchor right + left + bottom at xmin.editChoices ymax.editChoices    width to max.editChoices

            -- Angle
            path right
            paragraph .editAngleLabel text 'Angle'                  width 8
            path right
            text .editAngle       callback '!this.changeEditAngle()'         width 8 is REAL format !!angleFmt

            paragraph .editMinAngleLabel at xmin.editAngleLabel ymax text 'Min'                 width 8
            text .editMinAngle                     width 8 is REAL format !!angleFmt

            paragraph .editMaxAngleLabel at xmin.editAngleLabel ymax text 'Max'                 width 8
            text .editMaxAngle                    width 8 is REAL format !!angleFmt
          exit
          ------------------ End of Elbow Data

          -- Reducer Data
          frame .editReduFrame 'Reducer Information' anchor right + left + bottom at xmin.editChoices  ymax.editChoices  width to max.editChoices height 4

            -- Leave Bore
            option .editReduBore 'Leave Bore'   callback '!this.filterChoices()' tooltip 'Permissible Leave Bores' width 10
            path down
            paragraph .editReduArrive text 'Config.'
            path right
            button .editReduA1L2 toggle at xmax + 1 ymin pixmap  "AvevaSharedIcons>ID_DECREASE_BORE>32"  height 24 width 24 callback '!this.arriveLeave(1,2,|edit|)' tooltip 'Arrive major bore, leave minor bore'
            button .editReduA2L1 toggle at xmax + 2 ymin pixmap "AvevaSharedIcons>ID_INCREASE_BORE>32" height 24 width 24   callback '!this.arriveLeave(2,1,|edit|)' tooltip 'Arrive minor bore, leave major bore'
            -- End of Reducer Data

          exit
          -- End of Reducer Data

          -- Tee Data
          frame .editTeeFrame 'Tee Information' anchor right + left + bottom at xmin.editChoices  ymax.editChoices   width to max.editChoices

            -- Connection Bore
            option .editteeBore  'Conn. Bore'  at x1   ymax callback |!this.filterChoices()| tooltip 'Permissible connection bores' width 10
			-- code JFH-AS
			-- toggle .branConnResel  'Use Bran Conn'  at xmin ymax+0.5 callback ||

            path down
            halign right
          exit
          -- End of Tee Data

        exit
        frame .editLstuFrame 'Leave Tube:' at  xmin ymax.editComponentFrame width to max.editChoices
          option .editLstu anchor right + left  callback '!this.applyLstu()' tooltip 'Leave tube specification' width 32.3
        exit
        -- Re-establish connected components
        button .reconnect 'Reconnection'     at xmin.editComponentFrame     ymax.editLstuFrame+0.2      callback '!this.reconnect(true)' tooltip 'Re-establish adjacent connections'
        -- End of Component Selection Frame
      exit


      -- Error Page
      frame .errorsFrame   'Errors'  dock fill
        path down
        button  .errors 'Refresh'  callback '!this.errors()'
        list    .errorList  anchor all width to max.errorsFrame height 1
      exit
    exit
    -- End of Specification Selection Frame

    frame .sequenceSelector 'Component Sequence List' at xmin.extra ymax.extra+0.2 height 3.25

      button .startcomp pixmap  "StandardIcons>ID_DATACONTAINER_MOVEFIRST" width 16 height 16 at x0 ymin.sequenceSelector+0.3 callback |!this.moveToComp('START')|
      button .prevcomp pixmap  "StandardIcons>ID_GOTOPREVIOUSRECORD" width 16 height 16 at xmin+2 ymin callback  |!this.moveToComp('PREV')|
      button .filmStrip1 '' pixmap "AvevaSharedIcons>ID_MATCHLINES>32" at xmin+3 ymin
      button .filmStrip2 '' pixmap "AvevaSharedIcons>ID_MATCHLINES>32"  at xmax+1.5 ymin
      paragraph   .filmStrip at xmax.filmStrip2 ymin.sequenceSelector  pixmap  "AvevaSharedIcons>ID_SELECTION>48"
      button .filmStrip3 '' pixmap "AvevaSharedIcons>ID_MATCHLINES>32"  at xmax.filmStrip2+ 1 ymin.startcomp
      button .filmStrip4 '' pixmap "AvevaSharedIcons>ID_MATCHLINES>32"  at xmax.filmStrip3+ 1 ymin
      button .filmStrip5 '' pixmap "AvevaSharedIcons>ID_MATCHLINES>32"  at xmax+1 ymin
      button .nextcomp pixmap "StandardIcons>ID_DATACONTAINER_MOVENEXT" width 16 height 16 at xmax.filmStrip5 ymin callback |!this.moveToComp('NEXT')| at xmax ymin.startcomp
      button .endcomp pixmap "StandardIcons>ID_DATACONTAINER_MOVELAST"  width 16 height 16 at xmin+2 ymin  callback |!this.moveToComp('END')|
    exit
  exit


  ------------------ End of Creation Options

  -- Set Defaults for Modes
  !this.localView.navi.cursor = 'Pointer'
  !this.localView.navi.prompt = 'Navigate : '

  !this.localView.pick.cursor = 'Pointer'
  !this.localView.pick.prompt = 'Pick Element : '

  !this.localView.pAny.cursor = 'Pointer'
  !this.localView.pAny.prompt = 'Pick Any : '

  !this.localView.pLine.cursor  = 'Pointer'
  !this.localView.pLine.prompt  = 'Pick Pline : '

  !this.localView.point.cursor  = 'Pick'
  !this.localView.point.prompt  = 'Point Ppoint : '

  !this.localView.screen.cursor = 'Crosshair'
  !this.localView.screen.prompt = 'Pick 3D Position : '

  !this.localView.default.cursor  = 'Pointer'
  !this.localView.default.prompt  = 'Navigate : '


  ------------------ End of Bend Data

  -- Component Creation Form Members ------------------------------------------------------------------


  -- Current Active Branch
  member .branch    is DBREF
  member .branchHeadPosition is POSITION
  member .branchTailPosition is POSITION

  member .component is DBREF
  member .outSpec is BOOLEAN
  member .componentPosition is POSITION
  -- added for reselect form
  member .componentList is COMPONENTLIST

  -- Check for modification
  member .lastModified      is DATETIME
  -- Is branch valid
  member .isValid is BOOLEAN

  -- Created Components
  member .newComponent  is DBREF
  member .newComponents is ARRAY

  -- Multi choice (bucket for holding items created with their multiple choices)
  member .multipleSelect  is ARRAY

  -- Next and Previous Components
  member .next  is DBREF
  member .previous  is DBREF

  -- Check bore for component, could be P3 of a Tee or P2 of a reducer, etc.
  member .checkBore is BORE

  -- Arrive/Leave for new component (not to be confused with arrive/leave of current component)
  member .arriveBore  is BORE
  member .leaveBore is BORE
  member .tubeOD  is REAL
  -- Information about component
  member .answers               is ARRAY
  member .questions             is ARRAY
  member .sType                 is STRING
  member .wallTH  is REAL

  -- Connection information
  member .connections           is ARRAY
  member .connected             is COMPONENTRECONNECT

  -- member for storing the current flow direction forwards/backwards
  member .flow  is BOOLEAN
  member .modeButtonSave is BOOLEAN

  -- List of accessed Component Specifications
  member .specifications  is ARRAY

  -- List of specifications within the system
  member .specificationIndices  is ARRAY

  -- Branch specification
  member .branchSpecification is DBREF

  -- Active specification index (quick access to information)
  member .activeSpecIndex is REAL

  -- Specification to create component with
  member .currentSpecification  is DBREF

  -- Active specification components are created using
  member .activeSpecification is DBREF

  -- Alternative specification
  member .alternativeSpec is DBREF

  -- Current Selected component in spec
  member .currentComponentIndex is REAL

  -- Current task
  member .currentTask is STRING

  -- Warning task active
  member .warningTask is BOOLEAN

  -- Currently Active Component
  member .activeDataFrame is GADGET

  -- Currently Active Frame
  member .currentFrameIndex is REAL

  -- Special Attribute Registers (index is the same as the frame register)
  -- Radius Gadgets
  member .radiusRegister  is ARRAY
  -- Bore Gadgets
  member .boreRegister  is ARRAY
  -- Angle Gadgets
  member .angleRegister  is ARRAY
  -- Arrive Leave Gadgets??
  member .arriveLeaveRegister is ARRAY

  -- Active component object (use an array as it can be heterogeneous)
  member .activeComponent       is ARRAY
  -- Object for registered components
  member .componentObjects  is ARRAY

  -- Default component object
  member .defaultComponent  is COMPONENTDEFAULT

  -- Available Components
  member .availableComponents is ARRAY

  -- Aid Graphics
  member .tagID is REAL
  member .branchTagID is REAL
  member .planeTagID is REAL
  member .tagChanges  is REAL
  member .tagReselect  is REAL

  -- EDG Description
  member .edgDescription  is STRING

  -- Picked Position
  member .pickedPosition        is POSITION

  -- Active filters
  member .sTypeFilter           is BOOLEAN

  -- Display options (2 dimensional array [1] Key, [2] Description)
  member .detailText            is ARRAY

  -- Utility Option Settings
  member .tag                   is BOOLEAN
  member .tagConstraints        is BOOLEAN
  member .connectFreeEnds       is BOOLEAN
  member .autoConnection        is BOOLEAN
  member .ignorePositioned      is BOOLEAN
  member .tagPoint              is POINTVECTOR

  -- Utility Option Settings

  member .componentDetail   is REAL
  member .skipConnected         is BOOLEAN
  member .autoCreate            is BOOLEAN
  member .autoCreateSpec        is BOOLEAN
  member .autoAlign             is BOOLEAN

  -- Current Model Edit state
  member .modifyMode            is BOOLEAN
  member .state                 is STATE

  member .assemblies            is PIPINGASSEMBLYMGR
  member .assembly              is PIPEASSEMBLY

  -- Current element can actively be modified, should be set to FALSE
  -- on manual tracking and selection exiting modify tasks
  member .modifyActive          is BOOLEAN

  -- Undo for creation
  member .undo                  is UNDOABLE
  -- add a drawList for the local view
  member .drawList              is DRAWLIST

  --Number of Leave tube specs available
  member .noLstuSpecs           is REAL
  --Lstu Selection
  member .lstuSelection         is DBREF

  --multiBore boolean to tell if a selectable component is multiBore
  member .multiBore             is BOOLEAN
  -- multiBore has been used for reducing components and three way components
  -- need to know which type this is for COMPONENTDEFAULT base class
  -- .reducingComponent added for case where p1 bore is different from P2 bore
  member .reducingComponent     is BOOLEAN
  --member to set whether available item is a reducing flange
  member .redFlange             is BOOLEAN

  member .checkForSnapDist      is BOOLEAN
  member .oriComp               is DBREF

  -- Current element for modify tab
  member .modifyElement is DBREF

  using namespace 'Aveva.Model.Presentation'
  -- .net direction controls
  member .dirCont is DIRCONTROL
  member .arrivePos is POSITION
  member .directionControlActions is DIRECTIONCONTROLACTIONS
  member .pickedPosData           is EDGPOSITIONDATA
  member .pickedPosDirData        is EDGPOSITIONDATA

  ----------- Special members for edit form ------------------------------------------------------------

  member .trackCe is BOOLEAN

  member .editComponentPosition is POSITION
  member .editComponent is DBREF
  member .reconnectAvailable    is BOOLEAN
  member .editComponentDetail       is STRING
  member .editComponentObjects  is ARRAY
  -- Currently Active Component
  member .editActiveDataFrame is GADGET

  member .editArriveLeaveRegister is ARRAY

  -- Information about reselect component
  -- added for reselect form
  member .editSType                 is STRING
  member .editComponentRegister     is ARRAY

  -- Bore Gadgets
  member .editCheckItems            is ARRAY

  -- Available Components
  member .editAvailableComponents is ARRAY
  member .editComponentType       is STRING
  member .componentData           is COMPONENTEDITDATA
  member .editComponentData       is COMPONENTEDITDATA
  member .iconList                is ARRAY
  member .dimension               is PIPEMODELDIMENSION

  -- horrid fix for pressing "no" on bend radius
  member .bendAnswer is BOOLEAN
  member .bendSaved  is REAL

  member .branchSlope        is DBREF
  member .slopeList          is SLOPELIST
  member .componentFeedBack  is COMPONENTFEEDBACK
  member .pickReturn         is STRING
  member .multiSlope         is BOOLEAN

  --member to check the type of selections for creation
  member .connectValue          is BOOLEAN
  member .placeInLine           is BOOLEAN
  member .place3d               is BOOLEAN

  -- code JFH-AS
  -- Member the the branch Table - TECHNIP-FMC
  using namespace |PMLXmlDocument.PMLXmlDocument|
  member .branchtablexmldoc    is PMLXmlDocument
 
   -- member for storing valid S types for Valve filtering (Technip Custom feature)
  using namespace |PMLXmlDocument.PMLXmlDocument|
  member .valveTableXmlDoc      is PMLXmlDocument
  member .validsTypes           is ARRAY
 

  -- Register from
  !!appFormCntrl.registerForm(!this)

exit
-- End of form definition

------------------------------------------------------------------------
--
-- Method:      componentEditor
--
-- Description: Constructor method
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .componentEditor()

  -- code JFH-AS
  using namespace |PMLXmlDocument.PMLXmlDocument|
  !this.BranTxt.foreground = 2
  
  -- TECHNIP CUTSOM CODES
  -- Setting the default units for bore as inches for the component editor form.
  -- This code will set the units for bore as Inch temporary 
  -- Once the component editor form is closed the units will be reset to the the default project units   
  -- This unit change is applicable to the current user session and for other sessions the units will be either project units / user specified units (if any)

  
  -- reload the form that set the default units for dimensions in E3D and set the default unit for bore as inches
  pml reload form !!COMFORMATSSELECT
  !!COMFORMATSSELECT.init()
  !!COMFORMATSSELECT.setBoreFromCS(2)
  
  
  -- Initialise Variables
  !this.activeSpecIndex       = 0
  !this.currentComponentIndex = 0
  !this.currentFrameIndex     = 0
  !this.isValid               = FALSE
  !this.noLstuSpecs = 1
  !this.outSpec  = FALSE
  !this.checkForSnapDist      = true

  -- Temp settings
  !this.modifyActive           = FALSE
  !this.assemblyFrame.visible  = FALSE

  !warningIcon                = !!pml.getPathname('exclamation-32.png')
  !this.warningIcon.addPixMap(!warningIcon)

  !this.warningTask           = FALSE

  -- EDG Description
  !this.edgDescription        = 'Pipe Component Creation'

  -- Aid graphic numbers
  !this.tagID                 = !!aidNumbers.add('Pipe Component Creation')
  !this.branchTagID           = !!aidNumbers.add('Pipe Component Creation')
  !this.planeTagID            = !!aidNumbers.add('Pipe Component Creation')
  !this.tagChanges            = !!aidNumbers.add('Pipe Component Creation')
  !this.tagReselect           = !!aidNumbers.add('Pipe Component Creation')

  -- Set cancel callback
  !this.cancelCall            = '!this.close()'

  -- Configuration Info, options are DTXR = rText, DTXS = Stext, DTXT = dText, CATTEX = rText + Material Text
  !this.detailText            = ARRAY()
  !detailText[1]              = 'Full Description'
  !detailText[2]              = 'CATTEX'
  !this.detailText.append(!detailText)
  !detailText[1]              = 'R Text'
  !detailText[2]              = 'DTXR'
  !this.detailText.append(!detailText)
  !detailText[1]              = 'S Text'
  !detailText[2]              = 'DTXS'
  !this.detailText.append(!detailText)
  !detailText[1]              = 'T Text'
  !detailText[2]              = 'DTXT'
  !this.detailText.append(!detailText)
  !detailText[1]              = 'Catalogue Ref.'
  !detailText[2]              = 'CATR'
  !this.detailText.append(!detailText)

  -- make sure that the form icon list is available for the filmstrip
  !this.setIconList()
  -- Initialise first option
  !this.componentDetail       = 1
  -- initialise multi-bore and reducing component flags
  !this.multiBore             = false
  !this.reducingComponent     = false

  -- Filter settings
  !this.sTypeFilter           = FALSE

  -- Setup task panels
  !this.setTask('Initialise')

  !this.flow        = true
  !this.toHead.val  = FALSE
  !this.toTail.val  = TRUE
  !this.atoHead.val  = FALSE
  !this.atoTail.val  = TRUE

  -- Default Settings
  !this.readOptions()

  !this.componentFeedBack = object COMPONENTFEEDBACK()
  !this.componentFeedBack.form = !this

  !this.slopeList.pointGadget = !this.points

  --- use new componentEditData object to hide the gadget manipulation
  !this.componentData         = object COMPONENTEDITDATA('main',!this)
  !this.editComponentData     = object COMPONENTEDITDATA('modify',!this)

  -- Load Specifications
  -- this loads up the specList gadget it does it twice because there are two objects
  -- and they need to have a list of specs internally
  !this.componentData.setupSpecifications(!this.specList)
  !this.editComponentData.setupSpecifications(!this.specList)

  !this.modifyComponents.callback    = '!this.tabSelect('
  !this.selectComponents.callback    = '!this.tabSelect('
  !this.reselectComponents.callback  = '!this.tabSelect('
  !this.errorsFrame.callback         = '!this.tabSelect('

  -- add the direction control details
  using namespace 'Aveva.Model.Presentation'

  !this.directionControlActions = object DIRECTIONCONTROLACTIONS(!this)

  -- Add instances of .net control
  !this.dirCont = object DIRCONTROL()
  --add an event handler for the control
  !this.dirCont.addEventHandler('onReturnedValue', !this.directionControlActions, 'onReturnedValue')
  --add an event handler for the control
  !this.dirCont.addEventHandler('onMouseMoved', !this.directionControlActions, 'onMouseMoved')
  --add an event handler for the context
  !this.dirCont.addEventHandler('onChangeContext', !this.directionControlActions, 'onChangeContext')
  --add an event handler for the context
  !this.dirCont.addEventHandler('onFocusChange', !this.directionControlActions, 'onFocusChange')
  --add an event handler for the slope change
  !this.dirCont.addEventHandler('onSlopeChanged', !this.directionControlActions, 'onSlopeChanged')
  --add an event handler for the boltButtonPress
  !this.dirCont.addEventHandler('onBoltButtonPressed', !this.directionControlActions, 'onBoltButtonPressed')
  --add an event handler for point mode
  !this.dirCont.addEventHandler('onPointModeChanged', !this.directionControlActions, 'onPointModeChanged')

  -- use the slopeList element to populate the pipeSlope gadget
  !this.slopeList.setGadget(!this.pipeSlopeList)

  -- Add .net controls to PML containers
  !this.netdirContFrame.control = !this.dirCont.handle()
  -- reduce the direction control scale
  !this.dirCont.setscale(0.9)

  -- switch point mode off
  !this.dirCont.pointActive(FALSE)

  --set the dirCont iso mode to the piping defaults value
  !this.setIsoMode()

  -- the magic command to cause the reselect tab to refresh
  -----------------------------------------------------------
  -- ***********************************************************
  -- !!componentEditor.trackReselect(!!ce)
  -- ***********************************************************
  -----------------------------------------------------------
  -- the magic command to cause the reselect tab to refresh

  --setup the initial state of the currentMode member
  if (!this.modeButtonSave.unset()) then
    !this.modeButtonSave = TRUE
    -- true is forwards
  endif

  -- Set the 3D local view properties
  !!gph3DThumbnail(!this.localView)
  !this.localView.lcsgadget = FALSE
  !this.localView.rulers = FALSE

	-- code JFH-AS
	-- récupère le code du projet
	!project = current project
	!projectcode = !project.code()

	-- initialise le fichier XML pour les branch table
	!this.branchtablexmldoc = object PMLXmlDocument()
	!dfltsfile = object file(|%| & !projectcode & |DFLTS%\TPBranchtable\Spec_Branch.xml|)
	!this.branchtablexmldoc.load(!dfltsfile.fullname())
	-- !this.branchtablexmldoc.load('D:\01-Customers\Technip\dev\BranTable\BranTable\design\Branchtable.xml')

    -- Activate the "Use Bran Conn" toggle 
    !this.branConn.val = true
	!this.setbranConn(true)


    -- TECHNIP Custom Codes
	-- initialise the PML object for Valve Filtering
    using namespace 'PMLXmlDocument.PMLXmlDocument'
	!this.valveTableXmlDoc  =  object PMLXmlDocument()
	!dfltsfile = object file(|%| & !projectcode & |DFLTS%\Tpbranchtable\Valve_table.xml|)
	!this.valveTableXmlDoc.load(!dfltsfile.fullname())

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      tagSelect
--
-- Description: Method called by selecting any of the main tabs.
-- This is an open callback so the passed parameters are
-- gadget name and action. We are only looking for the SHOWN event
--
--
------------------------------------------------------------------------
define method .tabSelect(!object is GADGET, !action is  STRING  )

  AID CLEAR ALL $!<this.tagChanges>
  handle any
  endhandle

  --forwards

  if (!this.elementIsComponentOrBranch(!!ce).not()) then
    return
  endif

  -- respond to the modify tab
  if (!object.eq(!this.modifyComponents)) then
    if (!action.eq('SHOWN')) then
      --switch to the Modify tab
      !this.setTask(|MODIFYCOMPONENT|)
      -- set the mode without changing the save button state
      !this.setMode(!this.modeButtonSave,FALSE)
    else
      !this.modeButtonSave = !this.mode.val
      -- set the mode without changing the save button state
      !this.setMode(TRUE,FALSE)
      !this.mode.visible = FALSE
    endif
    return
  endif

  if (!object.eq(!this.selectComponents)) then
    if (!action.eq('SHOWN')) then
      --check if the branch spec is restricted
      !restricted = !this.branchSpec.pSpec.restricted
      handle any
        !this.setTask(|SELECTCOMPONENT|)
      elsehandle none
        if !restricted then
          !this.setBranch()
          !this.resumeTask()
          return
        else
          !this.setTask(|SELECTCOMPONENT|)
        endif
      endhandle
      if(!this.component.badRef().not()) then
        !this.getArriveLeaveData(!this.branch, !this.component)
      endif
      --switch to the select tab
      if (!this.currentTask.neq(|SELECTCOMPONENT|)) then
        --this resets the spec to be the current default spec when we move to the select tab
        !this.resetSpec()
      endif
      !this.componentList.select('DTEXT',!this.componentType.val)
      handle ANY
      endhandle
    else
      -- currently no actions for unselect
    endif
    return
  endif

  -- respond to the reselect tab
  if (!object.eq(!this.reselectComponents)) then
    if (!action.eq('SHOWN')) then
      --switch to the Reselect tab
      !this.setTask(|RESELECT|)
      !this.tagReselect()
      -- we need to track just to update the select
      !this.mode.visible = FALSE
    else
      -- try to go back to where we were before reselect was selected
      !!ce = !this.component
      handle ANY
        !!ce = !this.branch
        handle ANY
        endhandle
      endhandle
    endif
    return
  endif

  if (!object.eq(!this.errorsFrame)) then
    if (!action.eq('SHOWN')) then
      --switch to the Errors task
      !this.setTask(|ERRORS|)
    else
      -- currently no actions for unselect
    endif
    return
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      loadGadgets
--
-- Description: Responsible for loading the component gadgets
-- in both select and reselect modes. At some point this needs to
-- be re-factored for ease of understanding
--
--
------------------------------------------------------------------------
define method .loadGadgets(!spec is DBREF,!componentType is STRING,!mode is STRING)

  !this.componentData.pipingSpecs.setActiveSpecification(!spec)
  !this.editComponentData.pipingSpecs.setActiveSpecification(!spec)
  !this.activeSpecification = !spec

  if (!mode.eq('create')) then

    -- Populate Component List  with available components
    !this.componentList.dText = !this.componentData.pipingSpecs.activeSpec().descriptions
    !this.componentList.rText = !this.componentData.pipingSpecs.activeSpec().types

    -- code JFH-AS
	!this.componentList.dtext[29] = 'Bran Conn.'
    !this.componentList.rtext[29] = 'BRANCONN'
	
    !this.componentList.select('rtext',!componentType)
    handle any
      !this.componentList.select('rtext','ELBO')
      handle any
        !this.componentList.val = 1
      endhandle
    endhandle
    -- now we need to get the appropriate components
    -- switch off the gadgets modifyTag mLine adjacentType adjacentSelect modifyDone
    !this.modifyGadgets(FALSE)


    -- Modification inactive
    !this.modifyActive  = FALSE
    !componentObject            = !this.componentData.componentObject(!componentType)
    -- test to see if the component can have adjacent components
    !this.createAdjacent.active = !componentObject.adjacentComponents().set()
    !this.adjacentSpec.active = !componentObject.adjacentComponents().set()
    -- turn the out of spec selection of if we are not out of spec
    !this.adjacentSpec.visible = !this.outSpec
  else
    !this.componentData.selectSpecification(!spec)
  endif
  !this.specList.select('RTEXT', !spec.string())
  handle ANY
  endhandle

  if (!mode.eq('create')) then
    -- Display gadgets
    !this.componentGadgets(true)
  endif

  !this.loadComponents(!mode)
  if (!mode.eq('create')) then
    !this.componentData.initialiseFrame(!componentType)
    -- click on the first item
    !this.selectChoice()
    !this.componentTabs.active = true
  else
    !this.displayChoices('edit')
    !this.editComponentData.initialiseFrame(!componentType)
  endif
   -- set the branch main gadgets back if coming from the reselect task
  if (!!ce.owner.neq(!this.branch).and(!!ce.neq(!this.branch))) then
    !this.setBranchGadgets(FALSE)
  else
    !this.setBranchGadgets(TRUE)
  endif

  !this.setActive(TRUE)

endmethod

------------------------------------------------------------------------
--
-- Method:     .branchHasMoved()
--
-- Description: compares the current branch position with the stored one
-- returns true if the branch has moved
--
------------------------------------------------------------------------
define method .branchHasMoved() is BOOLEAN
  if (unset(!this.branch.hPosition) or unset(!this.branchHeadPosition) or unset(!this.branch.tPosition) or unset(!this.branchTailPosition)) then
    return FALSE
  endif
  if ((!this.branch.hPosition.wrt(/* ).neq(!this.branchHeadPosition)) or (!this.branch.tPosition.wrt(/* ).neq(!this.branchTailPosition))) then
    !this.branchHeadPosition = !this.branch.hPosition.wrt(/* )
    !this.branchTailPosition = !this.branch.tPosition.wrt(/* )
    return TRUE
  else
    return FALSE
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      .track(!type is STRING)
--
-- Description: track method for either db changed event or CE change
-- different actions are required for each
--
------------------------------------------------------------------------
define method .track(!type is STRING)

  --Prevent Pipe Router Syntax Error if we are in router
  var !a banner
  if (!a.upCase().occurs('ROUTER').gt(0)) then
    return
  endif

  if (defined(!!inassembly)) then
    return
  endif

  if (!!ce.badRef()) then
    return
  endif

  -- Check if we are at a branch or below and set the form activation
  if (!this.elementIsComponentOrBranch(!!ce)) then
    !this.setActive( TRUE )
    handle any
    endhandle
    !this.filmStrip()
  else
    !this.setActive( FALSE )
    AID CLEAR ALL $!<this.tagID>
    AID CLEAR ALL $!<this.tagReselect>
    !this.connected.untag()
    !this.directionControlActions.aidclear()
    !this.componentFeedBack.element(!!ce)
    return
  endif

  if (!this.branch.set() and badRef(!this.branch) eq FALSE) then
    if (!type.eq('Navigate').and(!this.branchHasMoved())) then
      !this.tagBranchHeadTail(!this.branch, TRUE)
    endif
  elseif (!this.warningTask eq FALSE and !this.branch.set()) then
    !this.setBranch(!!ce)
    !!alert.warning('The branch has become unset or has been deleted. The branch has been reset to the branch of the current element.')
  endif

  !this.track()

endmethod
------------------------------------------------------------------------
--
-- Method:      track
--
-- Description: Track Current Element
--
-- main method called from 'DBCHANGED' and 'DESICE'  events
--
------------------------------------------------------------------------
-- the purpose of tracking is to maintain the current task and keep its gadgets up to date
-- for component creation.
define method .track()


  -- untag the current element
  !this.connected.untag()

  -- stops tracking errors when navigating during type select needs to be removed if the types tag goes
  if (!this.currentTask.eq('SELECTTYPE')) then
    return
  elseif (!this.currentTask.eq('SELECTCOMPONENT').or(!this.currentTask.eq('MODIFYCOMPONENT'))) then
    -- this is where it sets the mode back
    if (!!ce.owner.neq(!this.branch).and(!!ce.neq(!this.branch))) then
      !this.setBranchGadgets(FALSE)
    else
      !this.setBranchGadgets(TRUE)
    endif

    -- Check for deleted element
    if(badRef(!this.component)) then
      !this.component = object DBREF()
      AID CLEAR ALL $!<this.tagID>
      --return
    endif


    -- 140468 Assemblies error because the spref is not set and it goes on to look for bores and all sorts of things not available
    if (!!ce.attlist.findFirst('SPREF').set()) then
      if (!!ce.spRef.unset()) then
        return
      endif
    endif

  endif

  -- Don't do anything if passed element is same as current component
  if (!this.checkForCurrentComponent()) then
    -- not sure if this is needed any more
    --return
  endif

  -- added because the ribbon bar can show the form with modify active and no current task
  if (!this.modifyComponents.selected.and(!this.currentTask.neq( 'MODIFYCOMPONENT'))) then
    !this.setTask('MODIFYCOMPONENT')
  endif
  if (!this.selectComponents.selected.and(!this.currentTask.neq('SELECTCOMPONENT')and(!this.currentTask.neq('MODIFY')))) then
    !this.setTask('SELECTCOMPONENT')
  endif
  if (!this.reselectComponents.selected.and(!this.currentTask.neq( 'RESELECT'))) then
    !this.setTask('RESELECT')
  endif

  -- if we are in modify mode we need to align the direction control handler with the
  -- current element
  if (  !this.currentTask.eq( 'MODIFYCOMPONENT')) then
    --first check that the current element is a piping component on a branch.
    --in this case the !!ce dDepth should always be 5 and the owner should be a branch
    !this.directionControlModeChange()
    !this.component = !!ce
    if (!!ce.type.eq('BRAN').or(!!ce.type.eq('TUBI'))) then
      !this.setModifyGadgets(FALSE )
    else
      !this.setModifyGadgets(TRUE )
    endif

    --!this.checkForCurrentComponent()
    -- Run method which checks piping component (not MDS) and de-activates modify gadgets if not
    !this.trackModify(!!ce)

    -- new method to get slope
    -- try a new setting to deal with branches
    !this.slopeList.setbranchSlope(!!ce)

    -- this updates the slope feedback text to whatever the direction is
    !this.currentSlopeText.val = !this.slopeList.getElementSlopes(!!ce)
    handle ANY
      --q var !!error
    endhandle

    --!this.specGadgets(FALSE)
    return
  endif

  --if the current task is not reselect then track it
  -- Track to current element
  -- if the current task is reselect we just want to provide the available components
  if (!this.currentTask.eq('RESELECT')) then
    if (!!ce.type.eq('BRAN')) then
      !this.reselectComponents.active = FALSE
      AID CLEAR ALL $!<this.tagReselect>
      -- now we need to set up the list of slope values
      !sloEle = !!ce.sloRef
    endif
    !this.reselectComponents.active = TRUE
    !this.trackReselect(!!ce)
    !this.setSpecMode()
    !this.tagReselect()
    --!this.checkForCurrentComponent()
  else
    !this.track(!!ce)
    !this.setSpecMode()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      .setDirectionControlElement(!element is DBREF )
--
-- Description: calls the direction control element tracking
--
--      DBREF       Element to track form to
--
------------------------------------------------------------------------
define method .setDirectionControlElement(!element is DBREF )

  --deactivate the modify tab gadgets if the current element type is TUBI
  if (!element.spRef.set().and(!!ce.type.neq('TUBI'))) then
    !this.directionControlActions.ce()
  else
    !this.directionControlActions.default()
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      .trackBranch
--
-- Description: calls the direction control element tracking
--
--      DBREF       Element to track form to
--
------------------------------------------------------------------------
define method .trackBranch()

  if (!this.currentTask.eq('MODIFYCOMPONENT')) then

    !this.slopeList.setbranchSlope(!!ce)

  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      track(element is DBREF)
--
-- Description: Track with respect to passed element
--
--      DBREF       Element to track form to
--
------------------------------------------------------------------------
define method .track(!passedElement is DBREF)

  -- Initialise Variables
  !element    = !passedElement

  -- Check if valid branch is set
  if(!this.isValid.not()) then
    return
  endif

  -- Handle deleted elements  ??? how would we get an invalid element ????
  if(badRef(!element)) then
    !element  = !this.branch
  endif

  -- Tidy reference data. If we have created new components and they have been deleted we need to tidy
  -- the list of new components
  !this.tidy()

  -- If type is TUBI, then get the element it relates to
  if(!element.type eq 'TUBI') then
    !element  = !element.string().after('OF').dbRef()
  endif

  if !element.type.eq('PIPCA') then
    return
  endif

  -- Determine we are at a branch or below. If we are above branch level the set branch button is disabled.
  !branch  = !this.getBranch(!element)
  if(!branch.unset()) then
    !this.selectBranch.active = FALSE
    return
  else
    if( !element.owner.type eq 'BRAN') then
      if( badref(!element.spRef) ) then
        -- unset spref on component
        return
      endif
    endif
    !this.selectBranch.active = true
  endif

  if (!this.elementIsComponentOrBranch(!element).not()) then
    return
  endif

  if (!this.currentTask.eq( 'MODIFYCOMPONENT')) then
    -- fix for 80288 where it is in the modify component task and its trying to reset the create gadgets
    return
  endif

  -- this may be a step too far but the next method does all the tagging and gathering of data
  !this.getArriveLeaveData(!branch,!element)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      trackReselect
--
-- Description: Track with respect to passed element
-- This should only be called when we are in reselect mode
--
--
------------------------------------------------------------------------
define method .trackReselect(!passedElement is DBREF)

  -- Initialise Variables
  !element    = !passedElement

  if (!element.type.eq('BRAN')) then
    !this.setActive( FALSE)
    return
  endif
  -- we are at a component so now we need to check if its owned by the current branch
  -- this deactivates the branch gadgets if we are re-selecting from a different spec
  if (!element.owner.neq(!this.branch)) then
    !this.setBranchGadgets(FALSE)
  else
    !this.setBranchGadgets(TRUE)
  endif

  --P-17089: If the TUBI's are shown on the design explorer then this little routine
  -- sets the !element variable to be the component that has the leave tube.
  if (!element.type.eq('TUBI')) then
    !elementName = !element.string()
    !elementName = '=' + !elementName.after('=')
    !element = !elementName.dbRef()
  endif

  -- this was commented out for some reason but putting it back means it fixes 87268
  !this.component = !element

  --- set the edit component to the currently tracked element
  !this.editcomponent = !element

  -- set the current bore on the select tab
  !arrive = !element.arrive
  handle ANY
    -- we are at a branch or the component has no spref
    !arrive = 1
  endhandle

  -- go and get the bore text in case of two bores
  !this.editCurrentBore.val = !this.setReselectBoreGadget(!element)

  -- Check if we have access to modify the component
  if(!!dbrefUpdate(!element).not()) then
    !!alert.warning('Unable to modify ' & !element.flnn & '.')
    !this.setActive(false)
    return
  endif

  -- check if the current component is from a piping spec
  !current = !element.spown
  handle any
    -- no spec
  elsehandle NONE
    if (!current.unset().not()) then
      if !current.name.match('LIMBO').gt(0) then
        !!alert.warning(!element.flnn & ' is in LIMBOSPEC')
      else
        !test = !this.editComponentData.pipingSpecs.specIndex(!current)
        if (!test.unset()) then
          !!alert.warning(!element.flnn & ' is not from a current piping spec and new components are restricted. New components may be added from other specs or existing components re-selected')
          !this.setActive(false)
          --return
        endif
      endif
    endif
  endhandle

  -- test for errors on the current component and populate the error list
  !this.testForComponentErrors(!element)

  ------------------ Get Current Component Information ------------------
  -- sets !this.editComponent !this.editComponentType !this.branch !this.editComponentPosition
  -- !this.arriveBore !this.leaveBore and !this.lastModified
  !this.getComponentDetail(!element)

  -- Check if both bore are unset
  if(!this.arriveBore.unset().and(!this.leaveBore.unset())) then
    !!alert.warning('Unable to derive arrive or leave bore of component.')
    return
  endif

  if (!this.activeComponent.unset()) then
    if (!this.editComponent.unset().not()) then
      !this.setActiveComponent(!this.editComponent )
    endif
  endif

  if (!this.activeComponent[1].component().neq(!this.editComponent)) then
    !this.setActiveComponent(!this.editComponent )
  endif

  -- Get bore indices
  -- this finds the arrive bore and sets !this.checkBore which is a bore object
  -- need to investigate !this.checkBore further
  !checkBoreIndex   = !this.activeComponent[1].checkBoreIndex()
  if(!checkBoreIndex gt 0) then
    !this.checkBore = !this.editComponent.ppBore[!checkBoreIndex]
    handle any
      !this.checkBore = object BORE()
    endhandle
  else
    !this.checkBore = object BORE()
  endif

  -- Allow Reconnections
  !this.getConnectedElements()

  !displayString                  = !element.flnn
  !this.editComponentName.val     = !displayString.subString(1,27)

  -- test to see if the component has moved
  !this.editTest()

  -------------------- Load Specification Information -------------------
  -- this loads all the lists for reselect
  -- Setup spec for components specification
  !spec = !element.spow
  handle any
    !spec = !element.owner.pSpec
  elsehandle NONE
    if (!spec.badRef()) then
      !spec = !element.owner.pSpec
    endif
  endhandle
  -- Handle unset specRef of components and limboSpec

  if (!spec.name.match('LIMBO').gt(0) or !this.editComponentData.pipingSpecs.references.findFirst(!this.currentSpecification).unset()) then
    -- stop it loading an invalid spec
    return
  endif

  !this.componentSpecification()


  --CW checks to see if we are on a multi-bore component

  !this.checkComponents('edit')

  -- addition  to set the current filter value
  if (!element.type inset ('REDU','COUP','FLAN')) then
    if (!arrive.eq(2)) then
      !this.editReduA2L1.val = TRUE
      !this.editReduA1L2.val = FALSE
      !this.arriveLeave(2,1,|edit|)
    else
	   !this.editReduA2L1.val = FALSE
      !this.editReduA1L2.val = TRUE
      !this.arriveLeave(1,2,|edit|)
    endif
  endif
  if (!this.multiBore.not()) then
    !this.editReduA2L1.active = FALSE
    !this.editReduA1L2.active = FALSE
  else
    !this.editReduA2L1.active = TRUE
    !this.editReduA1L2.active = TRUE
  endif

  !this.selectOptions()

  -- align texts
  -- sort out the colouring of out of spec etc
  !this.alignSpecList()

  !this.displayTubes(!this.editComponent, 'RESELECT')

endmethod
-- end of trackReselect method

------------------------------------------------------------------------
--
-- Method:      setReselectBoreGadget(!element)
--
-- Description: returns a string of the current components bore values
-- Designed to give better feedback of current bores
--
------------------------------------------------------------------------
define method .setReselectBoreGadget(!element is DBREF)is STRING

  if (!element.type.eq('BRAN')) then
    return !element.hBore.string()
  endif

  -- set the current bore on the select tab
  !arrive = !element.arrive
  handle ANY
    -- we are at a branch or the component has no spref
    return !element.owner.hBore.string()
  endhandle

  !leave = !element.leave

  !arriveBore = !element.ppbor[!arrive]
  handle ANY
    !arriveBore = !element.owner.members[!element.order - 1]
    handle ANY
      !arriveBore = !element.owner.hBore
    endhandle
  endhandle

  !leaveBore =  !element.ppbor[!leave]
  handle ANY
    !leaveBore = !element.owner.members[!element.order + 1]
    handle ANY
      !leaveBore = !element.owner.tBore
    endhandle
  endhandle

  if (!element.type inset('OLET','TEE','VTWA')) then
    -- always give
    !arriveBore = !element.ppbor[1]
    handle ANY
      !arriveBore = !element.owner.members[!element.order - 1]
      handle ANY
        !arriveBore = !element.owner.hBore
      endhandle
    endhandle
    !leaveBore = !element.ppbor[3]
    handle ANY
      !leaveBore = !element.owner.members[!element.order + 1]
      handle ANY
        !leaveBore = !element.owner.tBore
      endhandle
    endhandle
    return !arriveBore.string() & ' x ' & !leaveBore.string()
  endif
  -- new bit to show current and reduced bore
  if (!arriveBore.eq(!leaveBore)) then
    return !arriveBore.string()
  else
    return !arriveBore.string() & ' x ' & !leaveBore.string()
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      setTask
--
-- Description: Switch the relevant panels in and out for passed task
--
--
------------------------------------------------------------------------
define method .setTask(!formTask is STRING)

  if (!formTask.eq(!this.currentTask)) then
    return
  endif

  -- Initialise Variables
  !activeTask       = !this.currentTask
  !task             = !formTask.upCase()
  !this.currentTask = !task

  -- Remove any red highlighting for re-selection as this will be retagged if necessary
  !this.connected.untag()

  -- Initialise all task gadgets
  if(!task eq 'INITIALISE') then
    !this.warningGadgets(false)
    !this.typeGadgets(false)
    !this.componentGadgets(false)
    !this.modifyGadgets(false)
    !this.specGadgets(TRUE)
    return
  endif

  ------- Remove existing task gadgets
  -- TM moved to separate method for ease of reading
  !this.removeActiveTask()

  ------------ Show alternative specification selection gadgets
  if(!task eq 'SETSPECIFICATION') then
    !this.setSpecificationTask()
    ------------ Show component selection and creation gadgets
  elseif (!task eq 'SELECTCOMPONENT') then
    !this.specList.select('rtext',!this.branchSpecification.string() )
    handle ANY
    endhandle
    -- align the spec text with the branch setting
    !this.setSpecText(TRUE)
    -- go and get all the components
    !this.setSelectComponentTask()
    -- remove other graphical aids
    AID CLEAR ALL $!<this.tagReselect>
    !this.directionControlActions.aidclear()

    ------------ Show component modification gadgets
  elseif (!task eq 'MODIFY') then
    -- this method is for displaying alternative components not for showing the modify tab
    -- Display Gadgets
    !this.modifyGadgets(true)
    !this.setActive(TRUE)
    ------------ Show component type selection gadgets
  elseif (!task eq 'SELECTTYPE') then
    -- this fills the component list with the types in the selected spec
    if !this.currentSpecification.restricted.or(!this.componentData.pipingSpecs.references.findFirst(!this.currentSpecification).unset()) then
       return
    endif
    !this.setSelectTypeTask()
  elseif (!task eq ('RESELECT')) then
    !this.track()
    -- remove other graphical aids
    AID CLEAR ALL $!<this.tagID>
    !this.directionControlActions.aidclear()

    ------------ Show warning gadgets
  elseif (!task eq 'WARNING') then
    !this.warningGadgets(TRUE)
    -- Remember previous task
    !this.currentTask = !activeTask
  elseif (!task.eq('MODIFYCOMPONENT')) then
    -- make modify gadgets active (may need re-activating if previously de-activated for a non piping spec component)
    !this.setModifyGadgets(TRUE )
    !gadgetArray[0] = !this.dirCont.slope()
    -- set up the current slope mode based on the direction control slope button setting
    !this.directionControlActions.onslopeChanged(!gadgetArray)
    !this.setSlopeGadgets()
    -- we are at a component so now we need to check if its owned by the current branch
    -- this is where it sets the mode back
    if (!this.elementIsComponentOrBranch(!!ce)) then
      if (!!ce.owner.neq(!this.branch).and(!!ce.neq(!this.branch))) then
        !this.setBranchGadgets(FALSE)
      else
        !this.setBranchGadgets(TRUE)
      endif
    else
      !this.setActive(FALSE)
    endif
    -- fix to stop the direction control feedback appearing in other tasks
    if (!this.elementIsComponent(!!ce)) then
      !this.directionControlModeChange()
    endif
    !this.mode.visible = TRUE

    if (!!ce.type.eq('BRAN').or(!!ce.type.eq('TUBI'))) then
      !this.setModifyGadgets(FALSE )
    else
      !this.setModifyGadgets(TRUE )
    endif
    -- Run method which checks piping component (not MDS) and de-activates modify gadgets if not

    !this.trackModify(!!ce)
    -- remove all other graphical aids
    AID CLEAR ALL $!<this.tagReselect>
    AID CLEAR ALL $!<this.tagID>

  elseif (!task.eq('ERRORS')) then
    !this.errorsFrame.selected = true
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      resumeTask
--
-- Description: Revert to current task after a warning
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------

define method .resumeTask()

if !this.elementIsComponentOrBranch(!!ce) then
   !this.warningGadgets(false)
   Branch
   !this.isValid = true
   !this.branch = !!ce
else
   return
endif

!this.track()
handle any
endhandle

-- Set alternative
  !this.selectAlternativeSpec(!this.branchSpecification)
  handle any
  endhandle

if !this.currentTask.eq('MODIFYCOMPONENT') then
  !this.setTask('RESELECT')
endif


  !this.setSelectComponentTask()
  !this.setTask(!this.currentTask)

  !this.isValid = true
  if !this.currentSpecification.restricted.or(!this.componentData.pipingSpecs.references.findFirst(!this.currentSpecification).unset()) then
    !this.componentGadgets(false)
  endif


endmethod
-- End of method definition


------------------------------------------------------------------------
--
-- Method:      removeActiveTask
--
-- Description: Clear the current active task before setting a new one
--
--
------------------------------------------------------------------------
define method .removeActiveTask()

  !activeTask       = !this.currentTask
  -- Remove warning task
  if(!this.warningTask) then
    -- hide the warning gadgets
    !this.warningGadgets(false)
  else
    -- Remove component selection task
    if(!activeTask eq 'SETSPECIFICATION') then

      !this.specGadgets(TRUE)
      -- Remove create task
    elseif (!activeTask eq 'SELECTCOMPONENT') then
      !this.componentGadgets(false)

      -- Remove modify task
    elseif (!activeTask eq 'MODIFY') then
      !this.undo.endUndoable()
      !this.modifyGadgets(FALSE)
      -- Remove Select component type task
    elseif (!activeTask eq 'SELECTTYPE') then
      !this.typeGadgets(false)
      !this.checkBore = object BORE()
    endif
    !this.checkBore = object BORE()
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      setSpecificationTask
--
-- Description: set specification task actions
--
--
------------------------------------------------------------------------
define method .setSpecificationTask()

  -- Modification inactive
  !this.modifyActive  = FALSE

  -- Select current alternative specification
  if(!this.alternativeSpec.unset()) then
    !this.specList.clearSelection()
  else
    !this.specList.select('rText',!this.alternativeSpec.string())
    handle ANY
    endhandle
  endif

  -- Display gadgets
  !this.specGadgets(true)
  -- set the branch main gadgets back if coming from the reselect task
  !this.setBranchGadgets(TRUE)

endmethod

------------------------------------------------------------------------
--
-- Method:      setSelectComponentTask(!type)
--
-- Description: set select component task using a passed type
--
------------------------------------------------------------------------
define method .setSelectComponentTask(!componentType is STRING)
AID CLEAR ALL $!<this.tagChanges>
  --
  if (!this.currentTask.eq('')) then
    !this.currentTask =  'SELECTCOMPONENT'
  endif
  -- add some code here to check if the branch has been set

  -- switch off the gadgets modifyTag mLine adjacentType adjacentSelect modifyDone
  !this.modifyGadgets(FALSE)
  -- Modification inactive
  !this.modifyActive  = FALSE

  -- Display gadgets
  !this.componentGadgets(true)

  !componentObject            = !this.componentData.componentObject(!componentType)

  -- test to see if the component can have adjacent components
  !this.createAdjacent.active = !componentObject.adjacentComponents().set()
  !this.adjacentSpec.active = !componentObject.adjacentComponents().set()

  -- Maintain Component Data Frame
  --!this.editComponentData.initialiseFrame(!componentType)

  -- fill the component selection gadgets with the correct components.
  -- this is the only place where the components are loaded into the choices frame
  !spec = !this.specList.selection('rText').dbRef()
  if !this.specList.selection('Dtext').eq('Restricted') then
    -- we have found a restricted spec in setSelectComponent task so we are not going to load any component detail
    -- we should probably do some form tidying here
  else

      !this.loadGadgets(!this.specList.selection('rText').dbRef(),!componentType,'create')
  endif
  -- set the branch main gadgets back if coming from the reselect task
  if (!!ce.owner.neq(!this.branch).and(!!ce.neq(!this.branch))) then
    !this.setBranchGadgets(FALSE)
  else
    !this.setBranchGadgets(TRUE)
  endif

  -- turn the out of spec selection off if we are not out of spec
  !this.setActive(TRUE)

endmethod

------------------------------------------------------------------------
--
-- Method:      setSelectComponentTask
--
-- Description: set select component task actions
--
------------------------------------------------------------------------
define method .setSelectComponentTask()

  AID CLEAR ALL $!<this.tagChanges>
  --
  if (!this.currentTask.eq('')) then
    !this.currentTask =  'SELECTCOMPONENT'
  endif
  -- add some code here to check if the branch has been set

  -- switch off the gadgets modifyTag mLine adjacentType adjacentSelect modifyDone
  !this.modifyGadgets(FALSE)
  -- Modification inactive
  !this.modifyActive  = FALSE

  -- Display gadgets
  !this.componentGadgets(true)
  -- Check if there are any associated components
  if !this.elementIsComponent(!!ce) then
      !componentType = !!ce.type
  else
      !componentType = 'ELBO'
  endif

  !componentObject            = !this.componentData.componentObject(!componentType)


  -- test to see if the component can have adjacent components
  !this.createAdjacent.active = !componentObject.adjacentComponents().set()
  !this.adjacentSpec.active = !componentObject.adjacentComponents().set()

  -- Maintain Component Data Frame
  --!this.editComponentData.initialiseFrame(!componentType)

  -- fill the component selection gadgets with the correct components.
  -- this is the only place where the components are loaded into the choices frame
  !spec = !this.specList.selection('rText').dbRef()
  if !this.specList.selection('Dtext').eq('Restricted') then
    -- we have found a restricted spec in setsselectcomponent task so we are not going to load any component detail
    -- we should probably do some form tidying here
    !this.componentTabs.active = false
    !this.componentGadgets(false)
    !this.lstuFrame.visible = FALSE
  else
      !this.loadGadgets(!this.specList.selection('rText').dbRef(),!componentType,'create')
  endif
  -- set the branch main gadgets back if coming from the reselect task
  if (!!ce.owner.neq(!this.branch).and(!!ce.neq(!this.branch))) then
    !this.setBranchGadgets(FALSE)
  else
    !this.setBranchGadgets(TRUE)
  endif

  -- turn the out of spec selection off if we are not out of spec
  !this.setActive(TRUE)

endmethod
------------------------------------------------------------------------
--
-- Method:      setSelectTypeTask
--
-- Description: This is called when initialising the form to set up the
-- list of types for the current spec
--
--
------------------------------------------------------------------------
define method .setSelectTypeTask()

  -- Modification inactive
  !this.modifyActive  = FALSE

  -- Set Creation Specification
  !this.setAlternativeSpec()

  -- Unselect component type selected
  !this.componentList.clearSelection()

  -- load the lists??
  !this.loadComponents('create')

  -- Show gadgets
  !this.typeGadgets(true)
  !this.setActive(TRUE)

  -- set the branch main gadgets back if coming from the reselect task
  !this.setBranchGadgets(TRUE)

  --!this.currentTask = 'SELECTTYPE'

endmethod

------------------------------------------------------------------------
--
-- Method:      setActiveComponent
--
-- Description: set the active component
--
--
------------------------------------------------------------------------
define method .setActiveComponent(!element is DBREF )

  -- Setup currently active component object
  !this.activeComponent.clear()
  !this.activeComponent[1] = !this.editComponentData.componentObject(!element.type)
  !this.activeComponent[1].component(!element)
  handle ANY
    --!!alert.error('error in setting active component - error is ' & !!error.text)
  endhandle

endmethod
-- end of method
------------------------------------------------------------------------
--
-- Method:      .getComponentDetail
--
-- Description: Current Element get form details for the passed element
--
--
------------------------------------------------------------------------
define method .getComponentDetail(!element is DBREF )

  ------------------ Get Current Component Information ------------------

  -- Make passed component the current component
  !this.editComponent         = !element
  !this.editComponentType     = !element.type
  !this.branch                = !element.owner
  --!this.editComponentType.val = !element.type
  --!this.connected.clear()
  !this.editComponentPosition = !this.editComponent.position
  !this.arriveBore            = object BORE()
  !this.leaveBore             = object BORE()

  -- Set last modified time
  var !lastModified LASTM of $!<element>
  !this.lastModified          = object DATETIME(!lastModified)

  -- Get bore of previous and next element/branch
  !sequence                   = !this.editComponent.sequence + 1
  if (!!isImperialLength('BORE')) then
    !hboreString = !!comValueConvert(!this.branch.hBore.real(),'INCH').string()
    !tboreString = !!comValueConvert(!this.branch.tBore.real(),'INCH').string()
  else
    !hboreString = !!comValueConvert(!this.branch.hBore.real(),'MM').string()
    !tboreString = !!comValueConvert(!this.branch.tBore.real(),'MM').string()
  endif
  var !aBores evaluate (ABORE) for members of $!<this.branch> ignore ANY ''
  !aBores.insert(1,!hboreString)
  !aBores.append(!tboreString)
  var !lBores evaluate (LBORE) for members of $!<this.branch> ignore ANY ''
  !lBores.insert(1,!hboreString)
  !lBores.append(!tboreString)

  -- Get arrive bore
  do !i from !sequence - 1 to 1 by -1
    skip if(!lBores[!i].eq(''))
    !this.arriveBore  = !lBores[!i].bore()
    break
  enddo

  -- Get leave bore
  do !i from !sequence + 1 to !aBores.size()
    skip if(!aBores[!i].eq(''))
    !this.leaveBore   = !aBores[!i].bore()
    break
  enddo

  if (!this.arriveBore.unset().or(!this.leaveBore.unset())) then
    if(!this.arriveBore.unset()) then
      !this.arriveBore        = !this.leaveBore
    else
      !this.leaveBore         = !this.arriveBore
    endif
  endif

  -- Get component stype information
  if(!this.editComponent.spRef.unset()) then
    !this.editSType               = STRING()
  else
    !this.editSType               = !this.editComponent.sType
    handle ANY
      !this.editSType             = STRING()
    endhandle
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      .getConnectedElements
--
-- Description: gets the brconnect elements for the reconnect button
--
--
------------------------------------------------------------------------
define method .getConnectedElements()
  -- if the component needs reconnecting the isReconnectionRequired()returns true
  -- so we don't want to redefine !this.connected.
  if (!this.connected.isReconnectRequired()) then
    return
  endif

  -- Allow Reconnections
  !this.connections           = !this.editComponent.brConnect
  handle any
    -- If component has no spref brConnect does not exist so try and build the connections array manually.
    !currentElement = !!ce
    !!ce = !this.editComponent
    previous
    handle any
    elsehandle NONE
      !this.connections.append(!!ce)
    endhandle
    !!ce = !this.editComponent
    next
    handle any
    elsehandle none
      !this.connections.append(!!ce)
    endhandle
    !!ce = !currentElement
  endhandle

  !this.connections.append(!this.editComponent)
  !this.connected.componentReconnect(!this.editComponent, !this.connections)
  handle any
    -- If component has no spref this function may fail so handle any error and carry on.
  endhandle

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      editTest
--
-- Description: test if current element has been moved
--
--
------------------------------------------------------------------------
define method .editTest()

  -- We need to check if component has been modified
  if(!this.editComponent.set()) then

    -- If we are at the same component, do we need to refresh
    if(!this.editComponent.eq(!!ce)) then

      -- Check if the component has been modified
      !repositioned = !this.editComponent.position.neq(!this.editComponentPosition)

      -- Date Time last modified
      var !lastModified LASTM of $!<this.component>
      handle ANY
        -- put in for cases where the current element has been deleted
        return
      endhandle
      !dtm  = object DATETIME(!lastModified)
      !this.setActive(true)

      -- If the last modified data is different from the stored last modified
      -- (both greater and less than, should handle undo/redo/modified)
      if(!dtm.neq(!this.lastModified)) then

        -- If reconnection is available, don't update
        if (!this.reconnectAvailable.set()) then
          if(!this.reconnectAvailable) then
            if(!repositioned) then
              !this.updateComponent()
            endif
            return
          endif
        endif

        -- Element not modified
      else
        if(!repositioned) then
          !this.updateComponent()
        endif
        return
      endif

    endif

  endif
endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      .getArriveLeaveData
--
-- Description: examine the current component, gather the relevant data.
-- and perform tagging etc
--
------------------------------------------------------------------------
define method .getArriveLeaveData(!branch is DBREF,!element is DBREF )

  -- Get Arrive and Leave information for new component and tag point
  if(!branch eq !this.branch) then

    -- Retain old bores
    !oldArriveBore  = !this.arriveBore
    !oldLeaveBore   = !this.leaveBore

    -- Skip connected items
    if(!this.skipConnected and !element.type ne 'BRAN') then

      -- Get connected components
      !connected    = !element.brConnect
      handle(2,201)
        !connected = ARRAY()
      endhandle
      -- TM attas with spkbrk FALSE always have 0 atlen and ltlen so brcon identifies adjacent components
      if (!element.type.eq('ATTA')) then
        if (!element.spkbrk.not()) then
          !connected = ARRAY()
        endif
      endif
      if(!connected.set()) then

        -- Add element to list
        !connected.append(!element)
        !components = !!componentOrder(!connected)

        if(!this.flow) then
          !element  = !components.last()
        else
          !element  = !components.first()
        endif
      endif
    endif

    -- Assign element to component
    !this.component             = !element

    -- Component is a branch
    if(!this.component.type eq 'BRAN') then
      if(!this.flow) then
        !this.componentPosition = !element.hPosition
        !this.tubeOD = !element.phod
        handle ANY
          !this.tubeOD = 0
        endhandle
        !this.wallTH = !element.hwallt
        handle ANY
          !this.wallTH = 0
          !this.getSpecomWall(!this.component.hstube)
          handle ANY
          endhandle
        endhandle
      else
        !this.componentPosition = !element.tPosition
        !this.tubeOD = !element.ptod
        handle ANY
          !this.tubeOD = 0
        endhandle
        !this.wallTH = !element.twallt
        handle ANY
          !this.wallTH = 0
          !this.getSpecomWall(!this.component.hstube,!this.arriveBore)
          handle ANY
          endhandle
        endhandle
      endif
    else
      !this.componentPosition   = !element.position
      if (!this.flow) then
        !this.tubeOD = !element.lod
        handle ANY
          !this.tubeOD = 0
        endhandle
        !this.wallTH = !element.lwallt
        handle ANY
         if !element.type.eq('PTAP') then
            !this.wallTH = !this.getAlternateWall(!element)
          else
            !this.wallTH = 0
          endif
        endhandle
      else
        !this.tubeOD = !element.aod
        handle ANY
          !this.tubeOD = 0
        endhandle

        !this.wallTH = !element.awallt
        handle ANY
          if !element.type.eq('PTAP') then
            !this.wallTH = !this.getAlternateWall(!element)
          else
            !this.wallTH = 0
          endif

        endhandle
      endif
    endif

    -- Get the adjacent components
    !this.adjacent()

    -- Determine arrive bore for new component
    !bores            = !this.adjacentBores(!this.component, !this.flow)

    !this.arriveBore  = !bores[1]
    !arrivePosition   = !this.componentPosition(!this.component, !this.flow)
    !arriveDirection  = !this.componentDirection(!this.component, !this.flow)
    !this.leaveBore   = !bores[2]

    -- Define the tag point
    !this.tagPoint    = object POINTVECTOR(!arrivePosition, !arriveDirection)
    handle (2,785)
      -- error where an unset item is passed to track
      -- often caused by undo deleting the current element
      return
    endhandle

    -- If the bore changes, then we need to re-evaluate the selected components
    if(!oldArriveBore.neq(!this.arriveBore).or(!oldLeaveBore.neq(!this.leaveBore))) then
      !this.filterComponents('create')
    endif

    -- Show Current Bore
    !this.currentBore.val = !this.arriveBore.string(!!boreFmt)

    -- Tag Position
    if (!this.currentTask.eq('SELECTCOMPONENT') OR !this.currentTask.eq('MODIFY')) then
      !this.tag()
    elseif (!this.currentTask.eq('RESELECT')) then
      !this.tagReselect()
    endif
    --Lstu Tube available selections
    !this.displayTubes(!element,'create')
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:     .getAlternateWall
--
-- Description: gets the arrive or leave tube wall thickness for PTAPS
--
-----------------------------------------------------------------------
define method .getAlternateWall(!element is DBREF) is REAL

   if (!this.flow) then
      -- try the leave tube
      !return = !element.ltwall
      handle any
        !return = !element.atwall
        handle any
          return 0
        endhandle
      endhandle
   else
      !return = !element.atwall
      handle any
        !return = !element.ltwall
        handle any
          return 0
        endhandle
      endhandle
   endif

   return !return

  endmethod


------------------------------------------------------------------------
--
-- Method:      .checkForCurrentComponent()
--
-- Description: Checks to see if ce is the current active component
--
------------------------------------------------------------------------
define method .checkForCurrentComponent() is BOOLEAN

  !return = FALSE

  if(!!ce eq !this.component) then
    if(!this.component.type eq 'BRAN') then
      if(!this.flow) then
        !position             = !this.component.hPosition
      else
        !position             = !this.component.tPosition
      endif
    else
      !position               = !this.component.position
    endif

    -- Check if the component has been modified
    if !this.componentPosition.unset() then
      !this.componentPosition = N0
    endif

    if(!position ne !this.componentPosition) then
      !this.componentPosition = !position
      handle any
      endhandle
      -- Tag information
      !arrivePosition         = !this.componentPosition(!this.component, !this.flow)
      !arriveDirection        = !this.componentDirection(!this.component, !this.flow)
      !this.tagPoint          = object POINTVECTOR(!arrivePosition, !arriveDirection)
      handle ANY
        return TRUE
      endhandle

      if (!this.currentTask.eq('SELECTCOMPONENT')) then
        !this.tag()
      elseif (!this.currentTask.eq('RESELECT')) then
        !this.tagReselect()
      endif
    endif

    !return = TRUE

  endif

  return !return

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setupOptions
--
-- Description: Setup options frame to current settings
--
--
------------------------------------------------------------------------
define method .setupOptions()

  -- set up the appropriate gadget
  !this.adjacentSpec.val    = !this.autoCreateSpec
  !this.skipConn.val        = !this.skipConnected
  !this.createAdjacent.val  = !this.autoCreate
  !this.componentData.getMinTubeLengthDataCon()

  -- We only need to setup the options in the .connected object if we are in reselect mode
  if (!this.currentTask.eq('RESELECT')) then
    --setup the options in the .connected object
    !this.connected.reconnectEnds(!this.connectFreeEnds)
    !this.connected.ignorePositioned(!this.ignorePositioned)
  endif
  -- even though were not in the re-select task we still need to set the connected constraints if they are changed in the select task
  !this.connected.tag = !this.tagConstraints

  if (!!ce.type.eq('WORL')) then
    return
  endif

  if (!!ce.owner.type.neq('BRAN')) then
    return
  endif

  if (!!ce.owner.type.eq('BRAN')) then
    !a = !!ce.arrive
    !this.currentBore.val = !!ce.ppbor[!a].string()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setOption
--
-- Description: Set creation of adjacent components
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      STRING      Option setting
--
------------------------------------------------------------------------
define method .setOption(!option is STRING)

  -- set form gadget settings when their matching toggle is pressed or otherwise setup
  if (!option eq 'skipConnected') then
    !this.skipConnected()
  elseif (!option eq 'createAdjacent') then
    !this.autoCreate = !this.createAdjacent.val
    if (!this.autoCreate.not().or(!this.outSpecName.val.eq( 'Select From Spec' ))) then
      !this.adjacentSpec.visible = !this.outSpec
    else
      !this.adjacentSpec.visible = !this.outSpec
    endif
  elseif (!option eq 'adjacentSpec') then
    !this.autoCreateSpec = !this.adjacentSpec.val
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      readOptions
--
-- Description: read in piping settings for this form that are now stored globally in !!pipingSettings
--
--
------------------------------------------------------------------------
define method .readOptions()

  -------------------------------------------------------
  ------TEMP MUST BE REMOVED AND PUT INTO PRODUCT STARTUP
  -------------------------------------------------------
  if (undefined (!!pipingSettings)) then
    !!pipingSettings = object PIPINGSETTINGS()
  endif
  -------------------------------------------------------
  ------TEMP MUST BE REMOVED AND PUT INTO PRODUCT STARTUP
  -------------------------------------------------------

  --Boolean settings
  !this.skipConnected     = !!pipingSettings.skipConnected
  
  --TECHNIP Custom codes
  -- Set the default behaviour of auto create button in the component editor as false so that it will not create
  -- adjacent components for creation of valves and other components
  !this.autoCreate        = FALSE
  --!this.autoCreate        = !!pipingSettings.autoCreate
  
  !this.autoCreateSpec    = !!pipingSettings.useAlternateSpec
  !this.autoAlign         = !!pipingSettings.autoAlign

  !this.tag = !!pipingSettings.tagComponent
  !this.tagConstraints = !!pipingSettings.tagConstraints
  !this.autoConnection = !!pipingSettings.autoReconnect
  !this.connectFreeEnds = !!pipingSettings.reconnectFreeEnds
  !this.ignorePositioned = !!pipingSettings.ignorePositioned
  -- are we able to use point direction mode?
  !this.multiSlope = !!pipingSettings.pointDirection
  handle any
    !this.multiSlope = TRUE
  endhandle
  !this.pointDirection.visible = !this.multiSlope
  !this.pointDirection.active = !this.multiSlope
  !this.pointDirection.val = FALSE
  -- turn the direction control pointmode button on and off
  -- set the ppoint selection gadget visibility on only if the point val is visible and checked
  !this.points.visible = FALSE
  !!componentEditor.dirCont.pointActive(FALSE)
  !this.componentFeedBack.mode = !this.pointDirection.val

  !this.dirCont.pointMode(0)
  if (!this.pointDirection.val) then
    !this.directionText.val = 'Component Direction'
  else
    !this.directionText.val = 'Direction'
  endif
  --value or expression options
  !snap  = !!pipingSettings.snapDist

  if !snap.eq('Datacon') then
     !this.componentData.minTubeLengthExp = STRING()
     !this.componentData.snapDistanceVal   = REAL()
     -- if both values are unset it's using datacon
  else
     !this.componentData.snapDistanceVal  = !snap.real(!!distanceFmt)
     handle any
       !this.componentData.snapDistanceExp = !snap
     endhandle
  endif

  !minTube = !!pipingSettings.minTube
  if !minTube.eq('Datacon') then
     !this.componentData.minTubeLengthExp  = STRING()
     !this.componentData.minTubeLengthVal  = REAL()
     -- if both values are unset its using datacon
  else
     !this.componentData.minTubeLengthVal = !minTube.real(!!distanceFmt)
     handle any
       !this.componentData.minTubeLengthExp = !minTube
     endhandle
  endif

  --setup the direction control iso mode from defaults
  !this.setIsoMode()

  --display options
  !textDesc = !!pipingSettings.descriptions
  do !i from 1 to !this.detailText.size()
    if (!textDesc.eq(!this.detailText[!i][2])) then
      !this.componentDetail   = !i
      break
    endif
  enddo
  !this.displayChoices('create')
  handle ANY
  endhandle
  !this.displayChoices('edit')
  handle ANY
  endhandle

  -- Setup form for defaults
  !this.setupOptions()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      close
--
-- Description: Close form
--
--
------------------------------------------------------------------------
define method .close()

  -- Initialise Variables
  !this.newComponent  = object DBREF()
  !this.branch        = object DBREF()

  -- ensure Forwards mode for ongoing work
  FORWARDS

  -- Clear lists
  !this.newComponents.clear()
  !this.multipleSelect.clear()

  -- Remove applications events from system
  !!edgCntrl.remove(!this.edgDescription)

  -- Hide all Aid graphics for utility
  AID CLEAR ALL $!<this.tagID>
  AID CLEAR ALL $!<this.branchTagID>
  AID CLEAR ALL $!<this.tagChanges>
  AID CLEAR ALL $!<this.tagReselect>

  -- turn any red highlighting off
  !this.connected.untag()

  --clear any outstanding aids coming from the direction control
  !this.directionControlActions.aidclear()

  --clear any direction feedback arrows
  !this.componentFeedBack.clear()
  
  
  -- TECHNIP CUTSOM CODES
  -- Setting the default units for bore as inches for the component editor form.
  -- This code will set the units for bore as Inch temporary 
  -- Once the component editor form is closed the units will be reset to the the default project units   
  -- This unit change is applicable to the current user session and for other sessions the units will be either project units / user specified units (if any)
    --!formatset = object COMFORMATS()
    --!inchformat = object format()
    ---- defining the parameters / properties of format for representation
    --var !UNITS UNITS
    --q var !UNITS
    --if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
      --$p Hello
      --!inchformat.units = 'MM'
      --!inchformat.Label= 'mm'
      --!inchformat.TrailZeros = FALSE
		--
	--endif
    ----
    ------ Setting the default units for bore as Inches for the current session
    --!formatset.setGlobalBoreFormat(!inchformat)
    
    !!COMFORMATSSELECT.setBoreFromCS(1)
    kill !!componenteditor
    --pml reload form !!componenteditor
    

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      tidy
--
-- Description: Tidy reference data
--
--
------------------------------------------------------------------------
define method .tidy()

  -- Check if new component(s) have been deleted
  if(badRef(!this.newComponent)) then

    -- Remove new component from list
    !this.newComponent = object DBREF()

    -- Clear lists
    !this.newComponents.clear()

    -- control the flip button
    -- new policy for the flip button always visible but now active/inactive
    !this.flip.active = FALSE

    -- Setup reselection of adjacent components
    !this.adjacentClear()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      tag
--
-- Description: Tag current position
--
--
------------------------------------------------------------------------
define method .tag()

  -- Initialise Variables
  AID CLEAR ALL $!<this.tagID>

  if (!this.tag) then
    -- Display bore
    if(!this.flow) then
      !this.currentBore.val = !this.arriveBore.string(!!boreFmt)
    else
      !this.currentBore.val = !this.arriveBore.string(!!boreFmt)
    endif

    -- Tag Current Position
    !this.createTag.val = 'Creation from ' & !this.component.flnn
    handle ANY
      -- for occasions when !this.component is unset (I don't know why the component should be unset)
      return
    endhandle

    -- Proportion
    !proportion   = 0.4
    -- Offset Arrow parallel to route
    !offset       = !this.arriveBore.real() * 1
    handle ANY
      return
    endhandle
    !orthDir      = !this.tagPoint.direction.orthogonal(U)
    handle ANY
      !orthDir    = !this.tagPoint.direction.orthogonal(N)
    endhandle
    !offsetDir    = !orthDir.orthogonal(!this.tagPoint.direction)
    !tagPosition  = !this.tagPoint.position.offset(!offsetDir, !offset)
    !height       = !this.arriveBore.real()
    !oHeight      = !offset * 2
    !cHeight      = !height
    !cPosition    = !tagPosition.offset(!this.tagPoint.direction, !cHeight / 2)
    AID CYLINDER NUMBER $!<this.tagID>  AT $!<cPosition>   ORI Z IS $!<this.tagPoint.direction>  HEIGH $!<cHeight> DIAM 4mm FILLED ON
    AID CYLINDER NUMBER $!<this.tagID>  AT $!<this.tagPoint.position> ORI Z IS $!<offsetDir>     HEIGH $!<oHeight> DIAM 4mm FILLED ON
    AID ARROW    NUMBER $!<this.tagID>  AT $!<tagPosition> DIRECTION $!<this.tagPoint.direction> HEIGH $!<height> PROPORTION $!<proportion>
    -- Current element pointer
    if(!this.skipConnected.not()) then
      !direction  = !offsetDir.opposite()
      !nHeight    = (!oHeight - !this.arriveBore.real() - 10mm) / 2
      AID ARROW  NUMBER $!<this.tagID>  AT $!<tagPosition> DIRECTION $!<direction> HEIGH $!<nHeight> PROPORTION 0.75
    endif
    -- Show current component type
    !fullType     = !this.component.fullType
    !type         = !fullType.subString(1,1) & !fullType.subString(2).lowCase()
    AID TEXT    NUMBER $!<this.tagID> '$!<type>' AT $!<tagPosition>
    -- Refresh Alternate changes
    if(!this.currentTask.eq('MODIFY')) then
      !this.tagChanges()
    endif
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      tagChanges
--
-- Description: Tag change components
--
--
------------------------------------------------------------------------
define method .tagChanges()

  -- Initialise Variables
  AID CLEAR ALL $!<this.tagChanges>

  -- Mark all the components to be changed
  !detail = !this.adjacentType.selection('DTEXT')
  !type   = !this.adjacentType.selection('RTEXT').dbRef().type
  handle ANY
    return
  endhandle

  do !component values !this.newComponents
    skip if(!component.type ne !type)

    -- Offset Arrow parallel to route
    !offset       = !component.aBore.real() * 1.5
    !orthDir      = !component.aDirection.orthogonal(D)
    handle ANY
      !orthDir    = !component.aDirection.orthogonal(S)
    endhandle
    !offsetDir    = !orthDir.orthogonal(!component.aDirection)
    !tagPosition  = !component.position.offset(!offsetDir, !offset)
    !offsetDir    = !offsetDir.opposite()
    !message      = 'Alternate ' & !detail.lowCase() & ' available'
    AID TEXT  NUMBER $!<this.tagChanges> '$!message' AT $!<tagPosition>
    AID ARROW NUMBER $!<this.tagChanges> AT $!<tagPosition> DIRECTION $!<offsetDir> HEIGHT $!<offset>

  enddo

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      tagReselect
--
-- Description: Tag re-select components
--
--
------------------------------------------------------------------------
define method .tagReselect()

  -- Remove aid graphics
  AID CLEAR ALL $!<this.tagReselect>

  -- Tag Current Position
  if(!this.tag and !this.elementIsComponent(!!ce)) then

    -- Proportion
    !proportion   = 0.5

    -- Define tag point
    !arriveBore   = !this.arriveBore
    !aDirection   = !!ce.aDirection
    handle ANY
      return
    endhandle
    --!aPosition    = !this.activeComponent[1].baseClass().alignmentPosition
    !aPosition    = !!ce.position
    !tagPoint     = object POINTVECTOR(!aPosition, !aDirection.opposite())
    handle any
    endhandle

    -- P-13343: If a component with no spref gets through to here as a fail safe handle the errors that are caused and carry on.
    -- Directions
    !orthDir      = !tagPoint.direction.orthogonal(U)
    handle ANY
      !orthDir    = !tagPoint.direction.orthogonal(N)
      handle any
      endhandle
    endhandle
    !offsetDir    = !orthDir.orthogonal(!tagPoint.direction)
    handle any
    endhandle

    -- Define dimensions
    !od           = !!ce.aod
    handle any
    elsehandle NONE
      !oHeight      = !od * 2
      !aHeight      = !od * 1

      -- Positions
      !tagPosition  = !tagPoint.position.offset(!offsetDir, !od)
      !arPosition   = !tagPosition.offset(!aDirection, !aHeight)
      !cPosition    = !tagPosition.offset(!aDirection, !aHeight * 0.5)

      -- Graphics
      AID CYLINDER NUMBER $!<this.tagReselect>  AT $!<cPosition>  ORI Z IS $!<aDirection>   HEIGH $!<aHeight> DIAM 4mm FILLED ON
      AID CYLINDER NUMBER $!<this.tagReselect>  AT $!<aPosition>  ORI Z IS $!<offsetDir>    HEIGH $!<oHeight> DIAM 4mm FILLED ON
      AID ARROW    NUMBER $!<this.tagReselect>  AT $!<arPosition> DIRECTION $!<tagPoint.direction> HEIGH $!<aHeight> PROPORTION $!<proportion>

      -- Show current component type
      !fullType     = !!ce.fullType
      !detail       = !fullType.subString(1,1) & !fullType.subString(2).lowCase()
      !type         = !detail & '(' & !!ce.tysequ & ')'
      AID TEXT    NUMBER $!<this.tagReselect> '$!<type>' AT $!<tagPosition>
    endhandle

  endif

  -- Display connected constraints
  !this.connected.tag()

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      adjacent
--
-- Description: Set the adjacent elements for the component
--
--
------------------------------------------------------------------------
define method .adjacent()

  -- Get Next and Previous items
  !adjacent       = !this.adjacent(!this.component, !this.flow)
  !this.next      = !adjacent[1]
  !this.previous  = !adjacent[2]

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      adjacent
--
-- Description: Set the adjacent elements for the component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to get adjacent from
--    2   R      BOOLEAN     Flow direction, true for forwards
-- Return:
--   [Data Type] [Description]
--    ARRAY       2 element array, previous and next elements
--
------------------------------------------------------------------------
define method .adjacent(!component is DBREF, !flow is BOOLEAN) is ARRAY

  -- Current component is a Branch
  if(!component.type eq 'BRAN') then
    -- If there are no components
    if(!component.mCount eq 0) then
      !adjacent[1]    = !component
      !adjacent[2]    = !component
      -- Only single component exists
    elseif (!component.mCount eq 1) then
      !adjacent[1]    = !component
      !adjacent[2]    = !component.member[1]
      -- More than one component
    else
      if(!flow) then
        !adjacent[1]  = !component
        !adjacent[2]  = !component.members.first()
      else
        !adjacent[1]  = !component
        !adjacent[2]  = !component.members.last()
      endif
    endif
    -- Component
  else
    -- Previous Component
    var !previousPP split PREVPP of $!<component>
    !previous   = !previousPP[3].dbRef()
    -- P30435 if the previous or next component is a spkbrk FALSE atta it is not picked up in tube.
    do
      if (!previous.type.eq('ATTA')) then
        if (!previous.spkbrk.not()) then
          var !previousPP split PREVPP of $!<previous>
          !previous  = !previousPP[3].dbRef()
        else
          break
        endif
      else
        break
      endif
    enddo

    -- Next Component
    var !nextPP split NEXTPP of $!<component>
    !next       = !nextPP[3].dbRef()
    do
      if (!next.type.eq('ATTA')) then
        if (!next.spkbrk.not()) then
          var !nextPP split NEXTPP of $!<next>
          !next   = !nextPP[3].dbRef()
        else
          break
        endif
      else
        break
      endif
    enddo
    -- If the flow if reverse, then flip the previous and next
    if(!flow) then
      !adjacent[1]  = !previous
      !adjacent[2]  = !next
    else
      !adjacent[1]  = !next
      !adjacent[2]  = !previous
    endif
  endif

  -- Return
  return !adjacent

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      skipConnected
--
-- Description: Set skip connected flag
--
--
------------------------------------------------------------------------
define method .skipConnected()

  -- Set State
  !this.skipConnected = !this.skipConn.val

  -- Track to element
  !this.track(!this.component)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      flip
--
-- Description: Flip current created components
--
--
------------------------------------------------------------------------
define method .flip()

  -- Initialise Variables
  var !mode MODE
  !components = !this.newComponents
  !first      = !components.first()
  !last       = !components.last()

  -- Always work from head - tail
  !this.flow(true)
  -- Start of component group
  !sPosition  = !first.aPosition.wrt(World)
  !sDirection = !first.aDirection.wrt(World)
  !ePosition  = !last.lPosition.wrt(World)
  !eDirection = !last.lDirection.wrt(World)

  -- Determine the offset from the start to the end of the group
  !offset       = N0
  !offset.east  = !sPosition.east   - !ePosition.east
  !offset.north = !sPosition.north  - !ePosition.north
  !offset.up    = !sPosition.up     - !ePosition.up

  -- Re-order the components in the list
  !!ce  = !this.branch

  !item = !first

  !compList = !components
  !compList.compress()
  do !i from 2 to !compList.size()
    !component  = !compList[!i]
    REORDER $!<component> BEFORE $!<item>
    !item       = !component
  enddo

  -- Parallel Arrive/Leave
  if(!sDirection.isParallel(!eDirection)) then
    if(!sDirection.isParallel(!first.orientation.xDir()).not()) then
      !direction  = !sDirection.orthogonal(!first.orientation.xDir())
    elseif (!sDirection.isParallel(!first.orientation.yDir()).not()) then
      !direction  = !sDirection.orthogonal(!first.orientation.yDir())
    else
      !direction  = !sDirection.orthogonal(!first.orientation.zDir())
    endif
    !angle        = 180

    -- Non-parallel Arrive/Leave
  else
    -- Bisect direction between the start and end
    !direction    = !sDirection.bisect(!eDirection)
    !angle        = !sDirection.angle(!eDirection) * 2
  endif

  -- Loop through items, rotate and offset
  do !i indices !components
    !!ce = !components[!i]
    FLIP
    BY $!<offset>
    ROTATE THROUGH $!<sPosition> ABOUT $!<direction> BY $!<angle>
  enddo

  -- Save inverted list to new components
  !components.invert()
  !this.newComponents = !components

  -- Track current component
  --!this.track(!this.component)
  !this.tag()

  -- Revert to original mode
  $!<mode>

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setFlow
--
-- Description: Set creation flow
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for forwards, FALSE for backwards
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .setFlow(!forwards is BOOLEAN, !type is STRING )

  -- Initialise Variables
  !this.flow          = !forwards

  if (!type.eq('std')) then
    -- Head to Tail
    if(!forwards) then
      !this.toHead.val  = FALSE
      !this.toTail.val  = true
    else
      !this.toHead.val  = true
      !this.toTail.val  = FALSE
    endif
  else
    -- Head to Tail for assemblies
    if(!forwards) then
      !this.atoHead.val  = FALSE
      !this.atoTail.val  = true
    else
      !this.atoHead.val  = true
      !this.atoTail.val  = FALSE
    endif
  endif

  -- Set current component
  !this.track(!this.component)

  -- we have created a component at this point and we need to set its radius
  -- we have some options but at the moment the radius is set based on the form gadget setting.
  -- Calculates radius of a bend using N*OD option
  if (!this.componentType.val.upCase().eq('BEND')) then
    !radiusMultiplier = !this.bendRadiusOption.selection().real()
    handle ANY
      !radiusMultiplier = object REAL()
    endhandle
    if (!radiusMultiplier.set()) then
      !this.calculateRadius(!radiusMultiplier)
    endif
  endif
  -- No need to do anything if there is a selector so long as !radiusMultiplier is unset
  -- need something in the code at the time it populates the list to reset the radius option gadget.
  --

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      adjacentBores
--
-- Description: Returns the adjacent bores to the passed component, dependent
--              on the passed flow
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
--    2   R      BOOLEAN     Current creation flow direction.
-- Return:
--   [Data Type] [Description]
--    ARRAY      2 element array, [1] Arrive bore, [2] Leave bore
--
------------------------------------------------------------------------
define method .adjacentBores(!component is DBREF, !defaultFlow is BOOLEAN) is ARRAY
  -- Initialise Variables
  !bores        = ARRAY()
  !bore         = object BORE()
  !adjacent     = !this.adjacent(!component, !defaultFlow)
  -- Flows
  !flows[1]     = !defaultFlow
  !flows[2]     = !defaultFlow.not()
  !elements[1]  = !component
  !elements[2]  = !adjacent[2]

  -- Get arrive/leave bore
  do !i from 1 to 2
    !flow       = !flows[!i]
    !element    = !elements[!i]
    -- Branch
    if(!element.type eq 'BRAN') then
      if(!flow) then
        !bore   = !element.phBore
      else
        !bore   = !element.ptBore
      endif
      -- Component
    else
      -- Component with a specification reference
      if(!element.spRef.set()) then
        if(!flow) then
          !bore = !element.lBore
        else
          !bore = !element.aBore
        endif
        -- Component with no specification reference
      else
        -- Determine the bore from the upstream component
        if(!flow) then
          -- Component is first in the list
          if(!element.sequence eq 1) then
            !bore = !element.owner.hBore
            -- Roll back along the tube until we have an lBore
          else
            !from = !element.sequence - 1
            do !j from !from to 1 by -1
              if(!element.owner.members[!j].spRef.set()) then
                !bore = !element.owner.members[!j].lBore
                break
              endif
            enddo
            if(!bore.unset()) then
              !bore = !element.owner.hBore
            endif
          endif
          -- Determine the bore form the down stream component
        else
          -- Component is last in the list
          if(!element.sequence eq !element.owner.mCount) then
            !bore = !element.owner.tBore
          else
            do !j from !element.sequence + 1 to !component.owner.mCount
              if(!element.owner.members[!j].spRef.set()) then
                !bore = !element.owner.members[!j].aBore
                break
              endif
            enddo
            if(!bore.unset()) then
              !bore = !element.owner.tBore
            endif
          endif
        endif
      endif
      -- End of component
    endif
    -- Set arrive bore
    !bores[!i] = !bore
  enddo

  -- Return
  return !bores

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      componentPosition
--
-- Description: Returns the position of the passed component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
--    2   R      BOOLEAN     Current creation flow direction.
-- Return:
--   [Data Type] [Description]
--    POSITION    Position
--
------------------------------------------------------------------------
define method .componentPosition(!component is DBREF, !flow is BOOLEAN) is POSITION

  -- Initialise Variables
  !position     = object POSITION()

  -- Branch
  if(!component.type eq 'BRAN') then
    if(!flow) then
      !position = !component.hPosition
    else
      !position = !component.tPosition
    endif
    -- Component
  else
    !position = object POSITION()
    if(!flow) then
      !position = !component.lPosition
      handle(2,201)
      endhandle
    else
      !position = !component.aPosition
      handle(2,201)
      endhandle
    endif
    -- End of component
  endif

  -- Return
  return !position

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      adjacentPosition
--
-- Description: Returns the adjacent position to the passed component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
--    2   R      BOOLEAN     Current creation flow direction.
-- Return:
--   [Data Type] [Description]
--    POSITION    Position
--
------------------------------------------------------------------------
define method .adjacentPosition(!component is DBREF, !flow is BOOLEAN) is POSITION

  -- Initialise Variables
  !position       = object POSITION()
  -- Branch
  if(!component.type eq 'BRAN') then
    if(!flow) then
      !position   = !component.hPosition.wrt(world)
    else
      !position   = !component.tPosition.wrt(world)
    endif
    -- Component
  else
    if(!flow) then
      var !previousStr PREVPP of $!<component>
      !previous   = !previousStr.part(3).dbRef()
      if(!previous.type eq 'BRAN') then
        !position = !previous.hPosition.wrt(world)
      else
        !position = !previous.lPosition.wrt(world)
      endif
    else
      var !nextStr NEXTPP of $!<component>
      !next       = !nextStr.part(3).dbRef()
      if(!next.type eq 'BRAN') then
        !position = !next.tPosition.wrt(world)
      else
        !position = !next.aPosition.wrt(world)
      endif
    endif
    -- End of component
  endif

  -- Return
  return !position

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      componentDirection
--
-- Description: Returns the direction to the passed component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
--    2   R      BOOLEAN     Current creation flow direction.
-- Return:
--   [Data Type] [Description]
--    DIRECTION   Direction
--
------------------------------------------------------------------------
define method .componentDirection(!component is DBREF, !flow is BOOLEAN) is DIRECTION

  -- Initialise Variables
  !direction      = object DIRECTION()

  -- Branch
  if(!component.type eq 'BRAN') then
    if(!flow) then
      !direction  = !component.hDirection
    else
      !direction  = !component.tDirection
    endif
    -- Component
  else
    if(!flow) then
      !direction  = !component.lDirection
    else
      !direction  = !component.aDirection
      handle (2,201)
        -- occurs when spref unset. try opposite to leave
        !direction  = !component.lDirection.opposite()
        handle any
          -- this direction may not be correct, but must fall back to some direction
          !direction = !component.owner.tDirection
        endhandle
      endhandle
    endif
    -- End of component
  endif

  -- Return
  return !direction

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      adjacentDirection
--
-- Description: Returns the adjacent direction to the passed component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
--    2   R      BOOLEAN     Current creation flow direction.
-- Return:
--   [Data Type] [Description]
--    DIRECTION   Direction
--
------------------------------------------------------------------------
define method .adjacentDirection(!component is DBREF, !flow is BOOLEAN) is DIRECTION

  -- Initialise Variables
  !direction        = object DIRECTION()
  -- Branch
  if(!component.type eq 'BRAN') then
    if(!flow) then
      !direction    = !component.hDirection.wrt(world)
    else
      !direction    = !component.tDirection.wrt(world)
    endif
    -- Component
  else
    if(!flow) then
      var !previousStr PREVPP of $!<component>
      !previous     = !previousStr.part(3).dbRef()
      if(!previous.type eq 'BRAN') then
        !direction  = !previous.hDirection.wrt(world)
      else
        !direction  = !previous.lDirection.wrt(world)
      endif
    else
      var !nextStr PREVPP of $!<component>
      !next         = !nextStr.part(3).dbRef()
      if(!next.type eq 'BRAN') then
        !direction  = !next.tDirection.wrt(world)
      else
        !direction  = !next.aDirection.wrt(world)
      endif
    endif
    -- End of component
  endif

  -- Return
  return !direction

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      getBranch
--
-- Description: Returns branch from passed element
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Passed element
-- Return:
--   [Data Type] [Description]
--    DBREF       Branch
--
------------------------------------------------------------------------
define method .getBranch(!element is DBREF) is DBREF

  -- Get owning types
  !pTypes   = !element.ahlist
  !pTypes.append(!element.type)
  !index    = !pTypes.findFirst('BRAN')

  -- No branch above current element
  if(!index.unset()) then
    return object DBREF()
  else
    !parents  = !element.ownlst
    !parents.append(!element)
    return !parents[!index]
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setup
--
-- Description: Setup form on show for current element
--
--
------------------------------------------------------------------------
define method .setup()

  -- rebuild direction control to account for coord change
  !this.dirCont.buildcontrol()
  -- Initialise Variables
  !this.arriveBore      = object BORE()
  !this.newComponent    = object DBREF()
  !this.newComponents.clear()
  !this.multipleSelect.clear()
  !this.assemblyFrame.visible = FALSE
  -- fix to be able to show the form from a branch
  !this.currentComponentIndex = 1

  -- assembly tracking variable.
  if (defined(!!inassembly)) then
    !!inassembly.delete()
  endif

  --disable pointmode from the start
  !this.pointDirection.val = FALSE

  -- switch point mode off on the direction control
  !this.dirCont.pointActive(FALSE)

  -- Get Branch
  !branch                 = !this.getBranch(!!ce)

  -- Check that we have a branch
  if(!branch.unset()) then

     -- Initialise information
    !this.branchName.tag  = 'unset'
    --!this.currentSpec.val = ''
    !this.currentBore.val = ''
    !this.currentSpec.tag = ''
    !message              = ARRAY()
    !message.append('This FORM can only be used at a Branch or piping component.')
    !message.append('Navigate to a branch or component and use the "Set Branch" button.')

    -- Push into an error panel
    !this.warning(!message, FALSE)
    return
  endif


  -- Setup form to passed element
  !this.setBranch(!!ce)
  handle 21
    return
  endhandle

  -- set initial mode to forwards
  !this.setMode(!this.modeButtonSave,FALSE)
  handle any
    !this.setMode(TRUE,TRUE)
  endhandle

  -- Calculates radius of a bend using N*OD option
  !radiusMultiplier = !this.bendRadiusOption.selection().real()
  handle ANY
    !radiusMultiplier = object REAL()
  endhandle
  if (!radiusMultiplier.set()) then
    !this.calculateRadius(!radiusMultiplier)
  endif

  -- set default specification and out of spec gadgets
  !this.outSpecName.val       = 'Select From Spec'
  !this.outSpec = FALSE
  !this.adjacentSpec.visible  = !this.outSpec

  -- Move to elbo creation tab
  !this.componentData.pipingSpecs.setActiveSpecification(!this.currentSpecification)
  handle ANY
  endhandle
  !this.setFromIcon('ELBO')

  !this.minAngle.active = FALSE
  !this.maxAngle.active = FALSE
  !this.editMinAngle.active = FALSE
  !this.editMaxAngle.active = FALSE

  -- set the gadget values based on the defaults form
  !this.readOptions()
  !this.setupOptions()

  -- set the initial slope gadget to no slope (this changes the graphics to match the settings)
  -- the dirCont buildControl method needs to be updated to set the gadget visibility
  !this.dirCont.slope(0)

  !this.filmStrip()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      isValidBranch
--
-- Description: Check validity of branch before we continue
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   RW     ARRAY       Message array when invalid
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if branch is valid
--
------------------------------------------------------------------------
define method .isValidBranch(!message is ARRAY) is BOOLEAN


  !this.componentTabs.active = true
  -- Check Specification is Set
  if(!this.branch.pSpec.unset() or badRef(!this.branch.pSpec)    ) then
    !message  = ARRAY()
    !message.append('Unable to create component, branch does not have a valid pipe')
    !message.append('specification. Please set specification before creating components.')
    return FALSE
  elseif  (!this.branch.pSpec.restricted) then
    !message  = ARRAY()
    !name = !this.branch.pSpec.namn
    !message.append('Current branch specification ' &!name & ' is restricted')
    !message.append('and is not available for creating new components')
    !this.appendRestricted(!this.branch.pSpec)
    return FALSE
  endif

  !test = !this.componentData.pipingSpecs.references.findFirst(!this.branch.pSpec)
  if !test.unset() then
    !message  = ARRAY()
    !name = !this.branch.pSpec.namn
    !message.append('Current branch specification ' &!name & ' is not recognised as a current piping spec')
    !message.append('and cannot be used fo creating new components')
    !this.appendRestricted(!this.branch.pSpec)
    return FALSE
  endif
  -- Check bores are set
  if(!this.branch.hBore.unset() or !this.branch.tBore.unset()) then
    if(!this.branch.hBore.unset() and !this.branch.tBore.unset()) then
      !text     = 'as both the head and tail bores are unset'
      !boreText = 'bores'
    elseif (!this.branch.hBore.unset()) then
      !text     = 'as the head bore is unset'
      !boreText = 'the head bore'
    else
      !text     = 'as the tail bore is unset'
      !boreText = 'the tail bore'
    endif
    !message  = ARRAY()
    !message.append('Unable to create component, ' & !text & '.')
    !message.append('Please set ' & !boreText & ' before creating components.')
    return FALSE
  endif

  -- ensure there are no restricted specs when selecting a valid branch
  !this.removeRestricted()

  -- Check that head/tail have been defined
  if(!this.branch.lHead.not() or !this.branch.lTail.not()) then
    if(!this.branch.lHead.not() and !this.branch.lTail.not()) then
      !text     = 'as both the head and tail are not defined fully'
      !boreText = 'both the head and tail'
    elseif (!this.branch.lHead.not()) then
      !text     = 'as the head has not been fully defined'
      !boreText = 'the head'
    else
      !text     = 'as the tail has not been fully defined'
      !boreText = 'the tail'
    endif
    !message  = ARRAY()
    !message.append('Unable to create component, ' & !text & '.')
    !message.append('Please define ' & !boreText & ' before creating components.')
    return FALSE
  endif

  -- Return
  return true

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setBranch
--
-- Description: Setup form for current branch
--
--
------------------------------------------------------------------------
define method .setBranch(!passedElement is DBREF)


  -- Initialise Variables
  !element    = !passedElement

  if(badRef(!element)) then
    !element  = !!ce
  endif

  --make sure that if set branch is applied when the current element is TUBI, the current element is set
  --as the tubi owning component
  if (!passedElement.type.eq('TUBI')) then
    !element = !passedElement.ref
    !!ce = !element
  endif

  -- Get Branch
  !branch     = !this.getBranch(!element)

  -- If branch is unset we won't do anything
  if(!branch.unset()) then
    return error 21 noalert
  endif

  -- set the branch  top frame text -- moved to a new method so that it can be called from elsewhere
  -- Initialise Variables
  !this.branch        = !branch
  !this.arriveBore    = object BORE()
  !this.newComponent  = object DBREF()
  !this.newComponents.clear()
  !this.multipleSelect.clear()
  !this.branchSlope = !this.branch.sloRef
  if (!this.branchSlope.badRef()) then
    !this.slopeName.val ='unset'
    -- turn the slope off
    !this.dirCont.slope(0)
  else
    !this.slopeName.val = !this.branchSlope.namn
  endif

  !this.setBranchHeadingText()
  
  -- is it an HVAC branch
  if(!branch.owner.type.eq('HVAC')) then
    !message  = ARRAY()
    !message.append('Unable to modify HVAC Components, Please use the HVAC application')
    !this.warning(!message, FALSE)
    -- if we can't create it
    return error 21 noalert
  endif

  -- Have we got create access
  if(!!dbrefUpdatable(!branch).not()) then
    !message  = ARRAY()
    !message.append('Unable to modify branch, check access to modify and resolve')
    !message.append('or navigate to a branch with write access and press "Set Branch".')
    !this.warning(!message, FALSE)
    -- if we can't create it
    return error 21 noalert
  endif

  -- Is there a specification set for the branch?
  if(!branch.pspe.badRef()) then
    !message  = ARRAY()
    !message.append('Unable to modify branch, no specification has been set.')
    !this.warning(!message, FALSE)
    -- if we can't create it
    return error 21 noalert
  endif

   -- Clear adjacent information so that we don't see the adjacent options on an elbow
  !this.adjacentClear()

  -- Setup with current options -- load from the pdmsUser files

  -- needs to work with the piping defaults form
  !this.setupOptions()

  -- Setup default task (select component type)
  !this.setTask('SELECTTYPE')

  -- Setup insu and trace specs for current branch specification
  !this.otherSpecifications()
  handle 382
    return
  endhandle

  -- Set alternative
  !this.selectAlternativeSpec(!this.branchSpecification)
  handle any
  endhandle
  -- reset the spec gadgets to the current spec
  !this.setSpecText(TRUE)

  -- remove any graphical aids as these will be re-tagged in .track(!!ce)
  AID CLEAR ALL $!<this.tagID>
  AID CLEAR ALL $!<this.tagReselect>
  !this.directionControlActions.aidclear()

  -- Track current element
  !this.toHead.val  = !this.flow.not()
  !this.toTail.val  = !this.flow

  !this.branchHeadPosition = !this.branch.hPosition.wrt(/* )
  !this.branchTailPosition = !this.branch.tPosition.wrt(/* )
  -- Mark head and tail of branch
  !this.tagBranchHeadTail(!this.branch, TRUE)

 !message            = ARRAY()
  !this.isValid       = !this.isValidBranch(!message)
  if(!this.isValid.not()) then
    !this.warning(!message, false)
  return error 21 noalert
    -- when we show the warning task we abandon setting up the form and things from now on are ignored
    --- this section was moved from line 3723 to enable the setup branch function to complete
  endif

!this.track(!!ce)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      .appendRestricted
--
-- Description: insert a dummy specification at the top of the spec list
-- if the current spec is restricted or unclassified.
--
------------------------------------------------------------------------
define method .appendRestricted(!pSpec is DBREF)

if !this.specList.rText.findFirst(!pSpec.string()).set()then
   return
endif

if !this.specList.dText.findFirst('Restricted').set()then
   !this.removeRestricted()
endif

!dText =  !this.specList.dText
!rText =  !this.specList.rText
!dText.append('Restricted')
!rText.append(!pSpec.string())
!this.specList.dText = !dText
!this.specList.rText = !rText
-- now set the branch header text
!this.specList.select('rtext',!pSpec.string())

-- set the top text for name spec and bore
!this.setBranchHeadingText()
-- clear the component selection texts
!this.componentTabs.active = false
!this.choices.clear()
!this.componentGadgets(false)

endmethod

------------------------------------------------------------------------
--
-- Method:      .removeRestricted()
--
-- Description: remove a dummy specification at the end of the spec list
-- if the current spec is restricted or unclassified.
--
------------------------------------------------------------------------
define method .removeRestricted()

if !this.specList.dText.findFirst('Restricted').unset()then
   return
endif

!selection = !this.specList.val
!dText =  !this.specList.dText
!rText =  !this.specList.rText
!remove = !dText.findFirst('Restricted')
!dText.remove(!remove)
!rText.remove(!remove)
!this.specList.dText = !dText
!this.specList.rText = !rText
!this.setBranchHeadingText()
!this.componentTabs.active = true
--
!this.specList.select('rtext',!this.branchSpecification.string())
handle any
  !this.specList.val = 1
endhandle


endmethod

------------------------------------------------------------------------
--
-- Method:     .setBranchHeadingText()
--
-- Description: set the branch name and specification
--
--
------------------------------------------------------------------------
define method .setBranchHeadingText()

  -- Current bore of component
  !this.currentBore.val       = !this.branch.hBore.string(!!boreFmt)

  -- Setup current specification to branch spec
  !this.branchSpecification   = !this.branch.pSpec
  handle ANY
    !this.branchSpecification = object DBREF()
  endhandle
  !this.currentSpecification  = !this.branchSpecification

  -- Set Branch Information
  !this.branchName.tag        = !this.branch.flnn
  handle ANY
    !this.branchName.tag = 'unset'
    !this.branchName.active = false
  endhandle

  !this.currentSpec.tag       = !this.branchSpecification.flnn
  handle ANY
    !this.currentSpec.tag = 'unset'
    !this.currentSpec.active = false
  endhandle

 endmethod

------------------------------------------------------------------------
--
-- Method:      otherSpecifications
--
-- Description: get the insu and tracing specs
--
--
------------------------------------------------------------------------
define method .otherSpecifications()

  -- Insulation Specification
  !insulationSpec = !this.branch.iSpec
  if(!insulationSpec.unset()) then
    !this.insulation.select('rText','')
  else
    !this.insulation.select('rText', !insulationSpec.refNo.string())
    handle any
      if !insulationSpec.badRef().and(!insulationSpec.unset().not()) then
        !this.insulation.select('rText','')
        !this.componentTabs.active = false
        !this.componentGadgets(false)
        !!alert.warning('Branch Insulation Spec $!insulationSpec has been Deleted - Please reset the Branch Ispec to a valid reference')
        return error 382
      endif
    endhandle
  endif

  -- Tracing Specification
  !tracingSpec    = !this.branch.tSpec
  if(!tracingSpec.unset()) then
    !this.tracing.select('rText','')
  else
    !this.tracing.select('rText', !tracingSpec.refNo.string())
      handle any
      if !tracingSpec.badRef().and(!tracingSpec.unset().not()) then
        !this.tracing.select('rText','')
        !this.componentTabs.active = false
        !this.componentGadgets(false)
        !!alert.warning('Branch Tracing Spec $!tracingSpec has been Deleted - Please reset the Branch Tspec to a valid reference')
        return error 382
      endif
    endhandle
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      warning
--
-- Description: Set warning task and message
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      STRING       Warning message
--    2   R      BOOLEAN     True if Done button is allowed
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .warning(!message is STRING, !allowDone is BOOLEAN)
  !messageArray[1] = !message
  !this.warning(!messageArray, !allowDone)
endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      warning
--
-- Description: Set warning task and message
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      ARRAY       Warning message
--    2   R      BOOLEAN     True if Done button is allowed
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .warning(!message is ARRAY, !allowDone is BOOLEAN)

  -- Initialise Variables
  !display  = ''

  !this.setTask('warning')
  do !i indices !message
    !display = !display & ' ' & !message[!i]
  enddo

  !this.setTask('warning')
  !this.warning.val           = !display.trim()

  !this.warningDone.visible = !allowDone

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      warningGadgets
--
-- Description: Shows/Hides the gadgets associated with the spec task
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for show, FALSE for hide
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------

define method .warningGadgets(!show is BOOLEAN)

  -- Initialise Variables
  !this.warningTask           = !show
  !this.warningIcon.visible   = !show
  !this.warningTag.visible    = !show
  !this.wLine.visible         = !show
  !this.warning.visible       = !show

  !this.warningDone.visible = !show

  !this.tabs.visible           = !show.not()
  !this.componentTabs.visible  = !show.not()
  !this.outSpecName.visible    = !show.not()
  !this.specList.visible       = !show.not()
  !this.insulation.visible     = !show.not()
  !this.tracing.visible        = !show.not()
  !this.insulationText.visible     = !show.not()
  !this.tracingText.visible        = !show.not()
  !this.mode.visible = !show.not()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      specGadgets
--
-- Description: Shows/Hides the gadgets associated with the spec task
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for show, FALSE for hide
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .specGadgets(!show is BOOLEAN)

  -- Initialise Variables
  !this.specList.visible    = !show
  !this.insulation.visible  = !show
  !this.tracing.visible     = !show
  --!this.specDone.visible    = !show
  if(!show) then
    --!this.specDone.setFocus()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      componentGadgets
--
-- Description: Shows/Hides the gadgets associated with the create task
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for show, FALSE for hide
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .componentGadgets(!show is BOOLEAN)
  -- Initialise Variables

  !this.typelabel.visible           = !show
  !this.componentType.visible       = !show
  !this.componentType.visible       = !show
  !this.fLine.visible               = !show
  !this.sTypes.visible              = !show
  !this.selectComponents.selected   = !show
  !this.choices.visible             = !show
  !this.componentBendFrame.visible  = !show
  !this.createTag.visible           = !show
  !this.toTail.visible              = !show
  !this.toHead.visible              = !show

  if (!this.noLstuSpecs.gt(1)) then
    !this.lstuFrame.visible = !show
  else
    !this.lstuFrame.visible = FALSE
  endif

  !this.standardComponentFrame.visible = !show
  !this.createActions.visible       = !show
  !this.createAdjacent.visible      = !show
  !this.adjacentSpec.visible        = !this.outSpec
  !this.skipConn.visible            = !show


  -- Hide component specific panes
  !this.assemblyComponentFrame.visible = FALSE
  !this.createAssemblyActions.visible  = FALSE
  !this.componentElbowFrame.visible    = FALSE
  !this.componentBendFrame.visible     = FALSE
  !this.componentReduFrame.visible     = FALSE
  !this.componentTeeFrame.visible      = FALSE
  !this.assemblyFrame.visible          = FALSE
  !this.mode.visible                   = FALSE

  if(!show) then
    !this.choices.setFocus()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      modifyGadgets
--
-- Description: Shows/Hides the gadgets associated with the modify task
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for show, FALSE for hide
--
------------------------------------------------------------------------
define method .modifyGadgets(!show is BOOLEAN)

  !this.componentGadgets(!show.not())

  -- Initialise Variables
  !this.modifyTag.visible       = !show
  !this.mLine.visible           = !show
  !this.adjacentType.visible    = !show
  !this.adjacentSelect.visible  = !show
  !this.modifyDone.visible      = !show

  if(!show) then
    !this.mode.visible            = !show.not()
    !this.modifyDone.setFocus()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      typeGadgets
--
-- Description: Shows/Hides the gadgets associated with the select type task
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     True for show, FALSE for hide
--
------------------------------------------------------------------------
define method .typeGadgets(!show is BOOLEAN)

  -- Initialise Variables
  !this.assemblyFrame.visible = FALSE

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      setAlternativeSpec
--
-- Description: Use alternative specification
--
--
------------------------------------------------------------------------
define method .setAlternativeSpec()

  !this.currentSpecification = !this.specList.selection('rtext').dbRef()
  -- Switch active specification
  !this.setSpecification()

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      setSpecification
--
-- Description: Set the active specification
--
--
------------------------------------------------------------------------
define method .setSpecification()

  -- Only refresh when active spec is different from passed

  if !this.currentSpecification.restricted.or(!this.componentData.pipingSpecs.references.findFirst(!this.currentSpecification).unset()) then
     -- new code to avoid an error selecting an invalid spec
    return
  endif
    !this.componentData.pipingSpecs.setActiveSpecification(!this.currentSpecification)
    !this.editComponentData.pipingSpecs.setActiveSpecification(!this.currentSpecification)
    !this.activeSpecification = !this.currentSpecification

  -- Populate Component List  with available components
  !this.componentList.dText = !this.componentData.pipingSpecs.activeSpec().descriptions
  !this.componentList.rText = !this.componentData.pipingSpecs.activeSpec().types
  -- Populate Component List  with available components
  !this.editComponentList.dText = !this.componentData.pipingSpecs.activeSpec().descriptions
  !this.editComponentList.rText = !this.componentData.pipingSpecs.activeSpec().types

  !this.componentList.select('DTEXT',!this.componentType.val)
  handle ANY
    !this.componentList.val = 1
  endhandle

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectAlternativeSpec
--
-- Description: Select alternative specification
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Specification to select
--
------------------------------------------------------------------------
define method .selectAlternativeSpec(!alternativeSpec is DBREF)
  !this.specList.select('rtext',!alternativeSpec.string())
  if (!!ce.owner.type.eq('BRAN')) then
    !type = !this.componentList.selection()
    handle any
      !type = !!ce.type
    endhandle
    if (!type.unset()) then
      !this.componentList.select('rtext',!!ce.type)
      handle ANY
      endhandle
    endif
  endif

  -- this is the bit which decides its out of spec or not
  !this.setSpecMode()
  if (!this.currentTask.eq(|SELECTCOMPONENT|)) then
    -- do nothing at the moment
    -- we need to force a refresh of the lists
    !this.currentTask = ''
    -- just update the lists
    !this.setSelectComponentTask()
  elseif (!this.currentTask.eq('RESELECT')) then
    -- we are in reselect mode so we need to set the reselect gadget
    !this.editComponentData.selectSpecification(!alternativeSpec)
    !this.selectComponentType()
  elseif   !this.currentTask.eq(|SELECTTYPE|) then
    !this.currentTask = ''
    -- just update the lists
    !this.setSelectComponentTask()
  else
    --the task is undefined
    -- we need to do something if we change spec whilst in another task
    !this.setTask(|SELECTCOMPONENT|)
    return
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setSpecMode
--
-- Description: resets the spec text for out of spec or in spec
--
------------------------------------------------------------------------
define method .setSpecMode()

  -- the following method is identical for both selectComponent and reselect tasks
  -- previously there were two parts and they were different.

  if (!this.currentTask.eq(|SELECTCOMPONENT|).or(!this.currentTask.eq('RESELECT'))) then
    if (!this.specList.selection().dbRef().neq(!this.branchSpecification)) then
      !this.setSpecText(FALSE)
    else
      !this.setSpecText(TRUE)
    endif
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      .alignSpecList
--
-- Description: resets the current spec to the spec of the current element
-- the passed spec is the spec of the current component
--
------------------------------------------------------------------------
define method .alignSpecList( )

  !currentSpec = !!ce.spown
  if (!currentSpec.unset()) then
    !spec = 'unset'
  else
    !spec = !!ce.spown.flnn
  endif

  -- reset the spec gadgets based on the currentSpec

  !branchSpec = !!ce.owner.pspe
  !bspec = !branchSpec.flnn

  if (!branchSpec.eq(!currentSpec)) then
    !this.setSpecText(TRUE)
    !spec = 'Spec: ' & !spec
  else
    !this.setSpecText(FALSE)
    !spec = 'Spec: ' & '(' & !bspec & ')' & !spec
  endif

  !this.editCurrentSpec.val       = !spec
  !this.specList.select('rtext',!currentSpec.string() )
  handle ANY
    !this.specList.select('rtext',!branchSpec.string() )
    handle any
    endhandle
  endhandle

endmethod

------------------------------------------------------------------------
--
-- Method:      setSpecText
--
-- Description: toggles spec text so that the current spec settings are maintained.
--
------------------------------------------------------------------------
define method .setSpecText(!mode is BOOLEAN)

  -- true is in spec
  if (!mode) then
    !this.outSpecName.val       = 'Select From Spec'
    !this.outSpec = FALSE
    !this.adjacentSpec.visible = !this.outSpec
    !this.outSpecName.background = 0

  else
    !this.outSpecName.val       = 'Select Out of Spec'
    !this.outSpec = TRUE
    !this.adjacentSpec.visible = !this.outSpec
    !this.outSpecName.background = 3
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      initialiseCreation
--
-- Description: Initialise the relevant variables, gadgets, etc. for creation
--
------------------------------------------------------------------------
define method .initialiseCreation()
  -- TM need to do something here for assemblies
  -- stop backwards mode
  --etc
  --forwards
  -- If there is no new component, don't do anything
  if(!this.newComponent.unset()) then
    return
  endif

  if (!!ce.owner.type.neq('BRAN').and(!!ce.owner.type.neq('PIPE'))) then
    !this.setActive(FALSE)
  else
    !this.setActive(TRUE )
  endif

  -- Don't clear if we are in active modify mode
  if(!this.modifyActive) then
    return
  endif

  -- Setup reselection of adjacent components
  !this.adjacentClear()

  -- Stop Flip being used
  --!this.flip.visible    = FALSE
  !this.flip.active = FALSE

  -- Clear component list out
  !this.newComponents.clear()

  -- Initialise position
  !this.pickedPosition  = object POSITION()

  -- Initialise new component
  !this.newComponent    = object DBREF()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      loadComponents
--
-- Description: Load component choice
--
--
------------------------------------------------------------------------
define method .loadComponents(!mode is STRING)

  if (!mode.eq('create')) then


    -- Initialise Variables
    !componentType              = !this.componentList.selection('rText')
    handle ANY
      return
    endhandle
    -- Display current component type
    !this.componentType.val     = !this.componentList.selection('dText')
    -- Set Current Component
    !this.currentComponentIndex = !this.componentList.val
    -- tm added to deal with assemblies
    if (!componentType.eq('ASSY')) then
      !this.createAdjacent.visible      = FALSE
      !this.adjacentSpec  .visible      = FALSE
      !this.skipConn      .visible      = FALSE
      !this.componentData.assemblies.getarealist(!this.assemblyTypes)
      !this.componentData.assemblies.getareamembers(!this.assemblyTypes.selection().dbRef(), !this.assemblyChoices)
      !this.assemblyVisibility(TRUE)
      !this.selectChoice()
      return
    endif
  endif

  -- Define Component Table

  if (!mode.eq('edit')) then
    !componentType = !this.editComponentList.selection()
    !this.editComponentData.pipingSpecs.loadTable(!componentType)
    handle ANY
    endhandle
  else
    -- This was wrong it should be componentData and now is
    !this.componentData.pipingSpecs.loadTable(!componentType)
    handle ANY
    endhandle
    !componentList = !this.componentData.pipingSpecs.activeSpec().types
    !this.setIconTypeVisibility(!componentList)
  endif

  -- Get bore indices
  if (!mode.eq('edit')) then
    !boreIndices  = !this.editComponentData.boreIndices(!componentType)
  else
    !boreIndices  = !this.componentData.boreIndices(!componentType)
  endif
  -- Get Available sTypes for Component - if there is an object definition
  -- for the component type, then check on the Arrive/Leave configuration
  -- Get all components with Arrive Bore

  if (!mode.eq('edit')) then
    !sTypes  = !this.editComponentData.pipingSpecs.subTypes(!componentType, !boreIndices[1], !this.arriveBore)
    handle ANY
      !sTypes = ARRAY()
    endhandle
  else
    !sTypes       = !this.componentData.pipingSpecs.subTypes(!componentType, !boreIndices[1], !this.arriveBore)
    handle ANY
      !sTypes = ARRAY()
    endhandle
  endif
  -- Handle No sType
  if(!sTypes.unset()) then
    !this.editSTypes.visible = FALSE
    !this.sTypes.visible = FALSE
  else
    -- Define sType display and replacement
    !display          = ARRAY()
    !replace          = ARRAY()
    if(!sTypes.size() gt 1) then
      !display[1]       = 'unset'
      !replace[1]       = ''
    endif
    
    
    --!display.appendArray(!sTypes)
    --!replace.appendArray(!sTypes)
    
    -- TECHNIP CUSTOM Code
    --Filter the Stypes for Valves as per the Fluid Reference
    if (!componentType inset ('VALV','GASK','FLAN')) then
    --if (!componentType.eq('VALV')) then
      !validsTypes        = !this.loadValveXmlData(!componentType) 
      !display.appendArray(!validsTypes)
      !replace.appendArray(!validsTypes)
    else
      !display.appendArray(!sTypes)
      !replace.appendArray(!sTypes)
     endif
     
     
    -- Set gadget
    if (!mode.eq('edit')) then
      !this.editSTypes.dText  = !display
      !this.editSTypes.rText  = !replace
      !this.editSTypes.active = !sTypes.size().gt(1)
    else
      !this.sTypes.dText  = !display
      !this.sTypes.rText  = !replace
      !this.sTypes.active = !sTypes.size().gt(1)
    endif
  endif

  -- Select sType
  if (!mode.eq('edit')) then
    !this.filterComponents('edit')
  else
    !this.filterComponents('create')
  endif

  --Lstu Tube available selections
  !this.displayTubes(!this.component,!mode)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      filterSubType
--
-- Description: Filter the list of components calls filterComponents which does the work
-- Type is only used to differentiate assemblies
--
--
------------------------------------------------------------------------
define method .filterSubType(!type is STRING,!mode is STRING)

  -- filter assemblies
  if (!type.eq('ASSY')) then
    !this.sTypeFilter = !this.assemblyTypes.active and !this.assemblyTypes.selection('rText').empty().not()
  endif

  if (!mode.eq(|create|)) then
    -- Initialise Variables
    !this.sTypeFilter = !this.sTypes.active and !this.sTypes.selection('rText').empty().not()
    -- Filter component list
    !this.filterComponents('create')
  else
    !this.filterComponents('edit')
    -- Initialise Variables
    !this.sTypeFilter = !this.editSTypes.active and !this.editSTypes.selection('rText').empty().not()
    -- Filter component list
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      filterComponents
--
-- Description: Filter components using current filter settings
--
------------------------------------------------------------------------
define method .filterComponents(!mode is STRING )
    
	-- $p on est la
	-- Q VAR !this.componentList.RTEXT
	-- debut code JFH-AS
	if !this.componentList.selection('rText') eq 'BRANCONN' then
		--$p brancon
		-- renseigne la liste
		-- Ajout JFH-AS
		-- $p vider la liste
		
		-- il faut récupérer le diamètre de sortie choisi par l'utlisateur dans la liste contruite précédemment
		!diamsortie = !!componenteditor.teeBore.selection().before('in')
		-- il faut reparcourir le fichier xml, soit avoir mis le noeud mainbore dans une variable global
		!stype = !!diamheadernode[1].selectnodes(|DiamBranch[@value='| + !diamsortie + |']|)
		
		!questions      = ARRAY()
		!answers        = ARRAY()

		!questions.append('STYP')
		!questions.append('PBOR0')
		!questions.append('PBOR3')
		
		if !this.teeBore.val.eq(1) then
				!this.choices.clear()
				return
		else
			!answers.append(!stype[1].value('@stype'))
			!answers.append(object bore(!!diamheadernode[1].value('@value')))
			!answers.append(object bore(!diamsortie))
					
			-- essayer les OLET...
			
			!components  =  !this.editComponentData.pipingSpecs.getAvailableComponents('OLET', !questions, !answers)
			
			if !components.size() eq 0 then
				-- essayer les TEE
				!components  =  !this.editComponentData.pipingSpecs.getAvailableComponents('TEE', !questions, !answers)
			endif		
			
			!this.choices.clear()
			!texts = object array()
			!texts[1] = object array()
			!texts[1].append('Bore')
			!texts[1].append('sType')
			!texts[1].append('Description (Full Description)')
			!texts[2] = object array()
			!texts[3] = object array()
			!texts[2][1] = object array()
			!texts[2][2] = object array()
			!texts[2][3] = object array()
			
			--if !components
			do !component values !components
				!texts[2][1].append(!diamsortie)
				!texts[2][2].append(!component.stype)
				!texts[2][3].append(!component.detref.rtext)
				!texts[3].append(!component.refno.string())
			enddo
			
			!this.choices.setHeadings(!texts[1])
			!this.choices.setColumns(!texts[2])
			!this.choices.rText = !texts[3]
			return
		endif
	endif
	-- fin code JFH-AS

  if (!mode.eq('create')) then
    -- Initialise Variables
    !componentType        = !this.componentList.selection('rText')
    handle ANY
      --- if the componentList is not yet set up this selects the first item
      !this.componentList.val = 1
      handle any
        return
      endhandle
      !componentType        = !this.componentList.selection('rText')
    endhandle
  else
    !componentType = !this.editComponentList.selection()
  endif

  --!this.checkComponents(!mode)

  -- No component type selected
  if(!componentType.empty()) then
    return
  endif
  
   if (!mode.eq('create')) then
    -- TM if we are dealing with an assembly we need to filter the subtypes
    if (!componentType.eq('ASSY')) then $* we are listing assemblies
      !this.componentData.assemblies.getareamembers(!this.assemblyTypes.selection().dbRef(), !this.assemblyChoices)
      !this.choices.visible = FALSE
      !this.selectChoice()
      return
    endif
  endif

  -- Get sType
  if(!this.sTypeFilter) then
    if (!mode.eq('edit')) then
      -- Set specifications current sType
      !sType              = !this.editSTypes.selection('rText')
      !componentType = !this.component.type
      -- this sets the lastStype member of the selected spec in preparation for filtering
      !this.editComponentData.pipingSpecs.activeSpec().lastsType(!componentType, !sType)
    else
      !sType              = !this.sTypes.selection('rText')
      !this.componentData.pipingSpecs.activeSpec().lastsType(!componentType, !sType)
    endif
    -- No sType filtering
  else
    !sType              = ''
    if (!mode.eq('edit')) then
      !this.editComponentData.pipingSpecs.activeSpec().lastsType(!componentType, !sType)
    else
      !this.componentData.pipingSpecs.activeSpec().lastsType(!componentType, !sType)
    endif
  endif

  -- Is there a bore to check against
  if (!mode.eq('edit')) then
    !boreIndices          = !this.editComponentData.boreIndices(!componentType)
  else
    !boreIndices          = !this.componentData.boreIndices(!componentType)
  endif
  !arrive               = !boreIndices[1]
  !leave                = !boreIndices[2]
  !check                = !boreIndices[3]
  if (!mode.eq('edit')) then
    !boreGadget           = !this.editComponentData.boreGadget(!componentType)
  else
    !boreGadget           = !this.componentData.boreGadget(!componentType)
  endif

  if(!boreGadget.set()) then

    -- Get Bore information
    !questions[1]       = 'PBOR' & !arrive
    !answers[1]         = !this.arriveBore
    -- Determine the check bore
    -- Transition component
    if(!leave eq !check) then
      !question         = 'PBOR' & !check
      -- Three connection component
    elseif (!arrive + !leave + !check eq 6) then
      if(!leave eq 3) then
        !question       = 'PBOR3'
      else
        !question       = 'PBOR' & !check
      endif
    else
      !question         = 'PBOR' & !check
    endif

    -- Add sType to filter
    if(!sType.empty().not()) then
      !questions[2]     = 'STYP'
      !answers[2]       = !sType
    endif

    -- Get the available bores
    if (!mode.eq('edit')) then
      !bores              =  !this.editComponentData.pipingSpecs.componentData(!componentType, !question, !questions, !answers)
    else
      !bores              =  !this.componentData.pipingSpecs.componentData(!componentType, !question, !questions, !answers)
    endif
    !boreGadget.active  = !bores.empty().not()


    -- Populate bore information
    if(!bores.empty().not()) then
      !bores.sort()
      do !i indices !bores
        !boreString[!i] = !bores[!i].string(!!boreFmt)
      enddo
      -- Define Bore display and replacement
      !display          = ARRAY()
      !replace          = ARRAY()
      if(!boreString.size() gt 1) then
        !display[1]     = 'unset'
        !replace[1]     = ''
      endif
      !display.appendArray(!boreString)
      !replace.appendArray(!boreString)
      -- Set gadget
      !boreGadget.dText = !display
      !boreGadget.rText = !replace
      -- Select current check bore
      if(!this.checkBore.set()) then
        !boreGadget.select('RTEXT', !this.checkBore.string(!!boreFmt))
        handle ANY
          !this.checkBore = object BORE()
        endhandle
      else
        !boreGadget.val = 1
        handle ANY
        endhandle
      endif
    endif
  endif

  -- Get Available Choices for Component
  !this.loadChoices(!mode)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      loadChoices
--
-- Description: Load the choices for the current selection
--
--
------------------------------------------------------------------------
define method .loadChoices(!mode is STRING)


  -- Initialise relevant information on changing focus
  !this.initialiseCreation()
  --!validComponents           = ARRAY()
  --!validComponents.clear()

  if (!mode.eq('create')) then
    -- Get available choices for the current arrive bore
    !this.availableComponents = !this.choices(!this.arriveBore,!mode)
    
    --TECHNIP CUSTOM CODES
    -- Filter Available choices as per the valid stypes available for the selected component
    !componentType              = !this.componentList.selection('rText')
    handle ANY
      return
    endhandle
    !this.filterValidComponents('create',!componentType)
    
    -- If there are no component to choose from, then don't allow any creation
    !createAllowed            = !this.availableComponents.empty().not()
    !this.create.active       = !createAllowed
    !this.createPick.active   = !createAllowed
    !this.createPick3D.active = !createAllowed

    !this.displayChoices('create')
    handle ANY
    endhandle
  else
    !this.editAvailableComponents = !this.choices(!this.arriveBore,!mode)
    
    --TECHNIP CUSTOM CODES
    -- Filter Available choices as per the valid stypes available for the selected component
    !componentType              = !this.editComponentList.selection()
    handle ANY
      return
    endhandle   
    !this.filterValidComponents('edit',!componentType)
    
    !this.displayChoices('edit')
    handle ANY
    endhandle
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      choices
--
-- Description: Get the choices for the current selection
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BORE        Bore to check against
-- Return:
--   [Data Type] [Description]
--    ARRAY       List of available components
--
------------------------------------------------------------------------
define method .choices(!arriveBore is BORE,!mode is STRING   ) is ARRAY

  -- Initialise Variables
  !questions      = ARRAY()
  !answers        = ARRAY()
  
  if (!mode.eq('edit')) then
    -- I know this is the same but I think this should be current element type
    -- and i will test it later
    --!componentType  = !this.editComponent.type
    !componentType  = !this.editComponentList.selection()
    if(!this.sTypeFilter) then
      !sType        = !this.editSTypes.selection()
    else
      !sType        = ''
    endif
  else
    !componentType  = !this.componentList.selection('rText')
    if(!this.sTypeFilter) then
      !sType        = !this.sTypes.selection()
    else
      !sType        = ''
    endif
  endif

  if (!this.multiBore.not()) then
    !this.checkBore = object BORE()

    -- reset bore gadget to 'unset' for couplings
    if (!componentType.eq('COUP')) then
      if (!mode.eq('edit')) then
        !this.editComponentData.boreGadget(!componentType).val = 1
      else
        !this.componentData.boreGadget(!componentType).val = 1
        handle ANY
          -- need to revisit this to see what's going on
          --q var !this.componentData.boreGadget
        endhandle
      endif
    endif
  endif
  
  !checkBore      = !this.checkBore

  -- Get Bore Indices
  if (!mode.eq('edit')) then
    !boreIndices    = !this.editComponentData.boreIndices(!componentType)
  else
    !boreIndices    = !this.componentData.boreIndices(!componentType)
  endif
  -- Primary Question is the Bore
  !questions.append('PBOR' & !boreIndices[1])
  !answers.append(!arriveBore)

  -- If sType is set
  if(!sType.empty().not()) then
    !questions.append('STYP')
    !answers.append(!sType)
  endif

  ---- If check bore is set (look at how we handle swapping tees check bores about)
  if (!checkBore.set()) then
    !questions.append('PBOR' & !boreIndices[3])
    !answers.append(!this.checkBore)
  endif
  
  -- q var !questions
  -- q var !answers

  -- Return Available Components
  if (!mode.eq('edit')) then
    !components  =  !this.editComponentData.pipingSpecs.getAvailableComponents(!componentType, !questions, !answers)
    handle any
      --handle array element not found
      !components = ARRAY()
    endhandle
  else
    !components  =  !this.componentData.pipingSpecs.getAvailableComponents(!componentType, !questions, !answers)
    handle any
      -- handle array element not found
      !components = ARRAY()
    endhandle
  endif

  handle any
    -- TM fix to handle array element not found
    !components = ARRAY()
  endhandle
  --CW
  !this.checkComponents(!mode)
  -- test for undefined catRefs
  !items = !components
  do !n index !components
    if (!items[!n].catRef.badRef()) then
      !components.remove(!n)
      skip
    endif
  enddo

  return !components

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectChoice
--
-- Description: Select the current choice and setup other gadgets
--
--
------------------------------------------------------------------------
define method .selectChoice()
   -- Initialise Variables
  -- hide modify
  !this.modifyActive  = FALSE
  !componentType      = !this.componentList.selection()
  !component          = !this.choices.selection().dbRef()

  -- this called when the user clicks on a possible selection in the available list of components
  -- it only sets up the possibilities in terms of gadgets etc.
  if (!componentType.eq('ASSY')) then
    !component     = !this.assemblyChoices.selection().dbRef()
    !this.assembly = !this.componentData.assemblies.findPipe(!component)
	-- code JFH-AS
	if !this.assembly.branchCount.unset() then
	   !this.assembly.branchCount = 0
	endif
	-- q var !this.assembly
    if (!this.assembly.branchCount.gt(1)) then
      !this.atoTail.val                 = TRUE
      !this.atoTail.active              = FALSE
      !this.atoHead.active              = FALSE
      !this.atoHead.val                 = FALSE
      -- assemblies with multiple branches cannot be placed in backwards mode
      -- force to forwards mode
      !this.setFlow(true,|std|)
    else
      !this.atoTail.active              = TRUE
      !this.atoHead.active              = TRUE
    endif
    !this.assembly.varid = 'componentEditor.assembly'
    !this.displayAssembly()
    return
  endif

  -- Initialise relevant information on changing focus
  !this.initialiseCreation()
  ------------------------------------------------------- need to sort out setActive
  -- Get Components Questions and Answers
  !questions  =  !this.componentData.pipingSpecs.questions(!componentType)
  handle ANY
    -------------------------------- temporary fix for not being at a pipe when loading
    return
  endhandle
  !answers    = !this.componentData.pipingSpecs.answers(!componentType, !component)

  !boreIndices  = !this.componentData.boreIndices(!componentType)

  -- Check to see if there is a bore
  !boreGadget   = !this.componentData.boreGadget(!componentType)
  if(!boreGadget.set()) then

    -- Get Bore Indices
    !boreIndices  = !this.componentData.boreIndices(!componentType)
    !boreIndex    = !questions.findFirst('PBOR' & !boreIndices[3])
    if(!boreIndex.set()) then
      !boreGadget.select('RTEXT', !answers[!boreIndex].string(!!boreFmt))
      handle ANY
      endhandle
    endif
  endif

  if (!componentType.eq('BEND')) then
    !index  = !this.componentData.objectIndex('BEND')
    -- sort out the radius options
    -- TM we now need to add some code to deal with auto selected radius bends using DFBRAD
    !radius = !this.testBendRadius(!component,!questions,!answers )
    if (!radius.unset()) then
      !this.componentData.selectRadius()
      return
    else
      if ((!this.bendRadiusOption.selection('DTEXT').eq('Machine') and !radius neq 0mm) or !this.bendRadiusOption.selection('DTEXT').eq('Specification')) then
        !this.bendRadius.val = !radius
      else
        !radius = !this.bendRadius.val.real()
      endif
      !this.componentData.componentObjects[!index].radius   = !radius
      !this.componentData.componentObjects[!index].radiusOD = object REAL()
    endif
  endif

  -- Check to see if there is a angle information
  !angleGadgets   = !this.angleGadgets(!componentType)
  if(!angleGadgets.set()) then
    !this.componentElbowFrame.visible = TRUE
    !seles[1] = !component
    !depth = !component.ddepth
    handle ANY
      !depth = 2
    endhandle
    !index  = !this.componentData.objectIndex(!componentType)
    !angleGadgets[1].val = 90
    !angleGadgets[2].val = 90
    !angleGadgets[3].val = 90
    !this.componentData.componentObjects[!index].angle      = 90
    !this.componentData.componentObjects[!index].minAngle   = 90
    !this.componentData.componentObjects[!index].maxAngle   = 90
    !angleGadgets[1].active = TRUE
    do !unusedA to !depth - 2
      -- !a is not used anywhere so this code needs to be investigated
      if (!seles[!seles.size()].owner.question.match('ANG').eq(1)) then
        !angleGadgets[1].val = !seles[!seles.size()].maxans
        !angleGadgets[2].val = !seles[!seles.size()].answer
        !angleGadgets[3].val = !seles[!seles.size()].maxans
        !this.componentData.componentObjects[!index].angle      = !seles[!seles.size()].maxans
        !this.componentData.componentObjects[!index].minAngle   = !seles[!seles.size()].answer
        !this.componentData.componentObjects[!index].maxAngle   = !seles[!seles.size()].maxans
        !angleGadgets[1].active = (!seles[!seles.size()].maxans  gt !seles[!seles.size()].answer)
        break
      endif
      !seles.append(!seles[!seles.size()].owner)
    enddo
  else
    !this.componentElbowFrame.visible = FALSE
  endif

  -- new code to toggle the autocreate field. checks to see if the current selection is flanged.
  -- get the ppoints and see which are flanged - ignore the standard components which are expected
  --to be Flanged
  if (!componentType inset ('VALV','FLAN','VTWA','VTWA','FILT','VFWA','INST','PCOM') ) then
    -- find out if its flanged on any ends
    -- do nothing
  else
    !visible = !this.isItFlanged(!component )
    !this.createAdjacent.active = !visible
  endif

  !this.displayTubes(!component,'create')

endmethod

-----------------------------------------------------------------------
-- new code to toggle the autocreate field. checks to see if the current
-- selection is flanged. get the ppoints and see which are flanged
-- ignore the standard components which are expected
-- to be Flanged
-----------------------------------------------------------------------
define method .isItFlanged(!component is DBREF) is BOOLEAN

  !list = !component.ppls
  handle any
    return FALSE
  endhandle
  do !answers values !list
    !connection = !component.ppconn[!answers]
    handle any
      skip
    elsehandle none
      if (!connection.subString(1,1) inset('F','W')) then
        return true
      endif
    endhandle
  enddo

  return FALSE

endmethod

------------------------------------------------------------------------
--
-- Method:     .reselectionChoice()
--
-- Description: Select the current choice and setup other gadgets
--
--
------------------------------------------------------------------------
define method .reselectionChoice()

  -- Initialise Variables
  !reference            = !!ce

  -- Handle null selection
  !selection             = !this.editChoices.selection()
  if(!selection.unset()) then
    return
  endif

  -- Convert to DBREF
  !specReference        = !selection.dbRef()
  handle ANY
    return
  endhandle
  if(!specReference.unset()) then

    return
  endif

  -- Check that the spec component has as catRef
  if(!specReference.catRef.unset()) then
    !!alert.warning('Unable to use component as it has no catalogue definition assigned to it.')
    return
  endif

  --CW fix P-39135 --  Check if the component is an elbow and if so what the angle is --

  if (!reference.type eq ('ELBO') or !reference.type eq ('BEND')) then
    !elbAngle = !reference.angle
  endif

  -- before we change check to see if we have a flange allowance
  !type = !this.editComponent.catRef.compType
  handle (2,754)
    !type = ''
  endhandle
  !oldType = !type.match('ALL')

  --Check if we have to change type
  !type                 = !this.activeComponent[1].type()
  if(!this.editComponent.type ne !type) then

    -- Mark the database
    !this.undoAdd('Component type changed to ' & !type)
    !reference          = !!ce
    !!ce                = !this.editComponent
    !currentType = !!ce.type
    CHANGETYPE TO $!<type>
    handle (41,303) (41,232)
      -- too many values specified for attribute cref
      !!alert.message('Changing types from $!currentType to $!type disconnects branch connections. - Please reconnect branches')
    elsehandle (2,707)
      -- loosing the clutch attribute on bends. No error message required
    endhandle
    !!ce = !reference

  else
    -- Mark the database
    !this.undoAdd('Component reselected')

  endif

  -- Set Spec Reference
  !oldSpecRef = !this.editComponent.spRef
  !this.editComponent.spRef = !specReference

  !type = !this.editComponent.catRef.compType
  if (!type.match('ALL').gt(0)) then
    !this.editComponent.allow = !this.editComponent.flallow
    !this.editComponent.loose = TRUE
  elseif (!this.editComponent.type.eq('BEND')) then
    !this.setBendRadius(!oldSpecRef)

  else
    if (!oldType.neq(0)) then
      -- the previous flange was an allowance flange so reset to standard
      !this.editComponent.allow = 0
      !this.editComponent.loose = FALSE
    endif
  endif

  -- Set attributes from spec
  !this.setSpecAttributes(!this.editComponent)
  handle ANY
  endhandle

  !reference          = !!ce
  !!ce                = !this.editComponent
  SELECT LSTU
  handle ANY
  endhandle

  -- set the flange offset if it is available


  -- Change the RLOCK attribute if it is 2 to -1, so we know it has been changed
  -- explicitly by the user
  if(!this.editComponent.rLock eq 2) then
    !this.editComponent.rLock = -1
  endif

  -- fix for 178440 Flange changes its direction towards head position when user change the type of the flange.
  -- if the arrive geometry is bad forget realignment
  !arriveTest = !this.activeComponent[1].baseClass.checkAlignment()
  handle (2,759)
    -- object does not have a member baseClass
    !arriveTest = -1
  endhandle
  if (!arriveTest.neq(-1)) then
    -- Reposition component based on its original information
    !this.activeComponent[1].realign()
    handle ANY
    endhandle
  endif

  -- Select Current Component
  !this.selectCurrentComponent()

  -- Select Options
  !this.selectOptions()

  --CW fix P-39135 -- if component is an elbow then set its angle to original value

  if (!reference.type eq ('ELBO') or !reference.type eq ('BEND')) then
    !reference.angle = !elbAngle
    -- Angle not in specification range
    handle (61,86) (61,87)
      !!alert.warning('Component (' + !reference.type + ') selected is out of range for current design angle of ' + !reference.angle.string() + '. Setting angle to maximum range angle.')
      !this.editAngle.val = !this.editMaxAngle.val
      !reference.angle = !this.editMaxAngle.val
    elsehandle none
      !this.editAngle.val = !elbAngle
    endhandle
  endif
  -- Determine if we need to perform a reconnect - checks to see if the current brcon is the same as the previous one
  -- if brcon is different it returns true because something has changed.
  !reconnect  = !this.connected.isReconnectRequired()
  handle ANY
    !reconnect = true
  endhandle

  if(!this.autoConnection and !reconnect) then
    !this.reconnect(false)
    !this.undo.endUndoable()
  else
    !this.undo.endUndoable()
    !this.reconnect.active    = !reconnect
    !this.reconnectAvailable  = !this.reconnect.active
  endif

  -- Make sure we reselect the lstu after we have reconnected to get the correct pl bore
  -- ?????? this needs modifying for alternate lstu ??????

  sel lstu
  handle any
  endhandle

  -- Return to original element
  !!ce = !reference

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      angleGadgets
--
-- Description: Returns the gadgets used for setting the angle of the passed
--              type, an unset return means there is no gadget
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      STRING      Component type
-- Return:
--   [Data Type] [Description]
--    ARRAY       2 element array of gadget. [1] Option gadget, [2] input
------------------------------------------------------------------------
define method .angleGadgets(!componentType is STRING) is ARRAY

  -- Initialise Variables
  !result       = ARRAY()
  !index        = !this.componentData.frameIndex(!componentType)

  if(!index gt 0) then
    if(defined(!this.componentData.angleRegister[!index])) then
      !result[1]  = !this.componentData.angleRegister[!index][1]
      !result[2]  = !this.componentData.angleRegister[!index][2]
      !result[3]  = !this.componentData.angleRegister[!index][3]
    endif
  endif

  -- Return gadgets
  return !result

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectBore
--
-- Description: Select a check bore for the component type
--
------------------------------------------------------------------------
define method .selectBore(!gadget is GADGET, !dummySelect is STRING)
	-- code JFH-AS
  -- if !gadget.tag.eq(|Conn. Bore|) then
  -- Initialise Variables
  !this.checkBore   = object BORE(!gadget.selection())

  --  handle ANY
  --  endhandle
  -- Filter components
  !this.filterComponents('create')
  --!this.checkComponents('create')
endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectRadius
--
-- Description: Select radius option
--
--
------------------------------------------------------------------------
define method .selectRadius(!mode is REAL )
  !this.componentData.selectRadius(!this.componentList.selection())
endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      changeAngle
--
-- Description: Change angle value
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .changeAngle()

  !type = !this.componentList.selection()

  !gadgets = !this.angleGadgets(!type)

  if(!gadgets.set()) then
    !value = !gadgets[1].val
    !minValue = !gadgets[2].val
    !maxValue = !gadgets[3].val

    if (!value lt !minValue or !value gt !maxValue)then
      !!alert.error('Angle ' + string(!value, !!angleFmt) + ' is outside the specified range (expected range ' + string(!minValue, !!angleFmt) + ' to ' +  string(!maxValue, !!angleFmt))
      !gadgets[1].val = !maxValue
    endif
  endif

  !index  = !this.componentData.frameIndex(!type)

  !this.componentData.componentObjects[!index].angle = !gadgets[1].val

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      arriveLeave
--
-- Description: Switch Tee Arrive/Leave causes gadgets to reformat
-- giving appropriate bore selections somehow!
--
--
------------------------------------------------------------------------
define method .arriveLeave(!arrive is REAL, !leave is REAL,!mode is STRING )

  -- mode can be "create" or reselect
  -- Object Index
  if (!mode.eq('create')) then
    !index  = !this.componentData.frameIndex(!this.componentList.selection())
  else
    !index  = !this.editComponentData.frameIndex(!this.activeComponent[1].type())
  endif

  if(!index le 0) then
    return
  endif

  if (!mode.eq('create')) then
    -- Update component Object with Current Arrive and Leave Data
    !this.componentData.componentObjects[!index].arriveLeave(!arrive, !leave)
    -- Setup Arrive Gadgets
    !this.componentData.arriveLeaveSetup(!this.componentList.selection())
    -- Select Component
    !this.loadComponents(!mode)
  else
    -- the next two lines setup the arrive and leave of the current active component
    !this.activeComponent[1].arriveLeave(!arrive, !leave)
    !this.arriveLeaveSetup(!this.activeComponent[1])
    -- in theory we don't need to do the next two lines but it won't work without them
    -- Update component Object with Current Arrive and Leave Data
    !this.editComponentData.componentObjects[!index].arriveLeave(!arrive, !leave)
    -- Setup Arrive Gadgets
    !this.editComponentData.arriveLeaveSetup(!this.editComponentList.selection())
    -- Select Component
    !this.loadComponents(!mode)
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      arriveLeaveSetup
--
-- Description: The Arrive/Leave information for the current component
--              and the appropriate gadgets
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      ANY        Component Object Definition
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .arriveLeaveSetup(!componentObject is ANY)

  -- Initialise Variables
  !componentType  = !componentObject.type()
  !index  = !this.editComponentData.frameIndex(!this.activeComponent[1].type())
  if(!index.unset()) then
    return
  endif

  -- Get Object Arrive and Leave is extracted from
  !arriveLeave    = !componentObject.arriveLeave()
  handle ANY
    return
  endhandle
  !arrive         = !arriveLeave[1]
  !leave          = !arriveLeave[2]

  -- Get gadget information
  !gadgetData     = !this.editComponentData.arriveLeaveGadgets(!componentType)
  do !i indices !gadgetData
    !active       = (!gadgetData[!i][1] eq !arrive and !gadgetData[!i][2] eq !leave)
    !gadgetData[!i][3].val = !active
  enddo

endmethod

------------------------------------------------------------------------
--
-- Method:      displayChoices
--
-- Description: Display the currently available components
--
--
------------------------------------------------------------------------
define method .displayChoices(!mode is STRING )
  -- Initialise Variables

  -- Get list of choices
  if (!mode.eq('edit')) then
    
    --TECHNIP CUSTOM CODE
    -- Filter available components
    !componentType              = !this.editComponentList.selection()
    handle ANY
      return
    endhandle
    !this.filterValidComponents('edit',!componentType)
    
    !texts  =!this.editComponentData.componentColumns(!this.editAvailableComponents,'edit')
    -- Populate list gadgets
    if(!texts.set()) then
      !this.editChoices.clear()
      !this.editChoices.setHeadings(!texts[1])
      !this.editChoices.setColumns(!texts[2])
      !this.editChoices.rText = !texts[3]
    else
      !this.editChoices.clear()
    endif
    --CW set heading on gadget
    if (!this.editComponentType.eq('COUP')) then
      !this.editReduFrame.tag = 'Reducing Coupling Information'
    elseif (!this.editComponentType.eq('FLAN')) then
      !this.editReduFrame.tag = 'Reducing Flange Information'
    else
      !this.editReduFrame.tag = 'Reducer Information'
    endif


  else
    
    --TECHNIP CUSTOM CODE
    -- Filter available components
    !componentType              = !this.componentList.selection('rText')
    handle ANY
      return
    endhandle
    !this.filterValidComponents('create',!componentType)
    
    !texts  =!this.componentData.componentColumns(!this.availableComponents,'create')
    -- Populate list gadgets
    if(!texts.set()) then
      !this.choices.clear()
      !this.choices.setHeadings(!texts[1])
      !this.choices.setColumns(!texts[2])
      !this.choices.rText = !texts[3]
    else
      !this.choices.clear()
    endif


    --CW set heading on gadget
    if (!this.componentType.eq('COUP')) then
      !this.reduFrame.tag = 'Reducing Coupling Information'
    elseif (!this.componentType.eq('FLAN')) then
      !this.reduFrame.tag = 'Reducing Flange Information'
    else
      !this.reduFrame.tag = 'Reducer Information'
    endif
  endif
  
endmethod

-- End of method definition

-- Début code JFH-AS
-- ===================================================================== --
-- ===================================================================== --
------------------------------------------------------------------------
--
-- Method:      getStype
--
-- Description: Cette méthode retrouve le stype théorique à partir du fichier XML pour les tableaux de piguage
--
-- Method Type: Function/Procedure
-- Arguments:
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .getStype(!spec is string, !headerbore is string , !branchbore is string) is STRING
	-- récupère le noeud pipename dans le XML branch table
	!specnode = !this.branchtablexmldoc.selectnodes(|//BranchTable[@value='| + !spec + |']|)
	if not !specnode.size() gt 0 then
		return ('Not found#Spec ' + !spec + ' not found in branch table file')
	endif

	-- récupère le noeud diametre collecteur
	!diamheadernode = !specnode[1].selectnodes(|DiamHeader[@value='| + !headerbore + |']|)
	if not !diamheadernode.size() gt 0 then
		return ('Not found#Header diameter ' + !headerbore + ' not found in branch table file for spec ' + !spec)
	endif

	-- récupère le noeud diamètre sortie
	!diamoutnode = !diamheadernode[1].selectnodes(|DiamBranch[@value='| + !branchbore + |']|)
	if not !diamoutnode.size() gt 0 then
		return ('Not found#Branch diameter ' + !branchbore + ' not found in branch table file for header diameter ' + !headerbore + ' for spec ' + !spec)
	endif

	-- renvoie le STYPE
	return !diamoutnode[1].value('@stype')
endmethod
-- End of method
-- ===================================================================== --
-- ===================================================================== --
-- Fin code JFH-AS

------------------------------------------------------------------------
--
-- Method:      create
--
-- Description: Create component
--
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if component(s) created successfully
--
------------------------------------------------------------------------
-- called by the main create button to create a new component and connect it
define method .create(!createInLine is BOOLEAN) is BOOLEAN

  -- Initialise Variables
  !created            = FALSE
  !componentType      = !this.componentList.selection()
  if (!componentType.eq('')) then
    !!alert.error( 'no selection in component list')
    return
  endif
  !specReference      = !this.choices.selection().dbRef()
  !component          = !this.component
  if (!component.unset()) then
    !!alert.error(' current component is unset')
    return
  endif
  !positioning        = !this.pickedPosition.set()

  -- code JFH-AS
  if !componentType eq 'BRANCONN' then
    -- get comp type from SPCO
	!componentType = !specReference.catref.gtype
	-- !componentType = 'OLET'
	!forced = !this.branConn.val
	-- q var !forced
  else
    !forced = FALSE
  endif

  -- Modification inactive
  !this.modifyActive  = FALSE

  -- Initialise relevant information on changing focus
  !this.initialiseCreation()

  -- Modification active
  !this.modifyActive  = true

  -- Current navigation mode
  var !mode MODE

  -- Define UNDO Information
  !this.undoAdd('Created component (' & !componentType & ')')

  -- component type could be 'ASSY'
  if (!componentType.eq('ASSY')) then
    --if !this.choices.selection().dbRef().type.eq('APPLDA') then
    -- We are dealing with an assembly
    !this.assembly.varid = 'componentEditor.assembly'
    !this.assembly.buildNewAssembly('connected', !this.atoTail.val)
    !this.newComponents = !this.assembly.builtitems
    return
  endif

  -- Get component object
  !componentObject  = !this.componentData.componentObject(!componentType)

  -- it could be that the component has attas after it and we need to check that we have the right insert position
  -- Navigate to adjacent component
  !!ce  = !component
  handle ANY
    !component = !!ce
    -- !this.component no longer exists
  endhandle

  -- Set Flow Creation
  !this.flow(!this.flow)

  -- If the component is a branch, then create the component as first in the list
  !createPosition    = ''
  if(!component.type eq 'BRAN') then
    if(!component.mCount ne 0) then
      !createPosition    = 'BEFORE 1'
    endif
  endif
  -- Create createPosition can be before 1 in the case of branch head
  -- this is the point at which it creates the main component
  
  NEW $!<componentType> $!<createPosition>
  handle ANY
    !!alert.warning(|$!!error.text|)
    return !created
  endhandle
  
  -- Set new component info
  !this.newComponent  = !!ce
  !newComponent       = !!ce
  !newComponent.spRef = !specReference
  -- Set attributes from spec
  !this.setSpecAttributes(!newComponent)

  
		-- code JFH-AS
  if !!ce.type inset(|TEE|,|OLET|) and !this.branConn.val.not() then

	-- Recherche si le nouveau n'est pas en accord avec le fichier XML
	-- Stocke le styp du CE
	!CurStype = !!ce.styp
	
	-- gestion des unités
	var !UNITS UNITS
	if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
		var !unittext |mm|
	else
		var !unittext |in|
	endif

	!inchformat = object format()
	!inchformat.units = 'INCH'

    -- Récuperation des diametres Entrée et Piquage
	!headerbore = !!ce.ppbore[1].string().before(!unittext)
	!branchbore = !!ce.ppbore[3].string().before(!unittext)

	-- on gère les unités : MARIAN ne travaille qu'en INCH
	if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
		-- le projet est en mm
		!tpcurbore = object bore()
		!tpcurbore.bore(!headerbore.real())
		!headerbore = !tpcurbore.string(!inchformat)
		!headerbore = !headerbore.replace('.50','.5').replace('.00','').replace('0.','.')
		!tpcurbore.bore(!branchbore.real())
		!branchbore = !tpcurbore.string(!inchformat)
		!branchbore = !branchbore.replace('.50','.5').replace('.00','').replace('0.','.')
	else
		-- le projet est en inches
		!headerbore = !headerbore.replace('.50','.5').replace('.00','').replace('0.','.')
		!branchbore = !branchbore.replace('.50','.5').replace('.00','').replace('0.','.')
	endif
	
	-- on retrouve le STYPE target
	!spec = !!ce.spown.namn
	!TarStype = !this.getStype(!spec,!headerbore,!branchbore)

	-- si les 2 STYP ne sont pas identiques
	if !CurStype.neq(!TarStype) then
		!mess = !!alert.input(|"Use Branch Conn" option not used, please justify your choice|,|???|)
		
		!!ce.:TP-BRFORCE = TRUE
		!!ce.:TP-BRJUST  = !mess
		
		var !user user
		!!ce.:TP-BRUSER  = !user
		
		!Today = object datetime()
		!Date = !Today.date() & | | & !Today.monthstring().substring(1,3) & |. | & !Today.year()
		!!ce.:TP-BRDATE  = !Date
		!Hour = !Today.hour() & |h.| & !Today.minute()
		!!ce.:TP-BRTIME  = !Hour
	else
		$p The STYP is in accordance with SP.
	endif
  endif
  

  -- set the flange allowance
  if (!newComponent.type.eq('FLAN')) then
    !this.setFlangeAllowance(!newComponent)
  endif

  -- Modify the arrive leave, if required
  !arriveLeave        = !componentObject.arriveLeave()

  -- Handle component objects which don't have the "arriveLeave" method.
  handle ANY
  elsehandle NONE
    !newComponent.arrive  = !arriveLeave[1]
    !newComponent.leave   = !arriveLeave[2]
  endhandle

  -- Transpose Arrive/Leave if flow is backwards
  if(!this.flow.not()) then
        -- only change the arrive and leave if the component has different bores.
    if !newComponent.aBore.neq(!newComponent.lBore) then
       !arrive               = !newComponent.arrive
       !newComponent.arrive  = !newComponent.leave
       !newComponent.leave   = !arrive
    endif
  endif

  -- Get choice of spco
  var !choice CHOICE WITH $!<specReference>

  -- Remove type from list
  !selectString = !choice

  -- Change PBOR <val><val> to PBOR <val> <val>
  !selectString = !selectString.replace('PBOR 0','PBOR 0 ')
  !selectString = !selectString.replace('PBOR 1','PBOR 1 ')
  !selectString = !selectString.replace('PBOR 2','PBOR 2 ')
  !selectString = !selectString.replace('PBOR 3','PBOR 3 ')

  -- Force selection to set correct arrive/leave info
  if(!this.autoCreate and !this.adjacentSpec.val) then
  else
    SELECT with $!<selectString>
    handle ANY
    endhandle
  endif

  -- Set attributes from spec
  !this.setSpecAttributes(!newComponent)

  --CW set leave tube to displayed gadget value - Fix P-32959
  -- Select the leave tube

  -- Select the leave tube
  if !this.lstu.visible then
   !!ce.lstu = !this.lstu.selection().dbRef()
   handle ANY
     select lstube
      handle ANY
        !warning = 'There is no tube available at size ' + !!ce.lBore.string() + ' in the SPEC'
        !!alert.warning(!warning)
      endhandle 
   endhandle
  else
    select lstube
    handle ANY
      !warning = 'There is no tube available at size ' + !!ce.lBore.string() + ' in the SPEC'
      !!alert.warning(!warning)
    endhandle
  endif

  -- Carry out any specific for component
  !componentObject.define(!newComponent)

  -- Handles component objects which don't have the "define" method.
  handle ANY
  endhandle

  -- Determine if there are any possible connected elements
  !adjacentComponents = !componentObject.adjacentComponents()
  -- Handles component objects which don't have the "adjacentComponents" method.
  handle ANY
    !adjacentComponents = ARRAY()
  endhandle

  -- New Component
  !this.newComponents.append(!newComponent)

  -- Orient
  ORIENTATE

  -- If component did not have a SPREF and is a hard type of BEND or ELBOW
  -- and its parallel, then we'll use it as a positioning
  !deleteComponent          = FALSE
  if(!this.component.spRef.unset() and !this.component.hardType inset('BEND','ELBO')) then
    !aDir                   = !this.component.aDirection
    !lDir                   = !this.component.lDirection
    if(!aDir.angle(!lDir) ge 179.99) then
      !this.pickedPosition  = !this.component.position
      !positioning          = !this.pickedPosition.set()
      !deleteComponent      = true
    endif
  endif



  -- If there is a picked position, then we'll position the component at
  -- the position and orient in line with the pipe
  if(!positioning) then
    AT $!<this.pickedPosition>
    !this.pickedPosition  = object POSITION()
  endif

  -- Create and connect adjacent components
    !newComponents = object ARRAY()
  if(!this.autoCreate and !adjacentComponents.set()) then

    -- Create using branch spec
    if(!this.autoCreateSpec) then
      !specification  = !newComponent.spow
    else
      !specification  = !this.branchSpecification
    endif

    -- Positioned Component
    if(!positioning) then
      if (!newComponent.type.eq(|ATTA|)) then
          !newComponents = object ARRAY()
      else
          !newComponents  = !this.createAdjacent(!newComponent, !adjacentComponents, !specification)
          if (!newComponents.size().eq(0)) then
            if (!this.adjacentSpec.val and !!ce.type inset ('VALV','VTWA','VFWA','PCOM','FILT')) then
              !!alert.error('Cannot find Flanges from Specification ' & !this.specList.selection('DTEXT')  )
            endif
          endif
      endif
    else
      !newComponents  = !this.connectAdjacent(!newComponent, !adjacentComponents, !specification)
    endif

    -- New Components
    if(!newComponents.empty().not()) then
      !this.newComponents.appendArray(!newComponents)
    endif

    -- Just connect element to previous component
  else
    if(!positioning.not()) then
      !connected      = !this.connect(!newComponent)
    endif
  endif

    -- Order the components
  !components         = !!componentOrder(!this.newComponents)

  -- New components are always held in DB order
  !this.newComponents = !components

    !!ce = !newComponent
  -- set up a selection object to hold the group for model editor
  if !createInLine.not() then
    !selection= object SELECTION()
    do !a values !this.newComponents
      !selection.add(!a)
    enddo
    !selection.setCurrent()
    return
  endif

  -- At this point we should have created the component and any relevant
  -- adjacent ones. So we'll test to see if the components fit in the
  -- relevant space, etc.

  --Set the lstu for the new Components
  if (!this.noLstuSpecs.gt(1)) then
    do !comp values !this.newComponents
      --CW modify to use tube gadget to set lstube for new component -- Fix P-32959
      --Run displayTubes method to update lstu gadget for new component
      !this.displayTubes(!comp,'create')
      !comp.lstu = !this.lstu.selection().dbRef()
      -- set the flange allowance
      if (!comp.type.eq('FLAN')) then
        !this.setFlangeAllowance(!comp)
      endif
      -- prompt the user to look at the lstu because the bores have changed
      if (!comp.aBore.neq(!comp.lBore)) then
        refresh
        !!alert.message('This specification has multiple wall thicknesses. Please ensure you have selected the correct tube for the change of bore')
      endif
    enddo
  else
    !save = !!ce
    do !comp values !this.newComponents
      !!ce= !comp
      sel lstu
      handle ANY
      endhandle
      -- set the flange allowance
      if (!comp.type.eq('FLAN')) then
        !this.setFlangeAllowance(!comp)
      endif
    enddo
    !!ce = !save
  endif

  -- Start/End component in new components
  !first              = !components.first()
  !last               = !components.last()

  -- Previous elements position
  !adjacent           = !this.adjacent(!first, true)
  !startPosition      = !this.componentPosition(!adjacent[1], true)

  -- Previous elements direction
  !startDirection     = !this.componentDirection(!adjacent[1], true)

  -- Next elements position
  if(!first ne !last) then
    !adjacent         = !this.adjacent(!last, true)
  endif
  !endPosition        = !this.componentPosition(!adjacent[2], FALSE)

  -- Next elements direction
  !endDirection       = !this.componentDirection(!adjacent[2], FALSE)

  -- Start of component group
  !sPosition          = !first.aPosition
  !sDirection         = !first.aDirection
  !ePosition          = !last.lPosition
  !eDirection         = !last.lDirection

  -- Is start or end of group connected
  !slength            = !first.atlength
  handle any
    -- bad spref at first component
    return false
  endhandle
  !elength            = !last.ltlength
  handle any
    -- bad spref at last component
    return false
  endhandle
  !sConnected         = !slength lt 0.01mm
  !eConnected         = !elength lt 0.01mm
  !connected          = !sConnected.or(!eConnected)

  -- Check if components are minimum tube length from adjacent items
  -- if they are, then we most probably can't connect, as the items have
  -- been move by the minimum distance.
  !sMinimumTube       = !this.componentData.minTubeLength(!first, true)
  !eMinimumTube       = !this.componentData.minTubeLength(!last, FALSE)

  if(!slength eq !sMinimumTube) then
    !noSconnection    = true
  else
    !noSconnection    = FALSE
  endif

  if(!elength eq !eMinimumTube) then
    !noEconnection    = true
  else
    !noEconnection    = FALSE
  endif

  -- Zero length component group
  !zeroLength         = !sPosition.near(!ePosition, 0.01mm)

  -- Pipe segment length
  !pipeLine           = !startPosition.line(!endPosition)

  -- Component group length
  !compLine           = !sPosition.line(!ePosition)

  -- Minimum segment length (including minimum tube lengths)
  !compLength         = !compLine.length()
  !pipeLength         = !pipeLine.length()

  -- Is component group and line segment parallel (this is where AGS pseudo attributes are needed)
  !parallel           = !pipeLength gt 0 and (!startDirection.isParallel(!endDirection) and !sDirection.isParallel(!eDirection) and !sDirection.isParallel(!pipeLine.direction()))

  -- If component group and line segment are parallel and the components line
  -- is greater than the pipe segment, then we won't allow the component
  -- to be created in the line.
  -- We'll ignore zero length components
  -- parallel check
  -- NOTE: With the addition of the ability to insert outside of the next component this test now causes problems of randomly deleting the inserted component
  -- REMOVED at SP4.30
  --if !createInLine then
  --   --only do if not a model pick
  --
  --   if(!parallel and !pipeLength lt !compLength and !zeroLength.not()) then
  --
  --     !this.warning('Unable to create component(s) in this segment of pipe (' & !pipeLength.string(!!distanceFmt) & '). Absolute minimum gap required, excluding min tube lengths, is (' & !compLength.string(!!distanceFmt) & ').', true)
  --
  --     -- Should be able to use the undo
  --     UNDODB
  --     $!<mode>
  --     !!ce              = !component
  --     !this.track(!component)
  -- -    return FALSE
   --  endif
  --endif

  -- what does this do
  if !createInLine.not() then
     return
  endif

  --go and set the insulation and tracing for all new components
  do !listItem values !this.newComponents
    !this.setInsulationAndTracing(!listItem)
  enddo

  -- Set defaults for auto-connection
  !autoConnect        = FALSE
  !flow               = true

  -- Now we have geometry, we need to check if the component group overlaps
  -- either end of the pipe segment.
    -- Variable not outside introduced to check if the element lies out of the selected pipe
  !notOutSide = true

  if(!connected.not()) then

    -- If component group and pipe segment are parallel, check if the
    -- component group is outside of the pipe segment
    if(!parallel) then

      -- Derive the length of the pipe line (as pipe line and comp line may
      -- not be actually parallel, we need to map on onto the other)
      !compLineMapped = !pipeLine.near(!compLine.startPosition).line(!pipeLine.near(!compLine.endPosition))
      if !compLineMapped.length().lt(0.01) then
        !zeroLength = true
      endif

      -- Component out of bounds
      if(!pipeLine.union(!compLineMapped).length() gt !pipeLength and !zeroLength.not()) then
                if !!alert.confirm('The selected position is outside the current tube Limits - Is it ok to extend the tube?').eq('NO') then
         -- delete the outcome
         UNDODB
         $!<mode>
         !!ce              = !component
         !this.track(!component)
         return false
        else
          !autoConnect  = false
          !notOutSide = false
        endif
        -- Connect Start or End of group to start or end of pipe segment
        if(!pipeLength lt !startPosition.distance(!ePosition)) then
          !flow       = FALSE
        endif
      endif

      -- Non-parallel component group and pipe segment, check each end
    elseif (!deleteComponent.not()) then
      -- Based on position of the start/end, we need to determine if
      -- we need to connect the start or end of the group.
      !startVector    = object POINTVECTOR(!startPosition, !startDirection)
      !endVector      = object POINTVECTOR(!endPosition, !endDirection)

      -- Determine of start/end of the group is behind the respected end
      -- of the pipe section
      !sBehind        = !startVector.position.direction(!startVector.line(100mm).near(!sPosition)).angle(!startVector.direction).gt(0.01)
      handle any
        !sBehind = FALSE
      endhandle

      !eBehind        = !endVector.position.direction(!endVector.line(100mm).near(!ePosition)).angle(!endVector.direction).gt(0.01)
      handle any
        !eBehind = FALSE
      endhandle

      if(!sBehind and !this.flow or !eBehind and !this.flow.not()) then
        !autoConnect  = true
        !flow         = !this.flow
      endif

      -- End of non-parallel group

    endif

  endif

  -- Auto-Connection
  if(!autoConnect) then
    !this.connect(!components, !flow)

    -- Start of component group
    !sPosition    = !first.aPosition
    !sDirection   = !first.aDirection
    !ePosition    = !last.lPosition
    !eDirection   = !last.lDirection

    -- Is start or end of group connected
    !sConnected   = !first.atlength lt 0.01mm
    !eConnected   = !last.ltlength lt 0.01mm
    !connected    = !sConnected.or(!eConnected)

  endif

  -- Minimum tube length
  !sMinimumTube   = !this.componentData.minTubeLength(!first, true)

  !eMinimumTube   = !this.componentData.minTubeLength(!last, FALSE)

  -- Get minimum gap to fit components in
  if(!connected) then
    if(!sConnected) then
      !minGap     = !compLength + !eMinimumTube
    else
      !minGap     = !compLength + !sMinimumTube
    endif
  else
    !minGap       = !compLength + !sMinimumTube + !eMinimumTube
  endif


  -- This check is to see if the length lies within the snap dist.
  -- This is a recheck after component creation since atle and ltle value may change with adjacent components
  !snapDist = !this.componentData.snapDistance(!newComponent)
  var !mode mode
  !withinSnapDist  = !first.atlength leq !snapDist
  !toCheckLength = false
  if (!withinSnapDist) then
    if (!this.checkForSnapDist.not()) then
      !connected      = !this.connect(!newComponent)
      if (!this.autoCreate and !adjacentComponents.set()) then
        if (!newComponent.type.eq(|VALV|).not()) then
          !newComponents  = !this.connectAdjacent(!newComponent, !adjacentComponents, !specification)
        endif
      endif
      var !mode mode
      !withinSnapDist  = !first.atlength leq !snapDist
      !this.checkForSnapDist = true
    endif
  endif
  var !mode mode

  if (!first.atlength.leq(!sMinimumTube) and !mode.upCase().eq(|FORWARDS|)) then
    !toCheckLength = true
  elseif(!last.atlength.leq(!sMinimumTube) and !mode.upCase().eq(|BACKWARDS|)) then
    !toCheckLength = true
  endif

  -- If the component group and pipe segment are parallel, then we need
  -- to check that the component group will fit in the pipe leg

    if(!parallel and !toCheckLength and !notOutSide) then
    -- now we have an extended tube possibility the old tube checks are not relevant
    --if !this.component.tgeom then
    --if !newComponent.tgeom then
      if !createInLine then
        -- Does component fit in the gap
        --if(!pipeLength lt !minGap) then
          !slength = !first.atlength
          !elength = !last.ltlength

          -- Determine error message

          -- Min arrive tube
          --if(!eConnected and !slength lt !sMinimumTube) then

          if(!slength lt !sMinimumTube and !elength geq !eMinimumTube) then
            !text = 'Arrive tube is less than minimum (' & !sMinimumTube.string(!!distanceFmt) & '), actual tube length is (' & !slength.string(!!distanceFmt) & ').'
            !ques = true
          --elseif (!sConnected and !elength lt !eMinimumTube) then
          elseif (!elength lt !eMinimumTube and !slength geq !sMinimumTube) then
            !text = 'Leave tube is less than minimum (' & !eMinimumTube.string(!!distanceFmt) & '), actual tube length is (' & !elength.string(!!distanceFmt) & ').'
            !ques = true
          --elseif (!sConnected.not() and !eConnected.not()) then
          elseif (!slength lt !sMinimumTube and !elength lt !eMinimumTube) then
            !text = 'Arrive and leave tube are less than the minimum (' & !sMinimumTube.string(!!distanceFmt) & '/' & !eMinimumTube.string(!!distanceFmt) & '), actual tube lengths are (' & !slength.string(!!distanceFmt) & '/' & !elength.string(!!distanceFmt) & ').'
            !ques = false
          endif
          if (!slength.eq(0) or !elength.eq(0)) then
            !showAlert = false
            !ques = false
          else
            !showAlert = true
          endif
          -- Display any error message
          if(defined(!text)) then
            if (!ques) then
              if ((!slength + !elength) lt (2 * !sMinimumTube)) then
                !confirmVal = !!alert.warning(!text & | Minimum tube length could not be attained.|)
              endif
              if (undefined(!confirmVal)) then
                !confirmVal = !!alert.question(!text & | Do you wish to apply the Minimum length?|)
              endif
              if (!confirmVal.eq(|YES|)) then
                var !mode MODE
                !elements = object ARRAY()
                !elements.appendArray(!newComponents)
                !elements.append(!newComponent)
                !eleSeqAr = !elements.evaluate(object BLOCK(|!elements[!evalIndex].seq|))
                if(!mode.upCase() eq 'FORWARDS') then
                  !direction    = !!ce.aDirection.opposite()
                  !sortedEleSeqAr = !eleSeqAr.sortedIndices()
                else
                  !direction    = !!ce.lDirection.opposite()
                  !sortedEleSeqAr = !eleSeqAr.sortedIndices().invert()
                endif

                !curRef = !!ce
                do !x from 1 to !sortedEleSeqAr.size()
                  !!ce = !elements[!sortedEleSeqAr[!x]]
                  if (!x.eq(1)) then
                    FCONN
                    MOVE $!<direction> distance $!<sMinimumTube>
                  else
                    CONNECT
                  endif
                enddo
                !!ce = !curRef
              elseif (!confirmVal.eq(|CANCEL|)) then
                UNDODB
                return false
              endif
            else
              if (!showAlert) then
                !!alert.warning(!text)
              endif
            endif
          endif
      endif
  endif

  -- Delete component
  if(!deleteComponent) then
    !!ce    = !this.component
    !type   = !this.component.type
    DELETE $!<type>
  endif

  -- Navigate to new component
  !!ce = !newComponent
  --CW make sure spref is correct
  !!ce.spRef = !specReference

  if (!this.dirCont.slope().neq(0).and(!!ce.type inset('ELBO','BEND','TEE','OLET'))) then
    !lDir = !!ce.lDirection
    !this.applySlopeDirection(!lDir  )
  endif


  -- Revert to previous mode
  $!<mode>

  -- Handle multiple choices for adjacent components
  if(!this.reselectAdjacent().not()) then

    -- Need to check this, but if components are connected, don't allow
    -- "Flip" to be used
    --!this.flip.visible = !connected.not()
    !this.flip.active = !connected.not()

    -- Modification inactive
    --!this.modifyActive  = !this.flip.visible
    !this.modifyActive  = !this.flip.active

    -- Define graphic selection
    !this.graphicSelection()

    -- reorder attas if they have spkbrk FALSE
    -- P-30435 new tidyAtta routine replaces check for attas
    --removed because the defect failed and its better without it
    --!this.tidyAtta()

    -- Set end mark for UNDO
    !this.undo.endUndoable()

    -- Track
    --!this.track(!newComponent)
    !this.track()
  else

    -- Define graphic selection
    !this.graphicSelection()

    -- reorder attas if they have spkbrk FALSE
    --removed because the defect failed and its better without it
    --!this.tidyAtta()

    -- Set end mark for UNDO
    !this.undo.endUndoable()

  endif

  --!this.setTask('MODIFY')
  -- Return
  return true

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      reselectAdjacent
--
-- Description: Setup form for reselection of adjacent
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     Returns true if there are any adjacent items to select
--
------------------------------------------------------------------------

define method .reselectAdjacent() is BOOLEAN

  -- Initialise Variables
  !adjacentSelection  = !this.multipleSelect.set()

  -- No elements to reselect from
  if(!adjacentSelection) then
    !components     = ARRAY()
    !descriptions   = ARRAY()

    do !i indices !this.multipleSelect
      !type         = !this.multipleSelect[!i][1].type
      !components.append(!this.multipleSelect[!i][1].string())
      !index        = !this.componentData.pipingSpecs.activeSpec().types.findFirst(!type)

      if (!index.unset()) then
        -- we could not find any components from the current spec so we need to warn the use
        !!alert.message('Selecting Flanges from Specification ' & !this.branchSpecification.namn )
        !this.componentData.pipingSpecs.setActiveSpecification(!this.branchSpecification)
        !index        = !this.componentData.pipingSpecs.activeSpec().types.findFirst(!type)
        !description  = !this.componentData.pipingSpecs.activeSpec().descriptions[!index]
      else
        !description  = !this.componentData.pipingSpecs.activeSpec().descriptions[!index]
      endif
      !descriptions.append(!description)
    enddo

    -- Get component types from the system
    !this.adjacentType.dText  = !descriptions
    !this.adjacentType.rText  = !components

    -- Populate selection list
    !this.adjacentType()

    -- Move to Modify Tab
    !this.setTask('MODIFY')

  endif

  -- Return
  return !adjacentSelection

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      adjacentClear
--
-- Description: Clear the adjacent component list
--
--
------------------------------------------------------------------------
define method .adjacentClear()

  !this.multipleSelect.clear()
  !this.adjacentType.clear()
  !this.adjacentSelect.clear()

endmethod
-- End of method definition
-----------------------------------------------------------------------
--
-- Method:      adjacentType
--
-- Description: Setup form for selected type
--
--
------------------------------------------------------------------------
define method .adjacentType()

  -- Initialise Variables
  !index  = !this.adjacentType.val

  -- Get list of choices
  if(!index gt 0) then
    !texts  = !this.componentData.componentColumns(!this.multipleSelect[!index][2],'create')

    -- Populate list gadget
    !this.adjacentSelect.setHeadings(!texts[1])
    !this.adjacentSelect.setColumns(!texts[2])
    !this.adjacentSelect.rText   = !texts[3]

    -- Tag components to change
    !this.tagChanges()
    !!ce =!this.adjacentType.selection().dbRef()
    handle any
      -- item has been deleted
    endhandle


  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      adjacentSelect
--
-- Description: Select different specRef for component type in adjacent created components
-- this is called when a the alternative list is selected
--
------------------------------------------------------------------------
define method .adjacentSelect()
  !current = !!ce

  -- Initialise Variables
  !index          = !this.adjacentType.val
  !type           = !this.multipleSelect[!index][1].type
  handle any
    !!alert.error('Element has been deleted.')
    !this.setTask(|selectType|)
    return
  endhandle
  --!oldSpecRef     = !this.multipleSelect[!index][1].spRef
  !newSpecRef     = !this.adjacentSelect.selection().dbRef()
  handle ANY
    return
  endhandle

  -- Check on connectivity of the components
  !first          = !this.newComponents.first()
  !last           = !this.newComponents.last()

  -- Get pipe segment leg
  !startPosition  = !this.adjacentPosition(!first, true)
  !startDirection = !this.adjacentDirection(!first, true)
  !endPosition    = !this.adjacentPosition(!last, FALSE)
  !endDirection   = !this.adjacentDirection(!last, FALSE)

  -- Pipe segment ends

  -- Start of component group
  !sPosition      = !first.aPosition
  !ePosition      = !last.lPosition

  -- Connected at the start of the group
  !sConnected     = !startPosition.near(!sPosition, 0.01mm)
  -- Connected at the end of the group
  !eConnected     = !endPosition.near(!ePosition, 0.01mm)

  -- If start and end are connected, we'll use the start
  if(!sConnected or !eConnected) then
    !flow         = true
    if(!eConnected) then
      !flow       = FALSE
    endif
  endif

  -- Loop through components and change their spec ref
  do !i indices !this.newComponents
    skip if(!this.newComponents[!i].type ne !type)
    --skip if(!this.newComponents[!i].spRef ne !oldSpecRef)
    skip if(!this.newComponents[!i].neq(!current))
    -- Change specRef
    !this.newComponents[!i].spRef = !newSpecRef
    -- Set attributes from spec
    !this.setSpecAttributes(!this.newComponents[!i])
    --CW set leave tube to gadget value
    if (!this.noLstuSpecs.gt(1)) then
      !this.newComponents[!i].lstu = !this.lstu.selection().dbRef()
    endif
    if (!type.eq('FLAN')) then
      !this.setFlangeAllowance(!this.newComponents[!i])
    endif
  enddo

  -- Perform reconnections

  -- If there is no flow defined, the we'll connected away from primary component
  if(undefined(!flow)) then
    !this.connect(!this.newComponent, !this.newComponents)

    -- Reconnected from appropriate end
  else
    !this.connect(!this.newComponents, !flow)
  endif

  -- Define graphic selection
  !this.graphicSelection()

  -- Track Component
  !this.track(!this.newComponent)

  -- Tag components to change
  !this.tagChanges()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      graphicSelection
--
-- Description: Define graphic selection of current components
--
--
------------------------------------------------------------------------

define method .graphicSelection()

  -- Select the new components
  !reference      = !!ce
  !selection      = object SELECTION()
  !componentList  = !this.newComponents

  -- Remove new component from list so we can make sure the handle is on
  -- the "new" component
  !index          = !componentList.findFirst(!this.newComponent)
  if(!index.set()) then
    !componentList.remove(!index)
  endif

  do !comp values !componentList
    !selection.add(!comp)
  enddo

  -- Add the selection to the graphical selection
  !selection.add(!this.newComponent)
  !selection.setCurrent()
  !!ce            = !reference

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      modifyMode
--
-- Description: Re-instigates the model editor mode if was previously active
--
------------------------------------------------------------------------
define method .modifyMode()

  -- Initialise Variables

  -- Set task to select and create component
  !this.setTask('MODIFY')

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      createAtPosition
--
-- Description: Instigate an EDG event to position the components
--
--
------------------------------------------------------------------------
define method .createAtPosition()

  !this.connectValue = false

  -- TM if we are dealing with an assembly, this bit calls the insert  assembly bit
  -- there should be an equivalent bit in the create by connection
  !this.oriComp = !this.component

  !componentType        = !this.componentList.selection('rText')
  if (!componentType.eq('')) then
    !!alert.error( 'no selection in component list')
    return
  endif
  if (!componentType.eq('ASSY')) then
    -- We are dealing with an assembly
    !this.assembly.varid = 'componentEditor.assembly'
    !this.assembly.buildNewAssembly('intube', !this.toTail.val )
    !this.newComponents = !this.assembly.builtitems
    return
  endif

  -- Initialise Variables
  !componentType          =!this.componentData.pipingSpecs.activeSpec().descriptions[!this.currentComponentIndex]
  !this.pickedPosition    = object POSITION()
  -- turn attaBreak on so that atta actual positions can be determined
  ATTABREAK ON branch
  handle any
  endhandle

  -- Define EDG Packet
  !packet                 = object EDGPACKET()
  !packet.definePosition('Identify branch leg or Model Intersection Point for ' & !componentType)

  !packet.priority        = 3
  !packet.description     = !this.edgDescription

  -- When the component has been created successfully
  !packet.remove          = TRUE
  !packet.action          = '!!componentEditor.createAtPosition(!this.return[1],true)'
  !packet.pickPacket.picks[1].pick.modifiable = true

  -- Get current modify mode state
  !this.modifyMode = !this.state.modifyMode()
  if(!this.modifyMode) then
    !this.state.modifyMode(false)
  endif

  -- Add to event system
  if(!!edgCntrl.add(!packet)) then
  endif

   !this.oriComp = object DBREF()

endmethod
-- End of method definition


------------------------------------------------------------------------
--
-- Method:      create3DPosition
--
-- Description: Instigate an EDG event to position the components
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------

define method .create3DPosition()

    !this.connectValue = false

  -- TM if we are dealing with an assembly, this bit calls the insert  assembly bit
  -- there should be an equivalent bit in the create by connection
  !componentType        = !this.componentList.selection('rText')
  if (!componentType.eq('ASSY')) then
    -- We are dealing with an assembly
    !this.assembly.varid = 'componentCreation.assembly'
    !this.assembly.buildNewAssembly('intube', !this.toTail.val )
    !this.newComponents = !this.assembly.builtitems
    return
  endif

  -- Initialise Variables
  --!componentType          = !this.specifications[!this.activeSpecIndex].descriptions[!this.currentComponentIndex]
  !this.pickedPosition    = object POSITION()

  -- Define EDG Packet
  !packet = object EDGPACKET()
  !packet.definePosition('Pick a 3D position for ' & !componentType)
  !packet.priority    = 1
  --!packet.remove      = false

  !packet.description     = !this.edgDescription

  -- When the component has been created successfully
  !packet.remove          = TRUE
  !packet.action          = '!!componentEditor.create3dPosition(!this.return)'
  !packet.continue        = '!!componentEditor.showEDG()'

  -- Add to event system
  if(!!edgCntrl.add(!packet)) then
  endif

    !this.oriComp = object DBREF()


endmethod

-- End of method definition
------------------------------------------------------------------------
--
-- Method:      create3DPosition
--
-- Description: instigate creation based on a passed 3D pick
--
------------------------------------------------------------------------
define method .create3DPosition(!data is ARRAY)

  !this.createAtPosition(!data[1],false)

endmethod
-----------------------------------------

------------------------------------------------------------------------
--
-- Method:      .showEDG()
--
-- Description: called as the continuation to the 3D position pick packet
--
------------------------------------------------------------------------

define method .showEDG()

  -- if model editor is on already EDG switches it off
  !state = object STATE()
  -- $P modEdMode(true, true)
  !state.modEdMode(true, true)

endmethod

------------------------------------------------------------------------
--
-- Method:      createAtPosition
--
-- Description: Create component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R     EDGPICKDATA  Data returned from the pick
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .createAtPosition(!data is EDGPOSITIONDATA, !createInLine is BOOLEAN)


  if (!this.toTail.val) then
    !modeVal = true
  else
    !modeVal = false
  endif

  !this.checkForSnapDist  = true

  -- Initialise new component
  !this.newComponent    = object DBREF()
  !originComponent = !!ce
  --!!ce = !this.component
  !tubing         = object EDGTUBING()
  !this.oriComp = !this.component

  -- filter out the type of pick between a tubing or reference point picks
  if (!data.type.eq('TUBING')) then
    -- Initialise Variables
    !tubing         = object EDGTUBING()
    if !!dtbGetOwnerType(!data.item,|BRAN|).eq(!this.branch) then
       !originComponent = !data.item
    endif
    !position       = !tubing.exact(!originComponent, !data.pointVector)
    !this.component = !data.item
    if (!!dtbGetOwnerType(!data.item,|BRAN|).neq(!this.branch)) then
      !position       = !tubing.through(!this.oriComp, !data.pointVector.position, !this.flow)
      !this.pickedPosition = !position
      !data.item = !this.oriComp
      !this.component = !this.oriComp
      !!ce = !this.component
      !this.create(true)
      return
    endif
  elseif !createInLine then
    -- we are using the new positioning in line capability
    !position       = !tubing.through(!this.component, !data.position, !this.flow )
    !this.pickedPosition = !position
    !!ce = !this.component
    !this.create(true)
    return
  endif


  -- if we get here we are positioning within a length of tubing
  -- now get the actual position
  -- if create inline is false it means that we are positioning the component in 3-D space and opening model editor to adjust the posiion
  if (!createInLine.not()) then
    !this.pickedPosition  = !data.position
    !component = !this.component
  else
    -- we are positioning in tube - now we need to work out which end
    -- Convert implied tube into a line
    !line             = !tubing.line(!data.item)

    -- Get the intersection between the pick and the tube line
    !linePosition     = !line.intersection(!data.pointVector)

    -- Determine the nearer end
    !distance         = !line.startPosition.distance(!linePosition)
    !start            = true
    !eDistance        = !line.endPosition.distance(!linePosition)
    if(!eDistance lt !distance) then
      !distance       = !eDistance
      !start          = FALSE
    endif

    -- Snap to adjacent components
    !snapDistance     = !this.componentData.snapDistance(!data.item)
    -- the snap distance is set to 2x tube od and should be configurable but the frame is never shown

    if(!distance le !snapDistance) then
      !this.checkForSnapDist = true
      -- Connect to up stream item
      if(!start) then
        !position     = !line.startPosition
        !component    = !data.item
        !flow         = true
        -- Connect to down stream item
      else
        !adjacent     = !this.adjacent(!data.item, true)
        !component    = !adjacent[2]
        !position     = !line.endPosition
        !flow         = FALSE
      endif

      -- Position in line (taking in current flow creation)
    else
      -- go and get the actual position
      !this.getPickedPosition(!originComponent,!linePosition,!snapDistance,!data)

      if (!start) then
        !this.flow = true
      else
        !this.flow = false
      endif

      -- Auto align component
      if(!this.autoAlign) then

        -- Get the arrive and leave vectors at either end of the tube line
        -- Head tube selected
        if(!data.tubing eq 'HEAD') then

          -- Arrive Vector
          !arriveVector   = object POINTVECTOR(!data.item.hPosition.wrt(/* ), !data.item.hDirection.wrt(/* ))

          -- Leave Vector
          -- Branch has no members
          if(!data.item.mCount.eq(0)) then
            !arriveVector = object POINTVECTOR(!data.item.tPosition.wrt(/* ), !data.item.tDirection.wrt(/* ))
            !leaveVector  = object POINTVECTOR(!data.item.hPosition.wrt(/* ), !data.item.hDirection.wrt(/* ))
            -- Use first component
          else
            !comp         = !data.item.members[1]
            -- leave vector is pointing back to the head
            !leaveVector  = object POINTVECTOR(!comp.aPosition.wrt(/* ), !comp.aDirection.wrt(/* ))
          endif

          -- Leave tube of component selected
        else
          -- Arrive Vector
          --!arriveVector   = object POINTVECTOR(!data.item.lPosition.wrt(/* ), !data.item.lDirection.wrt(/* ))
          --!leaveVector    = !this.getVectorPositions(!data.item)
          !arriveVector   = object POINTVECTOR(!originComponent.lPosition.wrt(/* ), !originComponent.lDirection.wrt(/* ))
          !leaveVector    = !this.getVectorPositions(!originComponent)

        endif

        -- Forwards Flow
        if(!this.flow) then
          !vector           = !arriveVector
        else
          !vector           = !leaveVector
        endif
        !flowline           = !vector.line(1000mm)

        -- Determine if the aligned position is either negative or within the snap distance
        !mappedPosition     = !flowline.near(!linePosition)
        !mappedDirection    = !vector.position.direction(!mappedPosition)
        !mappedDistance     = !vector.position.distance(!mappedPosition)

        -- Force a connection
        -- this tests to see if the position runs out of tube
        !connectComponents  = (!vector.direction.angle(!mappedDirection) gt 90 or !mappedDistance le !snapDistance)

        -- Position component
        if(!connectComponents.not()) then
          !this.pickedPosition  = !mappedPosition
        endif

        -- Use picked position on the line
      else
        !this.pickedPosition  = !linePosition
      endif
    endif

      -- If flow is forwards, then we use the component
      -- else we use the next component in the line
      if(!start) then
        !component      = !originComponent
      else
        -- get the previous and next components from the origin component as we ar building backwards
        -- from the next component
        !adjacent       = !this.adjacent(!originComponent, true)
        !component      = !adjacent[2]
      endif
    endif

    if (!this.noLstuSpecs.gt(1)) then
      !newBore = !component.lBore
      handle any
        !newBore = !component.hBore
      endhandle
      !originalBore = !this.component.lBore
      handle any
        !originalBore = !this.component.hBore
      endhandle
      if (!newBore.neq(!originalBore)) then
        !currentElement = !!ce
        !!ce = !this.lstuSelection
        !this.lstuSelection = !this.reviseTube(spec, !newBore, !this.lstuSelection)
        !!ce = !currentElement
      endif
    endif

  -- Set component and flow data (CE as there seems to be a tracking   -- problem)
  !!ce                  = !component
  !this.component       = !component

  --!this.setFlow(!start,'std')
  -- set the mode forwards/backwards to suit the building direction
  !this.flow(!start)

  -- Create the component
  !this.create(!createInLine)

  -- set the mode back to what it was when we first started building
  !this.flow(!modeVal)

  !this.setFlow(!modeVal,'std')
  -- Remove the position
  !this.pickedPosition  = object POSITION()
  -- turn attBreak back to default
  var !testAttaBreak ATTABREAK
  if !testAttaBreak.eq('ON') then
     ATTABREAK SPKBRK branch
     handle any
     endhandle
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      .getPickedPosition
--
-- Description: sets !this.pickedPosition
--
------------------------------------------------------------------------
define method .getPickedPosition(!originComponent is DBREF,!linePosition is POSITION,!snapDistance is REAL,!data is ANY)

  -- Auto align component
      if(!this.autoAlign) then

        -- Get the arrive and leave vectors at either end of the tube line
        -- Head tube selected
        if(!data.tubing eq 'HEAD') then

          -- Arrive Vector
          !arriveVector   = object POINTVECTOR(!data.item.hPosition.wrt(/* ), !data.item.hDirection.wrt(/* ))

          -- Leave Vector
          -- Branch has no members
          if(!data.item.mCount.eq(0)) then
            !arriveVector = object POINTVECTOR(!data.item.tPosition.wrt(/* ), !data.item.tDirection.wrt(/* ))
            !leaveVector  = object POINTVECTOR(!data.item.hPosition.wrt(/* ), !data.item.hDirection.wrt(/* ))
            -- Use first component
          else
            !comp         = !data.item.members[1]
            -- leave vector is pointing back to the head
            !leaveVector  = object POINTVECTOR(!comp.aPosition.wrt(/* ), !comp.aDirection.wrt(/* ))
          endif
          -- Leave tube of component selected
        else
          -- Arrive Vector
          !arriveVector   = object POINTVECTOR(!originComponent.lPosition.wrt(/* ), !originComponent.lDirection.wrt(/* ))
          !leaveVector    = !this.getVectorPositions(!originComponent)
        endif

        -- Forwards Flow
        if(!this.flow) then
          !vector           = !arriveVector
        else
          !vector           = !leaveVector
        endif
        !flowline           = !vector.line(1000mm)

        -- Determine if the aligned position is either negative or within the snap distance
        !mappedPosition     = !flowline.near(!linePosition)
        !mappedDirection    = !vector.position.direction(!mappedPosition)
        !mappedDistance     = !vector.position.distance(!mappedPosition)

        -- Force a connection
        -- this tests to see if the position runs out of tube
        !connectComponents  = (!vector.direction.angle(!mappedDirection) gt 90 or !mappedDistance le !snapDistance)

        -- Position component
        if(!connectComponents.not()) then
          !this.pickedPosition  = !mappedPosition
        endif

        -- Use picked position on the line
      else
        !this.pickedPosition  = !linePosition
      endif

endmethod

------------------------------------------------------------------------
--
-- Method:     getVectorPositions
--
-- Description: gets the position and direction of the next point
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
-- Return:
--   [Data Type] [Description]
--    ARRAY       Components create
--
------------------------------------------------------------------------
define method .getVectorPositions(!item is DBREF) is POINTVECTOR


  -- this could be a problem because the next item could be an atta with spkbrk FALSE
  !finalItem = !item.owner
  do !a from 1 to !item.owner.members.size() - !item.order
    if (!item.owner.members[!item.order + !a].type.eq('ATTA')) then
      if (!item.owner.members[!item.order + !a].spkbrk.not()) then
        skip
      endif
    endif
    !finalItem = !item.owner.members[!item.order + !a]
    break
  enddo
  if (!finalItem.type.eq('BRAN')) then
    -- its the last member
    var !endPos   TPOSITION  of BRAN  wrt World
    var !endDir   TDIRECTION of BRAN  wrt World
  else
    var !endPos   APOSITION  of $!<finalItem>  wrt World
    var !endDir   ADIRECTION of $!<finalItem>  wrt World
  endif

  !leaveVector    = object POINTVECTOR(!endPos.position(), !endDir.direction())

  return !leaveVector

endmethod
------------------------------------------------------------------------
--
-- Method:      .connectionChoices(
--
-- Description: Tries to connect to previous item, if not move by min tube length
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component get and test specRef of
--    2   R      DBREF       Specification to search in
--    3   R      BOOLEAN     Perform test for multiple valid spec references
-- Return:
--   [Data Type] [Description]
--    ARRAY       List of specRef which are valid for component and connection
--
------------------------------------------------------------------------

define method .connectionChoices(!component is DBREF, !specification is DBREF, !multiChoice is BOOLEAN) is ARRAY

  -- Initialise Variables
  !available    = ARRAY()
  !specRef      = !component.spRef
  !position     = !component.position
  !orientation  = !component.orientation
  !posFlag      = !component.posFlag
  !oriFlag      = !component.oriFlag
  !!ce          = !component

  -- Get all possible components, in case the component current one fails
  !selections   = SELECT SPEC $!<specification>

  -- Put the default at the beginning of the list
  !index        = !selections.findFirst(!specRef)
  !selections.remove(!index)
  !selections.insert(1, !component.spRef)

  -- Loop through available selections
  do !i indices !selections

    -- Set spec ref
    !component.spRef   = !selections[!i]

    -- Try and connect to previous component
    CONNECT
    -- Unable to connect
    handle ANY
      -- SpecRef can connect to previous component
    elsehandle NONE
      !available.append(!selections[!i])

      -- If we are only finding the first, then we will exist
      break if(!multiChoice.not())
    endhandle

  enddo

  -- Return the component back to its original state
  !component.spRef        = !specRef
  !component.position     = !position
  !component.orientation  = !orientation
  !component.posFlag      = !posFlag
  !component.oriFlag      = !oriFlag

  -- Set attributes from spec
  !this.setSpecAttributes(!component)

  -- Return
  return !available

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      connect
--
-- Description: Tries to connect passed component to previous item,
--              if it can't then it moves it by min tube length
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if completed successfully
--
------------------------------------------------------------------------

define method .connect(!component is DBREF) is BOOLEAN

  -- Initialise Variables
  !connected  = true

  -- Navigate to component
  !!ce        = !component

  -- Connect
  CONNECT

  -- Handle Bad Connection
  handle ANY
    -- Extract units for error warning
    !minTubeLength  = !this.componentData.minTubeLength(!component)
    if (!minTubeLength.unset()) then
      !minTubeLength = 100mm
      !minTubeLengthString = !minTubeLength.string(!!distanceFmt)
      !!alert.warning('Invalid expression for minimum tube length. Please review Piping Application Defaults. Minimum tube length set as $!minTubeLengthString')
    else
      !minTubeLengthString = !minTubeLength.string(!!distanceFmt)
    endif

    -- Does the component require
    FCONN
    var !mode MODE
    if(!mode.upCase() eq 'FORWARDS') then
      !direction    = !!ce.aDirection.opposite()
      error |Incompatible connection types. Item positioned with a $!minTubeLength spool length from the previous component|
    else
      !direction    = !!ce.lDirection.opposite()
     error |Incompatible connection types. Item positioned with a $!minTubeLength spool length from the next component|
    endif

    MOVE $!<direction> distance $!<minTubeLength>
    !connected      = FALSE
  endhandle

  --reset control graphics and aids to reset to the zero angle if we are using the connect to prev button on the
  --modify tab
  if (!this.currentTask.eq('MODIFYCOMPONENT')) then
    !this.directionControlActions.resetAidAxes(TRUE)
  endif

  -- Return
  return !connected

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      connect
--
-- Description: Connects the passed components to the previous item
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      ARRAY       List of components to be connected
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if completed successfully
--
------------------------------------------------------------------------

define method .connect(!components is ARRAY) is BOOLEAN

  -- Connect the first component
  var !mode MODE
  if(!mode.upCase() eq 'FORWARDS') then
    !flow     = true
  else
    !flow     = FALSE
  endif

  -- Perform connection
  !connected  = !this.connect(!components, !flow)

  -- Return
  return !connected

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      connect
--
-- Description: Connects the passed components to the from up or down stream item
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      ARRAY       List of components to be connected
--    2   R      BOOLEAN     Flow direction
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if completed successfully
--
------------------------------------------------------------------------

define method .connect(!componentList is ARRAY, !flow is BOOLEAN) is BOOLEAN

  -- Initialise Variables
  var !mode MODE

  -- Set flow direction
  !this.flow(!flow)

  -- Order the list
  !components = !!componentOrder(!componentList)
  !components.compress()

  -- If backwards, invert list
  if(!flow.not()) then
    !components.invert()
  endif

  -- Connect the first component
  !connected  = !this.connect(!components[1])

  -- Connect all the remaining components
  do !i from 2 to !components.size()
    !!ce = !components[!i]

    -- We are using FCONNECT as we're working on the assumption this
    -- is a connected network of components.
    FCONNECT
  enddo

  -- Return
  $!<mode>
  return !connected

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      connect
--
-- Description: Connects the passed components about the passed component
--              Note: the component must be in the list of items
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to connect about
--    2   R      ARRAY       List of components to be connected
-- Return:
--   [Data Type] [Description]
--    BOOLEAN     True if completed successfully
--
------------------------------------------------------------------------

define method .connect(!component is DBREF, !componentList is ARRAY) is BOOLEAN

  -- Initialise Variables
  var !mode MODE

  -- Check component is in the list
  !index = !componentList.findFirst(!component)
  if(!index.unset()) then
    !!alert.warning('Component is not in list of components')
    return FALSE
  endif

  -- Order the list
  !components = !!componentOrder(!componentList)

  -- Split the list into two "before" component and "after" component
  !before     = !components.to(!index)
  !before.invert()
  !before.removeFirst()
  handle any
    --P-12759 for if !before array is empty
  endhandle
  !after      = !components.from(!index)
  !after.removeFirst()
  handle any
    --P-12759 for if after array is empty
  endhandle

  -- Set flow direction and connect preceding components
  !this.flow(false)
  do !i indices !before
    !!ce = !before[!i]
    CONNECT
    handle ANY
      FCONNECT
    endhandle
  enddo

  -- Set flow direction and connect following components
  !this.flow(true)
  do !i indices !after
    !!ce = !after[!i]
    CONNECT
    handle ANY
      FCONNECT
    endhandle
  enddo

  -- Return
  $!<mode>
  return true

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      connectAdjacent
--
-- Description: Creates and connects adjacent components for both side
--              of the passed component
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
--    2   R      ARRAY       List of adjacent component types (in order) to created
--    3   R      DBREF       Specification to create from
-- Return:
--   [Data Type] [Description]
--    ARRAY       List of components created
--
------------------------------------------------------------------------

define method .connectAdjacent(!component is DBREF, !adjacentTypes is ARRAY, !specification is DBREF) is ARRAY

  -- Initialise Variables
  !newComponents    = ARRAY()
  !currentComponent = !component
  var !mode MODE

  -- Navigate to component
  !!ce              = !currentComponent

  -- Set mode
  !this.flow(!this.flow)

  -- Determine if we can connect the passed component to the previous item
  CONNECT

  -- Component can't be connected, so we will create the adjacent components
  handle ANY
    FCONNECT

    -- Create first adjacent component, this should also determine if the passed
    -- component needs to be flipped
    !newComponent = !this.createFirstConnected(!component, !adjacentTypes[1], !specification, !this.flow.not())
    -- If the first component create has been connected, then we need to create
    -- the subsequent components and check them against the previous item to see
    -- if we need to create any more of the adjacent
    if(!newComponent.set()) then
      !newComponents.append(!newComponent)

      -- Can we connect the adjacent to the previous component
      !!ce  = !newComponent
      !this.flow(!this.flow)
      CONNECT

      -- If we can't connect then we'll try and create the other adjacent
      handle ANY
        if(!adjacentTypes.size() gt 1) then
          !nextComponentTypes = !adjacentTypes
          !nextComponentTypes.remove(1)

          !lastComponent      = !newComponent

          -- Loop through each of the adjacent components and
          -- Loop through the adjacent component types
          do !i indices !nextComponentTypes
            !type = !nextComponentTypes[!i]

            -- Create adjacent component in opposite to creation direction
            !this.flow(!this.flow.not())
            !newComponent     = !this.createConnected(!lastComponent, !type, !specification, true)

            -- Don't bother to
            break if(!newComponent.unset())
            !newComponents.append(!newComponent)
            !lastComponent    = !newComponent

            -- If component can be connected to the previous item, then we
            -- won't create any more adjacent ones
            !this.flow(!this.flow)
            CONNECT
            handle ANY
            elsehandle NONE
              break
            endhandle

          enddo

        endif

      endhandle
    endif

    -- Invert the new component list so that the order is correct
    !newComponents.invert()

    -- Connect the created components
    !componentList = !newComponents
    !componentList.append(!component)

    !this.flow(!this.flow)

    -- Connect components together
    !this.connect(!componentList, !this.flow)

  endhandle

  -- code to deal with adjacent elements which don't need a gasket
  if undefined(!newComponent) then
    if !this.testForGasketConnection(!component) then
      --  we have found a component with integral gaskets and we need to add a flange
      !test = !adjacentTypes.findFirst('GASK')
      if !test.gt(0) then
        !adjacentTypes.removeFrom(!test,1)
      endif
      !newComponents = !this.createAdjacent(!component, !adjacentTypes, !specification, !this.flow)
      return !newComponents
    endif
  endif


  -- Define the adjacent components on the other side of the component
  !specRefs   = ARRAY()
  !deriveList = !adjacentTypes

  -- Move to component
  !!ce  = !component
  !this.flow(!this.flow)

  -- Get connected components
  !connected        = !component.brConnect
  -- TM attas with spkbrk FALSE always have 0 atlen and ltlen so brcon identifies adjacent components
  if (!component.type.eq('ATTA')) then
    if (!component.spkbrk.not()) then
      !connected = ARRAY()
    endif
  endif

  -- Check the connected types off against the adjacent types, this allows
  -- use to mirror the adjacent components from items created or existing ones
  if(!connected.set()) then

    -- Put components in sequence order
    !components     = !!componentOrder(!connected)
    !components.compress()
    -- Invert the lists, if the flow is forwards (as we are working away from
    -- the component created)
    if(!this.flow) then
      !components.invert()
    endif

    --87343 We are only interested in the component next to the new one so the next line removes the rest
    !components = !components.to(1,1)

    -- Get connected types (of same bore)
    do !i indices !components
      if(!this.flow) then
        !checkBore  = !components[!i].aBore
      else
        !checkBore  = !components[!i].lBore
      endif
      if(!checkBore eq !this.arriveBore) then
        !types[!i]  = !components[!i].type
      else
        !types[!i]  = ''
      endif
    enddo

    -- Compare the adjacent types with the connected components and
    -- where possible use the connected of the same type
    do !i indices !adjacentTypes

      -- Connection list is less than adjacent type list
      if(undefined(!components[!i])) then
        break
      endif

      -- Check for adjacent item types in the connected set
      !index = !types.findFirst(!adjacentTypes[!i])

      -- If there isn't a component of the same type, break
      break if(!index.unset())
      -- Break if the adjacent type and the component type are not the same
      --break if(!adjacentTypes[!i] neq !components[!i].type)

      -- Use spec ref for opposite side component
      !specRefs[!i] = !components[!index].spRef
      !deriveList[!i].delete()

    enddo
  endif

  -- Create Opposite side components
  !lastComponent      = !component
  !createOppositeSide = true
  !!ce                = !component
  !this.flow(!this.flow)

  -- Create the adjacent components and connect them, in theory the specRefs
  -- should come before any derived elements
  do !i indices !specRefs
    !type = !adjacentTypes[!i]

    NEW $!<type>
    !newComponent       = !!ce
    !newComponent.rLock = 2
    !newComponent.spRef = !specRefs[!i]

    -- Set attributes from spec
    !this.setSpecAttributes(!newComponent)
    --CW Select leave tube from gadget - Fix P-32959

    if !this.lstu.visible then

      !!ce.lstu = !this.lstu.selection().dbRef()
      handle any
        SELECT LSTU
      endhandle
    else
      select lstube
    endif


    CONNECT
    -- If we can't connect the component, then its most probably not required,
    -- e.g. Flange has gasket one side, but not the other
    handle ANY
      DELETE $!<type>
      !createOppositeSide = FALSE
      break
    endhandle

    !newComponents.append(!newComponent)
    !lastComponent        = !newComponent

  enddo

  -- Create any adjacent components that need to be derived
  if(!deriveList.empty().not() and !createOppositeSide) then
    !deriveList.compress()

    -- Create subsequent adjacent components
    if (!lastComponent.type.eq(|ATTA|)) then
      !newAdjacent = object ARRAY()
    else
      !newAdjacent = !this.createAdjacent(!lastComponent, !deriveList, !specification, !this.flow)
    endif

    -- Connect the new adjacent to the previous items
    if(!newAdjacent.empty().not()) then
      !newComponents.appendArray(!newAdjacent)

      -- Loop through new components
      do !i indices !newAdjacent
        !!ce = !newAdjacent[!i]

        CONNECT
        handle ANY
          FCONNECT
          !!alert.warning('Problem in connecting adjacent component.')
        endhandle
      enddo
    endif
  endif

  -- Move to component
  !!ce  = !component


  -- First of all, can be connected to
  $!<mode>
  return !newComponents


endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      createFirstConnected
--
-- Description: Creates the first adjacent item to the passed component
--              on the upstream or downstream side. Very similar to .createdConnected
--              but it tries to connect the original component to the new component
--              just in case it needs to flip it.
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
--    2   R      STRING      Component type to create adjacent to component
--    3   R      DBREF       Specification to create component from
--    4   R      BOOLEAN     Side of component to create adjacent item on
--                           True - upstream creation, FALSE - downstream creation
-- Return:
--   [Data Type] [Description]
--    DBREF       Component created
--
------------------------------------------------------------------------
define method .createFirstConnected(!component is DBREF, !adjacentType is STRING, !specification is DBREF, !flow is BOOLEAN) is DBREF

  -- Initialise Variables
  !invalidConnection  = true
  var !mode MODE

  -- Set flow direction
  !this.flow(!flow)

  -- Create adjacent component
  NEW $!<adjacentType>
  !newComponent       = !!ce
  !newComponent.rLock = 2
  SELECT WITH SPEC $!<specification>
  -- Bad Selection
  handle ANY
    DELETE $!<adjacentType>
    !!ce        = !component
    $!<mode>
    return object DBREF()
  endhandle

  --CW set the leave tube to the gadget setting - Fix P-32959

  if !this.lstu.visible then
    !!ce.lstu = !this.lstu.selection().dbRef()
    handle ANY
      select lstube
    endhandle
  else
    select lstube
  endif

  -- We need to look at how choices would work here, as we need to be able to
  -- try the previous component to flip the component?

  -- Get all possible components, in case the default fails
  !selections   = SELECT SPEC $!<specification>

  -- Put the default at the beginning of the list
  !index        = !selections.findFirst(!newComponent.spRef)
  !selections.remove(!index)
  !selections.insert(1, !newComponent.spRef)

  -- Loop through available selections
  do !i indices !selections

    -- Move to component
    !!ce                  = !newComponent
    !this.flow(!flow)

    -- Set spec ref
    !newComponent.spRef   = !selections[!i]

    -- Set attributes from spec
    !this.setSpecAttributes(!newComponent)

    -- Try and connect to original component
    CONNECT
    -- Unable to connect
    handle ANY
      FCONNECT
      -- Try connecting original component to new adjacent one
      !!ce                = !component
      !this.flow(!flow.not())
      CONNECT
      -- Unable to connect
      handle ANY
        -- Original component can connect to first component
      elsehandle NONE
        !invalidConnection = FALSE
        break
      endhandle

      -- Permissible connection
    elsehandle NONE
      !invalidConnection  = FALSE
      break
    endhandle
  enddo

  -- If we still have an invalid connection here, we delete the component
  if(!invalidConnection) then
    !!ce            = !newComponent
    DELETE $!<adjacentType>
    !newComponent   = object DBREF()

  else

    -- Possible Choices for connection
    !choices      = !this.connectionChoices(!newComponent, !specification, true)

    -- Add item and its choices to the list of multiple select
    if(!choices.size().gt(1)) then
      !data[1]      = !newComponent
      !data[2]      = !choices
      !this.multipleSelect.append(!data)

    endif

  endif

  -- Return component
  $!<mode>
  return !newComponent

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      createConnected
--
-- Description: Creates the passed element type and connects to the passed
--              component. Uses default first, if this fails, then it tries
--              the others in the selection.
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
--    2   R      STRING      Component type to create adjacent to component
--    3   R      DBREF       Spec component is to be selected from
--    4   R      BOOLEAN     Test for multiple component types
-- Return:
--   [Data Type] [Description]
--    DBREF       Components create
--
------------------------------------------------------------------------
define method .createConnected(!component is DBREF, !type is STRING, !specification is DBREF, !multiSelect is BOOLEAN) is DBREF

  -- Initialise Variables
  --!invalidConnection  = true

  -- Move to component
  !!ce                = !component

  -- Create new component
  NEW $!<type>
  !newComponent       = !!ce
  !newComponent.rLock = 2

  !deleteAndReturn = FALSE

  SELECT WITH SPEC $!<specification>
  -- Bad Selection
  handle (42,55)(42,501)
    !selection        = SELECT SPEC $!<specification>
    handle ANY
      !deleteAndReturn = TRUE
    elsehandle NONE
      if(!selection.set()) then
        !newComponent.spRef = !selection[1]

        -- Set attributes from spec
        !this.setSpecAttributes(!newComponent)
        --CW set leave tube to gadget Fix P-32959

        !newComponent.lstu = !this.lstu.selection().dbRef()
      else
        !deleteAndReturn = TRUE
      endif
    endhandle
  elsehandle ANY
    !deleteAndReturn = TRUE
  endhandle

  -- If we we're unable to select the spref then delete the component and return with an error message.
  if (!deleteAndReturn) then
    DELETE $!<type>
    !!ce            = !component
    return object DBREF()
  endif

  if (!type.eq('FLAN')) then
    !this.setFlangeAllowance(!newComponent)
  endif
  -- somewhere it creates the next item in the list - flan gask flan gask
  -- then it deletes the last gask
  -- Possible Choices for connection
  !choices          = !this.connectionChoices(!newComponent, !specification, !multiSelect)

  -- If we still have an invalid connection here, we delete the component
  if(!choices.unset()) then
    !!ce            = !newComponent
    DELETE $!<type>
    !newComponent   = object DBREF()

    -- Set the spec reference and connect
  else
    -- Add item and its choices to the list of multiple select
    if(!choices.size().gt(1)) then
      !data[1]      = !newComponent
      !data[2]      = !choices
      !this.multipleSelect.append(!data)
    endif
    !newComponent.spRef = !choices[1]

    -- Set attributes from spec
    !this.setSpecAttributes(!newComponent)

    !this.connect(!newComponent)
  endif

  return !newComponent

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      createAdjacent
--
-- Description: Creates the adjacent items on both sides of the passed item
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
--    2   R      ARRAY       Types of components to create adjacent to component (in order)
--    3   R      DBREF       Specification to create from
-- Return:
--   [Data Type] [Description]
--    ARRAY       Components create
--
------------------------------------------------------------------------
define method .createAdjacent(!component is DBREF, !adjacentTypes is ARRAY, !specification is DBREF) is ARRAY

  -- Initialise Variables
  !componentString      = !component.string()
  !newComponents        = ARRAY()
  var !mode MODE

  -- P-12283: Create upstream adjacent components for with flow and Create downstream adjacent components for against flow.
  if (!this.toHead.val.eq(FALSE) and !this.toTail.val.eq(TRUE)) then
    !this.flow(FALSE)
  elseif (!this.toHead.val.eq(TRUE) and !this.toTail.val.eq(FALSE)) then
    !this.flow(TRUE)
  endif
  --end fix

  !originComponent      = !component

  if !this.testForGasketConnection(!originComponent) then

    !test = !adjacentTypes.findFirst('GASK')
    if !test.gt(0) then
      !adjacentTypes.removeFrom(!test,1)
    endif

  endif

  do !i indices !adjacentTypes
    !type               = !adjacentTypes[!i]
    !newComponent       = !this.createConnected(!originComponent, !type, !specification, true)
    if(!newComponent.unset()) then
      break
    endif
    !originComponent    = !newComponent
    --CW set leave tube to value on gadget - Fix P-32959
    if (!this.noLstuSpecs.gt(1)) then

      !!ce.lstu = !this.lstu.selection().dbRef()
    endif

    !newComponents.append(!newComponent)
  enddo

  -- P-12283: Create downstream adjacent components for with flow and Create upstream adjacent components for against flow.
  if (!this.toHead.val.eq(FALSE) and !this.toTail.val.eq(TRUE)) then
    !this.flow(TRUE)
  elseif (!this.toHead.val.eq(TRUE) and !this.toTail.val.eq(FALSE)) then
    !this.flow(FALSE)
  endif
  --end fix

  !originComponent      = !componentString.dbRef()

  -- Loop through components created for opposite side and use the same
  do !i indices !adjacentTypes
    !type               = !adjacentTypes[!i]
    !newComponent       = !this.createConnected(!originComponent, !type, !specification, FALSE)
    if(!newComponent.unset()) then
      break
    endif
    !originComponent    = !newComponent

    if (!this.noLstuSpecs.gt(1)) then
      !newComponent.lstu = !this.lstuSelection
    endif

    !newComponents.append(!newComponent)
  enddo

  -- Return component
  $!<mode>
  return !newComponents

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      createAdjacent
--
-- Description: Creates the first adjacent item to the passed component
--              on the upstream or downstream side.
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component to have adjacent components created
--    2   R      STRING      Component type to create adjacent to component
--    3   R      DBREF       Specification to create from
--    4   R      BOOLEAN     Side of component to create adjacent item on
--                           True - upstream creation, FALSE - downstream creation
-- Return:
--   [Data Type] [Description]
--    ARRAY       Components create
--
------------------------------------------------------------------------

define method .createAdjacent(!component is DBREF, !adjacentTypes is ARRAY, !specification is DBREF, !flow is BOOLEAN) is ARRAY

  -- Initialise Variables
  !lastComponent  = !component
  !newComponents  = ARRAY()
  var !mode MODE

  -- Create adjacent component
  !!ce            = !component

  -- Set flow direction
  !this.flow(!flow)

  -- Loop through the adjacent component types
  do !i indices !adjacentTypes
    !type               = !adjacentTypes[!i]
    -- Create new component
    !newComponent       = !this.createConnected(!lastComponent, !type, !specification, true)
    -- Don't bother to
    break if(!newComponent.unset())
    !newComponents.append(!newComponent)
    !lastComponent  = !newComponent
  enddo

  -- Return component
  $!<mode>
  return !newComponents

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      flow
--
-- Description: Set creation flow for component (forwards/backwards)
--  True for forward, FALSE for backwards
--
--
------------------------------------------------------------------------
define method .flow(!flow is BOOLEAN)
  if(!flow) then
    FORWARDS
  else
    BACKWARDS
  endif
endmethod

------------------------------------------------------------------------
--
-- Method:      .testForGasketConnection
--
-- Description: tests the passed component for a gasket arrive and leave
-- looking to match ctype WG or G as the first characters
--
--
------------------------------------------------------------------------
define method .testForGasketConnection(!component is DBREF) is BOOLEAN

  if !component.type.eq('GASK') then
    return FALSE
  endif
  !arrive = !component.aconn
  !leave = !component.lconn
  if !arrive.match('WG').eq(1).and(!leave.match('WG').eq(1)) then
    return TRUE
  elseif !arrive.match('G').eq(1).and(!leave.match('G').eq(1)) then
    return TRUE
  else
    return FALSE
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      setSpecAttributes
--
-- Description: Sets component attributes to from specification
--
--
------------------------------------------------------------------------

define method .setSpecAttributes(!component is DBREF)

  -- Initialise Variables
  !reference  = !!ce
  !!ce        = !component

  -- collect all attributes for a design element
  !attributes = ARRAY()

  !attributes[1] = 'ANGL'
  !attributes[2] = 'RADI'
  !attributes[3] = 'HEIG'
  !attributes[4] = 'SHOP'

  !questions = ARRAY()
  !answers = ARRAY()
  !maxAnswers  = ARRAY()

  -- P-30777 change to choices mechanism to eliminate spaces in styp problem
  var !choices choice number
  do !a from 1 to !choices.real()
    var !question Choice question $!a
    !questions.append(!question)
    var !answer Choice answer $!a
    !answers.append(!answer)
    var !maxans Choice maxans $!a
    !maxAnswers.append(!maxans)
  enddo

  do !i from 1 to !questions.size()
    !index = !attributes.findFirst(!questions[!i])
    if (!index.set()) then
      !answer = !answers[!i]
      !maxAnswer = !maxAnswers[!i]
      if(!attributes[!index] eq 'SHOP') then
        -- SHOP / SITE can be shop / true or site / FALSE
        if(!answer.eq('TRUE') or !answer.eq('SHOP')) then
          !component.shop = TRUE
        elseif (!answer inset('FALS','FALSE','SITE')) then
          !component.shop = FALSE
        endif
      else
        -- we have real attribute
        -- we are going to use a greater value
        if(REAL(!answer) gt REAL(!maxAnswer)) then
          !maxAnswer = !answer
        endif
        !value = !component.$!attributes[$!index]

        -- set attribute to a proper value
        if(!value lt REAL(!answer) or !value gt REAL(!maxAnswer)) then
          !component.$!attributes[$!index] = REAL(!maxAnswer)
          handle ANY
          endhandle
        endif
      endif
    endif
  enddo

  -- fix for bends resetting radius
  -- I am not sure if this is needed any more
  -- Reselect component
  --RESELECT WITH SPEC $!<component.spow>
  handle ANY
  endhandle
  if (!this.bendAnswer.set()) then
    if (!this.bendAnswer.not()) then
      !!ce.radius = !this.bendSaved
      handle ANY
        -- element has no bend radius
        !this.bendAnswer = FALSE
      endhandle
    endif
  endif

  -- go and test the loffline flag
  !this.setOffLineFlag(!reference)

  -- Return to original component
  !!ce        = !reference

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      assemblyVisibility
--
-- Description: Sets component attributes to from specification
--
-- Method Type: Procedure
--
------------------------------------------------------------------------
define method .assemblyVisibility(!visible is BOOLEAN)

  !this.componentGadgets(false)
  !this.assemblyFrame.visible = !visible
  !this.assemblyComponentFrame.visible = !visible
  !this.createAssemblyActions.visible  = !visible
  --!this.fLine.visible         = !visible
  --!this.nLine.visible          = !visible.not()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      .displayAssembly
--
-- Description: Sets component attributes to from specification
--
-- Method Type: Procedure
--
------------------------------------------------------------------------
define method .displayAssembly()

  !selected = !this.assemblyChoices.selection().dbRef()
  handle any
    !!alert.error('No Assembly selected')
    return
  endhandle
  !save = !!ce
  !!ce = !selected

  -- Get information about the pipe (i.e. volume)
  var !unusedVolume VOL CE
  handle ANY
    --!!alert.confirm (|No Graphical Elements in this Assembly|)
    !this.localView.visible = FALSE
    return
  elsehandle NONE
    !this.localView.visible = TRUE
  endhandle

  --   !background = !!gphViews.views.first().background
  --   handle any
  --     !background = 15
  --   endhandle
  -- !this.drawList = object drawList()
  --   !this.localView.background = !background
  !this.localView.shaded     = TRUE
  !this.drawList.attachview(!this.localView)
  !this.drawList.removeall()
  !this.drawList.add(!!ce)
  !this.limits(!!ce)

  var !a coll all bran for ce
  do !b values !a
    mark $!b
  enddo

  -- iso2
  !dira[1]  = -0.57735
  !dira[2]  = 0.57735
  !dira[3]  = -0.57735

  !this.localView.direction = !dira

  -- mark all the relevant elements in the local view
  !this.assembly.markelements()

  !!ce = !save

endmethod
------------------------------------------------------------------------

------------------------------------------------------------------------------
define method .limits(!element is DBREF)

  -- Get volume of item
  !volume      = object VOLUME(!element)

  -- Load view limits with Volume
  !array[1]    = !!comValueConvert(!volume.from.east,'MM')
  !array[2]    = !!comValueConvert(!volume.to.east,'MM')
  !array[3]    = !!comValueConvert(!volume.from.north,'MM')
  !array[4]    = !!comValueConvert(!volume.to.north,'MM')
  !array[5]    = !!comValueConvert(!volume.from.up,'MM')
  !array[6]    = !!comValueConvert(!volume.to.up,'MM')

  -- Set view Limits
  !this.localView.limits = !array

endmethod
------------------------------------------------------------------------

------------------------------------------------------------------------
--
-- Method:      .calculateRadius
--
-- Description: Calculates radius of a bend using N*OD option
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1    R       REAL      Multiplier N for radius (N*OD)
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .calculateRadius(!radiusMultiplier is REAL)

  -- Check if there is a component selected to create from
  if(!this.component.set()) then

    -- Get the component that the bend will be created from
    !adjacentComponent = !this.component

    --If its a branch then goto first member instead
    if(!adjacentComponent.type eq 'BRAN') then
      if(!adjacentComponent.mCount ne 0) then
        !adjacentComponent = !this.component.members.first()
        !lod = !adjacentComponent.lod
      else
        if(!this.flow eq TRUE) then
          -- Flow is forwards so use leave
          !lod = phod
        else
          !lod = ptod
        endif
      endif
    else
      -- its not a branch
      if(!this.flow eq TRUE) then
        -- Flow is forwards so use leave
        !lod = !adjacentComponent.lod
      else
        !lod = !adjacentComponent.aod
      endif
    endif

    !radius = !radiusMultiplier * !lod
    handle any
      !radius = 0
    endhandle

    if (!this.currentTask.eq(|RESELECT|)) then
      -- Set the bend radius in the text gadget
      !this.editBendRadius.val = !radius
      radius $!radius
    else
      !this.bendRadius.val = !radius
    endif

  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      displayTubes
--
-- Description: Called to display the lstu gadget and call functions
--                to load its contents
--
--
------------------------------------------------------------------------
define method .displayTubes(!element is DBREF, !mode is STRING)


  if (!mode.eq('create')) then
    if (!element.badRef().or(!element.unset())) then
      return
    endif
    if (!this.elementIsComponentOrBranch(!element).not().and(!element.type.neq('SPCO'))) then
      -- we are above branch level so we can't work out the lstu
      !this.lstuFrame.visible = FALSE
      return
    endif

    if !this.branch.pSpec.restricted then
         !selection = !this.activeSpecification
    else
         !selection = !this.branch.pSpec
    endif

    -- fix to stop it aborting on an undefined dbref
    if (!element.unset()) then
      return
    endif
    if (!element.type.eq('SPCO')) then

      !type = !this.componentList.selection()
      !spRef = !element
      !questions      = !this.componentData.pipingSpecs.questions(!type)
      !answers        = !this.componentData.pipingSpecs.answers(!type, !spRef)
      !boreIndices  = !this.componentData.boreIndices(!type)


      if (!this.flow.eq(TRUE)) then
        !this.noLstuSpecs = !this.loadTubes(!this.lstu, !answers[!questions.findFirst('PBOR' & !boreIndices[2])], !selection,!mode)
        handle ANY
        endhandle
      else
        !this.noLstuSpecs = !this.loadTubes(!this.lstu, !answers[!questions.findFirst('PBOR' & !boreIndices[1])], !selection,!mode)
        handle ANY
        endhandle
      endif

    else
      if (!element.type.eq('BRAN')) then
        if (!this.flow.eq(TRUE)) then
          !bore = !element.hBore
        else
          !bore = !element.tBore
        endif
      else
        !bore = !element.lBore
      endif
      !this.noLstuSpecs = !this.loadTubes(!this.lstu, !bore, !selection,!mode)
    endif

    if (!this.noLstuSpecs.gt(1)) then
      -- 171624 Piping - Component Creation - Leave Tube Selection Errors
      -- changed from !this.choices.visible
      !this.lstuFrame.visible = !this.choices.active.and(!this.choices.visible)
    else
      !this.lstuFrame.visible = FALSE
    endif
  else
    -- its edit mode
    -- Initialise Variables
    !componentType  = !this.activeComponent[1].type()
    !component      = !this.activeComponent[1].component()

    -- Get Components Questions and Answers
    !questions      = !this.editComponentData.pipingSpecs.questions(!componentType)
    !answers        = !this.editComponentData.pipingSpecs.answers(!componentType, !component.spRef)

    !boreIndices    = !this.activeComponent[1].arriveLeave()

    if (!answers.set()) then
      !bore = !answers[!questions.findFirst('PBOR' & !boreIndices[2])]
      handle any
        !this.editLstuFrame.visible = FALSE
        return
      endhandle
      !this.noLstuSpecs = !this.loadTubes(!this.editLstu, !bore, !this.branch.pSpec,!mode)
      if (!this.noLstuSpecs.gt(1)) then
        !this.editLstuFrame.visible = TRUE
      else
        !this.editLstuFrame.visible = FALSE
      endif
    else
      !this.editLstuFrame.visible = FALSE
    endif
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      loadTubes
--
-- Description: Loads the available leave tube into !gadget
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
-- Return:
--   [Data Type] [Description]
-- REAL  The number of lsTubes available for bore and spec
--
------------------------------------------------------------------------
define method .loadTubes(!gadget is GADGET, !bore is BORE, !specification is DBREF,!mode is STRING ) is REAL

  --remove callbacks from the gadget (they will be reinstated at the end of the method)
  --this is required because the current build is incorrectly firing the callbacks of the
  --supplied gadget when they are being manipulated by code
  !gadgetCallback = !gadget.callback
  !gadget.callback = ''

  !dText = object ARRAY()
  !rText = object ARRAY()
  -- TM fix to stop the new bend command causing a tracking error
  if (!bore.unset()) then
    return 0
  endif
  -- Get numeric value of bore as a string. The final .real().string() removes trailing decimal zeros
  !format           = object FORMAT()
  !format.dimension = 'L'
  !tubes = !!getSpecComponents(!specification.name, 'TUBE', !bore.string(!format).real().string())

  !dtxr = object STRING()
  !mtxx = object STRING()

  do !tube values !tubes
    !dtxr = !tube.dtxr
    handle any
      !dtxr = ''
    endhandle

    !mtxx = !tube.mtxx
    handle any
      !mtxx = ''
    endhandle

    !outerValue = !tube.catRef.para[2].real()
    handle any
      !outer = '--'
    elsehandle NONE
      -- if imperial units
      !outerMetric = !!comValueConvert(!outerValue,'MM')
      if ( !!isImperialLength('DIST')) then
        -- first convert parameter value to MM. If parameter is undimensioned
        -- then assume that it is in MM, otherwise convert the dimensioned value
        -- to INCH
        !outer     = !!comUnitsConvert(!outerMetric,'MM','INCH').string('D3')
      else
        !outer = !outerMetric.string('D1')
      endif
    endhandle

    !wall = !tube.pwallt[1].string('D2')
    handle any
      !wall = '--'
    endhandle

    !dText.append(!outer + ' OD x ' + !wall + ' Thk, ' + !dtxr + ' ' + !mtxx )
    !rText.append(!tube.string())

  enddo

  !gadget.dText = !dText
  !gadget.rText = !rText

  if (!mode.eq('create')) then
    !component = !this.component
  else
    !component = !this.editComponent
  endif

  !gadget.select('rText', !component.lstu.string())
  handle any
    !gadget.select('rText', !component.hstu.string())
    handle any
      !gadget.select('rText', !gadget.rText[1])
      handle ANY
      endhandle
      --Initialise lstube selection
      !this.lstuSelection = !gadget.rText[1].dbRef()
      handle ANY
      endhandle
    elsehandle none
      if (  !this.lstuSelection.unset()) then
        --Initialise lstube selection

        !this.lstuSelection = !component.hstu
      endif
    endhandle
  elsehandle none

    if (!component.aBore.neq(!component.lBore) or (!this.lstuSelection.unset())) then
      --Initialise lstube selection
      !this.lstuSelection = !component.lstu
    endif
  endhandle

  --reinstate the gadget callback
  !gadget.callback = !gadgetCallback

  return !tubes.size()

endmethod

------------------------------------------------------------------------
--
-- Method:      tubeChoice
--
-- Description: Called to set the lstu selection
--
--
------------------------------------------------------------------------
define method .tubeChoice(!lstu is STRING)

  !this.lstuSelection = !this.lstu.selection().dbRef()

  --CW to change Leave Tube on current element using gadget--

  if (!!ce.type.eq('BRAN')) then
    handle Any
    endhandle
    return
  endif

  if (!!ce.lstu.sType.neq(!this.lstu.selection().dbRef().sType)) then
    !answer = !!alert.confirm ('Leave Tube selected differs from Current Element - do you wish to modify Leave Tube of Current Element?')
    if (!answer.eq('YES')) then
      !!ce.lstu = !this.lstu.selection().dbRef()
    else
      !this.track(!!ce)
      handle Any
      endhandle
    endif
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      reviseTube
--
-- Description: Called to revise the selection for a place in position
--                              with new bore.
--
--
------------------------------------------------------------------------
define method .reviseTube(!spec is DBREF ,!bore is BORE, !lstu is DBREF) is DBREF

  !tubes = !!getSpecComponents(!spec.name, 'TUBE', !bore.string().replace('mm', '').replace('in', ''))

  do !tube values !tubes
    if (!lstu.tanswer.eq(!tube.tanswer)) then
      return !tube
    endif
  enddo

  return !tubes[1]

endmethod

------------------------------------------------------------------------
--
-- Method:      testBendRadius
--
-- Description: Called to test if a radius can be machine defined or spec defined
--
--
------------------------------------------------------------------------
define method .testBendRadius(!component is DBREF,!questions is ARRAY, !answers is ARRAY )is REAL

  -- P-30990 if the user is not at a piping component the radius is not needed
  if (!component.unset()) then
    return 0
  endif
  if (!component.catRef.unset()) then
    return 0
  endif

  !radius = REAL()
  do !a index !questions
    if (!questions[!a].match('RAD').eq(1)) then
      -- the radius is set in the spec
      !radius = !answers[!a]
      !this.setBendGadgetExtra('Spec')
      return !radius
    endif
  enddo

  -- if it gets here it could not find the right radius in the spec so now we need to test the dbfrad
  if (!component.catRef.compType.eq('VAR')) then
    !radius = !this.machineTest(!this.component)
    if (!radius.gt(-1)) then
      !this.setBendGadgetExtra('Machine')
      return !radius
    else
      !radius            = 0mm
      !bendOption        = !this.bendRadiusOption.selection('DTEXT')
      !definedBendOption = ( !bendOption.eq('Define') or !bendOption.match('OD').gt(0) )
      if( !definedBendOption.not() or !this.bendRadius.val eq 0mm ) then
        !!alert.error('Unable to Set Bend Radius from Bending Machine - Please Select a Radius' )
      else
        !radius = !this.bendRadius.val.real()
      endif
    endif
  endif

  -- what does this do?????
  !this.setBendGadgetExtra('create')
  return !radius

endmethod
------------------------------------------------------------------------

------------------------------------------------------------------------
--
-- Method:      setBendGadgetExtra
--
-- Description: Called to test if a radius can be machine defined or spec defined
--
--
--
------------------------------------------------------------------------
define method .setBendGadgetExtra(!type is STRING)

  !dText = !this.bendRadiusOption.dText
  !rText = !this.bendRadiusOption.rText

  -- strip out the last option if its either
  -- [1]  <GADGET> !!componentEditor.bendRadiusOption [LIST]
  -- [2]  <GADGET> !!componentEditor.bendRadius [TEXT]
  -- test 1 split out the radius
  if (!dText.findFirst('Define').neq(!dText.size())) then
    !index =  !dText.findFirst('Define')
    !dText.removeFrom(!index + 1)
    !rText.removeFrom(!index + 1)
  endif

  if (!type.eq('Spec')) then
    !dText.append('Specification')
    !rText.append('Spec')
  elseif (!type.eq('Machine')) then
    !dText.append('Machine')
    !rText.append('Machine')
  endif

  !this.bendRadiusOption.dText = !dText
  !this.bendRadiusOption.rText = !rText
  !this.bendRadiusOption.val = !dText.size()

endmethod

------------------------------------------------------------------------
--
-- Method:      machineTest
--
-- Description: Called to test if a radius can be machine defined
--
--
--
------------------------------------------------------------------------
define method .machineTest(!component is DBREF ) is REAL

  -- Bend Machine reference could come from Branch, Pipe or Zone
  !macList = !this.branch.bendmacref
  if (!macList.unset() or !macList.badRef()) then
    -- Try Pipe
    !macList = !this.branch.owner.bendmacref
    if (!macList.unset() or !macList.badRef()) then
      -- Try Zone
      !macList = !this.branch.owner.owner.bendmacref
    endif
  endif

  if (!macList.unset() or !macList.badRef()) then

    return -1
  else
    var !machines collect all FMBDIM for $!macList
    do !a values !machines
      -- fix to add a tolerance to the outside diameters
      !radiusDiff = abs(!a.dbRef().od - !this.tubeOD)
      handle ANY
        -- if any of the values are unset then its not a match
        return -1
      endhandle
      !radiusTest = !radiusDiff.lt(1mm)
      if (!radiusTest) then
        if (!a.dbRef().wThickness.neq(0)) then
          -- test the wall thickness
          !wallDiff = abs(!a.dbRef().wThickness - !this.wallTH )
          if (!wallDiff.lt(0.1mm)) then
            return !a.dbRef().bradius.value() * !this.tubeOD
          endif
        else
          return !a.dbRef().bradius.value() * !this.tubeOD
        endif
      endif
    enddo
  endif

  return -1

endmethod
------------------------------------------------------------------------

------------------------------------------------------------------------
--
-- Method:      setFlangeAllowance
--
-- Description: Called to test if a radius can be machine defined
--
--
------------------------------------------------------------------------
define method .setFlangeAllowance(!flange is DBREF)

  !type = !flange.catRef.compType
  !flanType = !type.match('ALL')
  if (!flanType.gt(0)) then
    !flange.allow = !flange.flallow
    handle ANY
      -- in case the flange allowance is unset
      !!alert.error('Selected flange is an allowance flange but no allowance value is defined')
      !flange.allow = 0
      !flange.loose = FALSE
      return
    endhandle
    !flange.loose = TRUE
  else
    !flange.allow = 0
    !flange.loose = FALSE
  endif

endmethod
------------------------------------------------------------------------

------------------------------------------------------------------------
--
-- Method:      getSpcomWall
--
-- Description: Called to find the wall of a spcom by looking for the
-- appropriate pdaEle and navigating to the wthEle (should this be core?)
--
--
------------------------------------------------------------------------
define method .getSpecomWall(!spRef is DBREF)

  !bore = !this.component.hBore
  if (!bore.unset()) then
    return
  endif

  !pdaRef = !spRef.pdaReference
  if (!pdaRef.unset()) then
    !spec = !this.component.pspe
    !pdaRef = !spRef.spown.pdaRef
  endif
  if (!pdaRef.unset()) then
    return
  else
    var !bores coll all pdaEle for $!pdaRef
    do !b value !bores
      if (!b.dbRef().nBore.eq(!bore)) then
        !wthRef = !b.dbRef().wthRef
        if (!wthRef.unset()) then
          return
        else
          !this.findWallVal(!bore,!wthRef)
        endif
      endif
    enddo
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      findWallVal
--
-- Description: Called to find the wall thickness by looking through a wall thickness table
--
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--       !bore   BORE       The bore size we are looking for
--       !table  DBREF      The wall thickness table to be searched
------------------------------------------------------------------------
define method .findWallVal(!bore is BORE ,!table is DBREF)

  var !bores coll all WTHELE for $!table
  do !b value !bores
    if (!b.dbRef().nBore.eq(!bore)) then
      !this.wallTH = !b.dbRef().wThickness
      handle ANY
        !this.wallTH = 0
      endhandle
      return
    endif
  enddo
  -- if we get here we have not found a wall thickness
  !this.wallTH  = 0

endmethod
------------------------------------------------------------------------
--
-- Method:     tidyAtta
--
-- Description: Reorder any attas which may have been displaced by the insertion
--
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--       !component  DBREF      the insert component
------------------------------------------------------------------------
define method .tidyAtta()

  var !atta coll all atta with spkbrk eq FALSE for $!this.branch
  if (!atta.size().eq(0).or(!this.newComponents.size().eq(0))) then
    return
  endif
  !attas = ARRAY()

  do !a values !atta
    !attas.append(!a.dbRef())
  enddo
  !componentList = ARRAY()
  !attaList = ARRAY()
  !distanceList = ARRAY()

  do !element values !this.branch.members
    if (!element.spRef.unset()) then
      !!alert.error(!element.flnn & ' has an unset spref - Please select it')
      return
    endif
    !tubing         = object EDGTUBING()
    !line           = !tubing.line(!element)
    !position       = !line.startPosition
    skip if (!line.length().eq(0).or(!attas.findFirst(!element).set()))
    do !a values !attas
      !dist = !this.checkAlignment(!line,!a.position.wrt(/* ))
      if (!dist.neq(-99)) then
        !componentList.append(!element)
        !attaList.append(!a)
        !distanceList.append(!dist)
      endif
    enddo
  enddo

  -- we should now have a list of attas which should match the total number of attas
  -- if the array does not match the total number of attas then we have something which is offline somehow
  if (!attaList.size().neq(!attas.size())) then
    -- we need to find those attas in a strange position and maintain their order
    !oddList = !attas.difference(!attaList)
  endif

  -- now we should have a list of attas
  -- go and reorder them by sorting the attas
  !this.sortAttas(!componentList,!attaList,!distanceList)

  -- reorder any oddments
  !this.findNearest(!oddList)

endmethod

------------------------------------------------------------------------
--
-- Method:     .sortAttas
--
-- Description: given a set of inline attas we need to work out which ones are in order
--
--
------------------------------------------------------------------------
define method .sortAttas(!components is ARRAY, !attas is ARRAY, !distances is ARRAY)

  -- the code below does not work using the old sort routines
  -- we need to sort the array

  !newArray = ARRAY()
  !componentList = !components
  !componentList.unique()
  do !a index !componentList
    !newArray[!a] = ARRAY()
    do !b index !components
      if (!components[!b].eq(!componentList[!a])) then
        -- we have found an instance of the component
        !tempArray[1] = !componentList[!a]
        !tempArray[2] = !attas[!b]
        !tempArray[3] = !distances[!b]
        !newArray[!a].append(!tempArray)
        !tempArray = ARRAY()
      endif
    enddo
  enddo

  do !a values !newArray
    if (!a.size().eq(1)) then
      !this.reorder( !a[1][1], !a[1][2] )
    else
      -- we need to process the results more
      !this.processMultiple(!a)
    endif
  enddo

endmethod
------------------------------------------------------------------------
--
-- Method:     processMultiple
--
-- Description: reorder multiple attas after a component
--
--
-- passes an array of components and an array of attas to be reordered
------------------------------------------------------------------------
define method .processMultiple(!comps is ARRAY)

  -- we are faced with a multiple ARRAY where
  -- !comps[1] is the real component
  -- !comps[2] is an atta
  -- !comps[3] is the distance from the real component
  -- first we need to reIndex the array based on the distances

  !tempArray = ARRAY()
  -- get the numbers
  do !a values !comps
    !tempArray.append(!a[3])
  enddo

  !index = !tempArray.sortedIndices()
  !newArray = !comps.reIndex(!index)
  !this.reorder( !newArray[1][1], !newArray[1][2] )
  do !a from 2 to !newArray.size()
    !this.reorder( !newArray[!a - 1][2], !newArray[!a][2] )
  enddo

endmethod

------------------------------------------------------------------------
--
-- Method:     .checkAlignment
--
-- Description: test to see if a given position lies on a line between two positions
--
--
------------------------------------------------------------------------
define method .checkAlignment(!testLine is LINE, !atta  is POSITION) is REAL
  -- construct a line from pl of the prev component to pa of the next
  -- if the atta position is on the line then its on the

  if (!testLine.onProjected(!atta).and(!testLine.distance(!atta).lt(1mm))) then
    -- the atta is on the line
    !pv = !testLine.pointVector()
    !newPv = !pv.through(!atta)
    !distance = !testLine.startPosition.distance(!newPv.position)
    return !distance
  else
    return -99
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:     reorder
--
-- Description: Reorder passed attas
--
--
------------------------------------------------------------------------
define method .reorder( !component is DBREF, !atta is DBREF  )

  if (!component.type.eq('BRAN')) then
    reorder $!atta before 1
  else
    !ce = !!ce
    !!ce = !component.owner
    reorder $!atta after $!component
    handle (2,18)
      -- element is locked so cannot change anyway
    endhandle
    !!ce = !ce
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:     findNearest
--
-- Description: find the nearest component to the atta position and reorder it
--
--
------------------------------------------------------------------------
define method .findNearest(!comps is ARRAY)

  do !a values !comps
    !nearest = 10000
    do !element values !this.branch.members
      skip if (!element.type.eq('ATTA'))
      !near = !a.position.distance(!element.position)
      if (!near.lt(!nearest)) then
        !nearest = !near
        !origin = !element
      endif
    enddo
    !this.reorder(!origin,!a)
  enddo

endmethod

------------------------------------------------------------------------
--
-- Method:     checkComponents
--
-- Description: check to see if items have different arrive and leave bores
--
--
------------------------------------------------------------------------
define method .checkComponents(!mode is STRING ) is BOOLEAN

  !this.multiBore = FALSE
  !this.reducingComponent = FALSE

  --loop through displayed choices and find  if items in list have differing arrive/leave bores

  -- Mark the database
  if (!mode.eq('edit')) then
    !items = !this.editAvailableComponents
  else
    !items = !this.availableComponents
  endif

  do !n index !items
    skip if !items[!n].badRef()
    if (!items[!n].ppbor[1].neq(!items[!n].ppbor[2])) then
      !this.multiBore = TRUE
      !this.reducingComponent = TRUE
      -- no need to look further if both set to TRUE
      break
    endif

    --check for olets and tees to set dspbore for list gadget

    !g = !items[!n].catRef.gType
    !h = 'TEE,OLET'
    if (!h.match(!g).gt(0)) then
      !this.multiBore = TRUE
    endif
  enddo

endmethod

------------------------------------------------------------------------
--
-- Method:      setFromIcon
--
-- Description:  sets up the component list to show the available components
-- for the passed component type.
--
--
------------------------------------------------------------------------
define method .setFromIcon(!type is STRING)
  
  if (!this.componentList.rtext.empty()) then
    !!alert.warning('No valid components exist in this spec.')
    return
  endif
  
  if (!type.neq(!this.componentList.selection('rtext'))) then
    !this.multiBore = FALSE
  endif
  !this.componentList.select('Rtext','$!type')
  handle any
    !!alert.error('No $!type available')
    return
  endhandle
  -- set the stype filter so that it loads all the columns
  !this.sTypeFilter = FALSE
  -- Check if the current task is select component, if it is not, then set the task
  if (!this.currentTask.neq('SELECTCOMPONENT')) then
    !this.setTask(|SELECTCOMPONENT|)
    -- draw the graphical aids for selecting a component
    if(!this.component.badRef().not()) then
      !this.getArriveLeaveData(!this.branch, !this.component)
    endif
    --clear any outstanding aids coming from the direction control
    !this.directionControlActions.aidclear()
    --clear any outstanding aids coming from the reselect tab
    AID CLEAR ALL $!<this.tagReselect>
  endif
    -- if the task is already in select component mode, we don't need to change the task, just refresh the gadgets
    !this.setSelectComponentTask(!type)
    handle ANY
      !!alert.error('No $!type available')
      return
    endhandle

endmethod

------------------------------------------------------------------------
--
-- Method:      directButtons
--
-- Description: Actions called by all of the direct buttons
--
--
--
------------------------------------------------------------------------
define method .directButtons(!option is STRING)

  var !mode mode
  !this.undoAdd('Direct button action')
  if (!option.eq('CE')) then
    !this.executeCommand( 'thro CE' )
  elseif (!option.eq('Cursor')) then
    !this.pickPosition()
    handle ANY
      !!alert.error(!!error.text)
    endhandle
  elseif (!option.eq(|Next|)) then
    if (!mode.eq('Forwards')) then
      !throughPosition = apos of next wrt /*
      handle ANY
        !!alert.error(!!error.text)
        return
      endhandle
    else
      !throughPosition = lpos of next wrt /*
      handle ANY
        !!alert.error(!!error.text)
        return
      endhandle
    endif
    !this.positionThrough(!!ce, !throughPosition )
    handle ANY
      !!alert.error(!!error.text)
    endhandle
  elseif (!option.eq(|Tail|)) then
    !throughPosition = tpos of branch wrt /*
    handle ANY
      !!alert.error(!!error.text)
      return
    endhandle
    !this.positionThrough(!!ce, !throughPosition )
    handle ANY
      !!alert.error(!!error.text)
    endhandle
  elseif (!option.eq(|Previous|)) then
    if (!mode.eq('Forwards')) then
      !throughPosition = lpos of previous wrt /*
      handle ANY
        !!alert.error(!!error.text)
        return
      endhandle
    else
      !throughPosition = apos of previous wrt /*
      handle ANY
        !!alert.error(!!error.text)
        return
      endhandle
    endif
    !throughPosition = pos of prev wrt /*
    handle ANY
      !!alert.error(!!error.text)
      return
    endhandle
    !this.positionThrough(!!ce, !throughPosition )
    handle ANY
      !!alert.error(!!error.text)
    endhandle
  elseif (!option.eq(|Head|)) then
    !throughPosition = hpos of branch wrt /*
    handle ANY
      !!alert.error(!!error.text)
      return
    endhandle
    !this.positionThrough(!!ce, !throughPosition )
    handle ANY
      !!alert.error(!!error.text)
    endhandle
  endif


endmethod

------------------------------------------------------------------------
--
-- Method:      .setMode
--
-- Description: sets mode between forwards and backwards
--
--
------------------------------------------------------------------------
define method .setMode(!mode is BOOLEAN, !reset is BOOLEAN  )

  if (!this.mode.val.neq(!mode)) then
    !this.mode.val = !mode
  endif

  if (!reset) then
    !this.modeButtonSave = !mode
  endif
  -- mode is either forwards or backwards
  -- need some code to show which it is
  if (!mode) then
    forwards
    !this.mode.setToolTip('Change to backwards mode')
  else
    backwards
    !this.mode.setToolTip('Change to forwards mode')
  endif

  --setup the arrive position of the current element in terms of the current mode forwards or backwards
  var !newMode mode
  if (!newMode.upCase().eq('BACKWARDS')) then
    !arrive = !!ce.leave
    handle ANY
    endhandle
    !leave = !!ce.arrive
    handle ANY
    endhandle
  else
    !arrive = !!ce.arrive
    handle ANY
    endhandle
    !leave = !!ce.leave
    handle ANY
    endhandle
  endif

  --reset the direction shown in the direction text gadget appropriate to the current mode
  !this.direction.val = !!ce.pdir[!leave].wrt( /* ).string()
  handle any
    if (!!ce.type.eq('BRAN')) then
      !this.direction.val = !!ce.hDir.wrt(/* ).string()
    endif
  endhandle
  -- reset the direction control actions to suit backwards and forwards
  if (!this.currentTask.eq('MODIFYCOMPONENT').and(!reset)) then
    !this.directionControlModeChange()
  endif
endmethod

------------------------------------------------------------------------
--
-- Method:      .directionControlModeChange()
--
-- Description: changes the directioncontrol
--
------------------------------------------------------------------------
define method .directionControlModeChange()

    --reset the direction control
    if (!this.elementIsComponent(!!ce)) then
      -- align the direction control
      !this.setDirectionControlElement(!!ce)
      -- if its a component then we need to set the distance text
      !this.setDistanceText()
      !this.componentFeedBack.element(!!ce)
      !this.slopeList.setComponent(!!ce)
    else
      !this.directionControlActions.default()
    endif
    !this.filmStrip()

endmethod


------------------------------------------------------------------------
--
-- Method:      .direct
--
-- Description: directs the current component
-- probably not called any more
--
--
------------------------------------------------------------------------
define method .direct(!dir is STRING)

  !this.undoAdd('Direct $!dir')
  direct $!dir
  handle any
    ori and p3 is $!dir
    handle any
    endhandle
  endhandle

  !this.undo.endUndoable()
  !this.track()

endmethod

------------------------------------------------------------------------
--
-- Method:      connect
--
-- Connects the current component to the previous one
-- Called by the connect button
--
------------------------------------------------------------------------
define method .connect()

  !this.undoAdd('Connect component')

  -- is it a group
  !selection = object SELECTION()
  !selection.getCurrent()
  !selectList = !selection.getSelection()
  !newList = !selectList
  do !l index !newList
    if (!newList[!l].badRef()) then
      !selectList.remove(!selectList.findFirst(!newList[!l]))
    endif
  enddo
  if (!selectList.size().gt(1)) then
    !lists = !this.reorderList(!selectList)
    !list = !lists[1]
    !test = !lists[2]
  else
    !this.connect(!!ce)
    !this.undo.endUndoable()
    !this.track()
    return
  endif

  if (((!test[!test.maxindex()] - !test[!test.minindex()]) + 1 ) neq(!test.size())) then
    !!alert.error('selected items are not concurrent - connecting first element')
    !this.connect(!!ce)
    !this.undo.endUndoable()
    !this.track()
    return
  endif

  !select = FALSE
  var !mode mode
  if (!list.size().gt(1)) then
    if (!mode.eq('Forwards').and(!list.findFirst(!!ce).eq(1))) then
      --- its the first item in the list
      !select = TRUE
    elseif (!mode.eq('Backwards') and (!list.findFirst(!!ce) eq (!list.size()))) then
      !list.invert()
      !select = TRUE
    endif
  endif

  if (!select) then
    if (!!alert.confirm('Do you want to connect all the selected items?').eq('YES')) then
      do !a values !list
        !!ce = !a
        !this.connect(!!ce)
      enddo
    else
      !this.connect(!!ce)
    endif
  else
    !this.connect(!!ce)
  endif
  !this.undo.endUndoable()
  !this.track()

endmethod
------------------------------------------------------------------------
--
-- Method:     reorderList
--
-- Description: called to reorder a component selection array into
-- list order
--
--
------------------------------------------------------------------------
define method .reorderList(!input is ARRAY ) is ARRAY

  !order = ARRAY()
  !return = !input
  do !a values !input
    !order.append(!a.order)
  enddo

  !sortedOrder = !order.sortedIndices()
  !order.reIndex(!sortedOrder)
  !return.reIndex(!sortedOrder)
  !returnArray = ARRAY()
  !returnArray.append( !return)
  !returnArray.append( !order)

  return !returnArray

endmethod

------------------------------------------------------------------------
--
-- Method:      resetSpec
--
-- Description: called by pressing the spec linklabel
-- Resets the current spec back to that of the branch
--
--
------------------------------------------------------------------------
define method .resetSpec()

  --get the name of the current spec selection
  !selectedSpec = !!componentEditor.specList.selection('RTEXT')

  --get the name of the branch spec
  !!componentEditor.branchSpecification = /$!!componentEditor.currentSpec.tag

  --if the selected spec does not match the branch spec then reset it so it does
  if (!selectedSpec.dbref().neq(!!componentEditor.branchSpecification)) then
    !!componentEditor.specList.select('dtext',!!componentEditor.branchSpecification.namn)
    !this.selectAlternativeSpec(!this.branchSpecification)
    if (!!ce.owner.type.eq('BRAN')) then
      !this.setFromIcon(!!ce.type)
    else
      -- force the default to be an elbow
      !this.setFromIcon('ELBO')
    endif
    --remove any select out of spec highlighting
    --!!componentEditor.setSpecText(TRUE)
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      filmStrip
--
-- Description: Shows the washing line on navigation
--
--
------------------------------------------------------------------------
define method .filmStrip()

  if (!!ce.owner.type.eq('BRAN').or(!!ce.type.eq('BRAN'))) then
    -- we can continue
    !this.sequenceSelector.active = TRUE
  else
    !this.sequenceSelector.active = FALSE
    !this.filmStrip1.addPixMap('AvevaSharedIcons>ID_MATCHLINES>32')
    !this.filmStrip2.addPixMap('AvevaSharedIcons>ID_MATCHLINES>32')
    !this.filmStrip3.addPixMap('AvevaSharedIcons>ID_MATCHLINES>32')
    !this.filmStrip4.addPixMap('AvevaSharedIcons>ID_MATCHLINES>32')
    !this.filmStrip5.addPixMap('AvevaSharedIcons>ID_MATCHLINES>32')
    return
  endif

  -- make a list of components
  if (!!ce.type.eq('BRAN')) then
    !list  = !!ce.members
    !branch = !!ce
  else
    !list = !!ce.owner.members
    !branch = !!ce.owner
  endif

  !list.insert(1,!branch)
  !list.insert(1,=0)
  !list.insert(1,=0)
  !list.append(!branch)
  !list.append(=0)
  !list.append(=0)

  !newList = ARRAY()
  do !x values !list
    !newList.append(!x.string())
  enddo

  !newList[3] = 'HEAD'
  !newList[!newList.size() - 2] = 'TAIL'

  var !mode mode
  !reversed = FALSE
  if (!mode.eq('Backwards')) then
    !list.invert()
    !newList.invert()
    !reversed = TRUE
    !this.sequenceSelector.tag =  'Component Sequence List (Backwards)'
  else
    !this.sequenceSelector.tag =  'Component Sequence List'
  endif

  !order = !list.findFirst(!!ce)
  --76452 12.2#Test11a-Error message is displayed for elbow using position through tail or connect to previous options
  -- the following if block fixes the above defect but its not clear why it should.
  -- It seems that the findFirst( !!ce ) fails to get the current element first time round
  if (!order.unset()) then
    !refNo = !!ce.refNo
    !order = !list.findFirst(!refNo)
  endif
  !list = !list.from(!order - 2,5)
  !newList = !newList.from(!order - 2,5)
  do !a from 1 to 5


    if (!list[!a].badRef()) then
      !newIcon = !this.selectIcon('BLANK')
    elseif (!list[!a].type.eq('BRAN')) then
      -- we are at a head or tail but we don't know which
      !newIcon = !this.selectIcon(!newList[!a])
    else
      if (!list[!a].type inset ('FLAN','REDU')) then
        if (!reversed) then
          !newIcon = !this.selectIcon(!list[!a].type & !list[!a].leave)
        else
          !newIcon = !this.selectIcon(!list[!a].type & !list[!a].arrive)
        endif
      else
        !newIcon = !this.selectIcon(!list[!a].type)
      endif
    endif
    !commandString = '!this.filmStrip' & !a & '.addPixMap(!newIcon)'
    $!commandString
    !commandString = '!this.filmStrip' & !a & '.callback = |!this.moveToComp('
    !commandString = !commandString  & |'| & !list[!a] &  |')| & '|'
    $!commandString
    !name = !list[!a].flnn
    handle ANY
    elsehandle NONE
      !commandString = '!this.filmStrip' & !a & '.setToolTip(|$!name|)'
      $!commandString
    endhandle
  enddo


  --!this.drawDimension()

endmethod
------------------------------------------------------------------------
--
-- Method:      .drawDimension()
--
-- Description: could be called as part of the filmStrip to dimension
-- the current working area
--
--
------------------------------------------------------------------------
-- evaluation to demonstrate dimensioning
define method .drawDimension()

  -- only draw dimensions if the branch contains 5 components or above
  if (!!ce.owner.members.size().lt(5)) then
    return
  endif

  !order = !!ce.order
  if (!order.lt(2)) then
    !list = !!ce.owner.members.from(1,5)
  else
    !list = !!ce.owner.members.from(!order - 2,5)
  endif

  !this.dimension.clearDimension()
  !this.dimension.createDetailDimension(!list)

endmethod
------------------------------------------------------------------------
--
-- Method:      moveToComp
--
-- Description: called as part of the filmStrip to navigate along the branch
--
--
------------------------------------------------------------------------
define method .moveToComp(!to is STRING)

  if (!to.eq('START')) then
    branch
    first member
  elseif (!to.eq('END')) then
    branch
    last member
  elseif (!to.eq('NEXT')) then
    next
    handle any
    endhandle
  elseif (!to.eq('PREV')) then
    previous
    handle any
    endhandle
  else
    $!to
    handle any
    endhandle
  endif
  !this.modifyElement = !!ce
  !this.component = !!ce
  -- Goto starting component

  -- Determine arrive bore for new component
  !bores            = !this.adjacentBores(!this.component, !this.flow)
  !this.arriveBore  = !bores[1]
  !arrivePosition   = !this.componentPosition(!this.component, !this.flow)
  !arriveDirection  = !this.componentDirection(!this.component, !this.flow)
  !this.leaveBore   = !bores[2]

  -- Define the tag point
  !this.tagPoint    = object POINTVECTOR(!arrivePosition, !arriveDirection)
  handle (2,785)
    -- error where an unset item is passed to track
    -- often caused by undo deleting the current element
    return
  endhandle

  -- OK so at right member, reset filmStrip
  !this.filmStrip()

endmethod

------------------------------------------------------------------------
--
-- Method:      changeComponentType
--
-- Description: Change Component Type
-- called from selecting the change component type option
-- for example from ELBOW to a BEND
--
------------------------------------------------------------------------
define method .changeComponentType()

  -- Initialise Variables
  !componentType              = !this.editComponentList.selection('RTEXT')
  -- If component Type is empty, we must be setting up the form, so no action
  if(!componentType.empty()) then
    return
  endif

  -- Get new component object
  !changeTypeObject           = !this.editComponentData.componentObject(!componentType)

  -- Copy the relevant information from the active component object into the new one
  !changeTypeObject.copy(!this.activeComponent[1])

  -- Copy change component to new type
  !this.activeComponent.clear()
  !this.activeComponent[1]    = !changeTypeObject


  --  Select Component Type
  !this.selectComponentType()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      updateComponent
--
-- Description: Update components, modified by external means
--
--
------------------------------------------------------------------------
define method .updateComponent()

  -- Get active components information
  !this.activeComponent[1].component(!this.editComponent)
  handle ANY
  endhandle

  -- Set current position
  !this.editComponentPosition = !this.editComponent.position

  -- Tag component
  --!this.tag()

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      insulationSpecification
--
-- Description: Set insulation spec of component
--
------------------------------------------------------------------------
define method .insulationSpecification()

  -- Set insulation
  !insulation   = !this.insulation.selection()

  if(!insulation.empty().not()) then
    !this.editComponent.iSpec = !insulation.dbref()
  else
    !reference  = !!ce
    !!ce        = !this.editComponent
    iSpec nulref
    !!ce        = !this.editComponent
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      tracingSpecification
--
-- Description: Set insulation spec of component
--
------------------------------------------------------------------------
define method .tracingSpecification()

  -- Set insulation
  !trace   = !this.tracing.selection()

  if(!trace.empty().not()) then
    !this.editComponent.tSpec = !trace.dbref()
  else
    !reference  = !!ce
    !!ce        = !this.editComponent
    tSpec nulref
    !!ce        = !this.editComponent
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      componentSpecification
--
-- Description: Setup using the current components specification
--
--
------------------------------------------------------------------------
define method .componentSpecification()
  !this.setSpecifications(!this.componentSpecification(!this.editComponent), !this.editComponent.iSpec, !this.editComponent.tSpec)
endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:      componentSpecification
--
-- Description: Get component specification
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Component
-- Return:
--   [Data Type] [Description]
--    DBREF       Component specification
--
------------------------------------------------------------------------
define method .componentSpecification(!component is DBREF) is DBREF

  !spec = !component.spow
  -- Handle unset specRef of components and limbospec
  if (!component.spref.unset()or !spec.name.match('LIMBO').gt(0)) then
      !spec = !component.owner.pSpec
  else
    !spec = !component.spow
  endif
  -- Return spec
  return !spec

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      setSpecification
--
-- Description: Setup using components specification This is called when we navigate to
-- a component in reselect mode
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      DBREF       Piping specification
--    2   R      DBREF       Insulation specification
--    3   R      DBREF       Tracing specification
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .setSpecifications(!piping is DBREF, !insulation is DBREF, !tracing is DBREF)

  -- Insulation Specification
  if(!insulation.unset()) then
    !this.insulation.select('RTEXT','')
  else
    !this.insulation.select('RTEXT', !insulation.refNo.string())
  endif
  !this.insulationSpecification()

  -- Tracing Specification  !tracingSpec    = !element.tSpec
  if(!tracing.unset()) then
    !this.tracing.select('RTEXT','')
  else
    !this.tracing.select('RTEXT', !tracing.refNo.string())
  endif
  !this.tracingSpecification()

  -- Select Current Piping Specification
  !this.editComponentData.selectSpecification(!piping)

  --  Select Component Type
  !this.selectcomponentType()

  -- Select current components options
  !this.selectOptions()

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectcomponentType
--
-- Description: Select Component Type
--
--
------------------------------------------------------------------------
define method .selectcomponentType()

  -- Define Component Table
  -- Setup change types (the first type should be the same as the component)
  !this.editComponentData.loadChangeTypes(!this.activeComponent[1].type())

  -- Maintain Component Data Frame
  !this.editComponentData.initialiseFrame(!this.activeComponent[1].type())

  -- Load Available Components
  !this.editAvailableComponents = !this.choices(!this.arriveBore,'edit')

  -- Display available stypes
  !this.displayStypes()

  -- Display available bores
  !this.displayBores()

  -- Display available choices
  !this.displayChoices('edit')

  -- Select Current Component
  -- commented out to make reselection work with out of spec
  --!this.selectCurrentComponent()

  --Display the available leave tubes if there is more than 1
  !this.displayTubes(=0,'edit')

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectOptions
--
-- Description: Select Stype and Bore options for selected component
--
--
------------------------------------------------------------------------
define method .selectOptions()

  -- Initialise Variables
  !componentType  = !this.activeComponent[1].type()
  !component      = !this.activeComponent[1].component()

  -- Select sub-type
  !sType          = !component.sType
  handle ANY
  elsehandle NONE
    !this.editSTypes.select('RTEXT', !sType)
    handle ANY
      !this.editSTypes.val = 1
      handle ANY
      endhandle
    endhandle
  endhandle

  -- Select Bore
  -- Determine the Bore information
  !boreGadget     = !this.editComponentData.boreGadget(!componentType)
  if(!boreGadget.set()) then

    -- Get bore indices
    !boreIndices  = !this.activeComponent[1].arriveLeave()

    -- Get Controlling bore for component
    !boreString   = !component.ppBore[!boreIndices[3]].string(!!boreFmt)
    handle any
      !boreString = object STRING()
    endhandle
    !boreGadget.select('RTEXT', !boreString)
    handle ANY
      !boreGadget.val = 1
      handle ANY
      endhandle
    endhandle

  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      filterChoices
--
-- Description: Filter available components by stype and current settings
-- this is now only called in edit mode
--
------------------------------------------------------------------------
define method .filterChoices()

  !this.editAvailableComponents   = !this.editFilterChoices(!this.activeComponent[1])
  -- Display available choices in the list
  !this.displayChoices('edit')

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      editFilterChoices
--
-- Description: Filter available components by stype and current settings
--

-- called when the user selects the bore filter in reselect mode
--  returns  ARRAY   =    List of available components
--
------------------------------------------------------------------------
define method .editFilterChoices(!componentObject is ANY) is ARRAY

  !componentType  = !componentObject.type()

  -- Get question and answers
  !qa             = !this.questionsAndAnswers(!componentObject)
  -- Handle no question and answers
  if(!qa.unset()) then
    return ARRAY()
  endif

  !questions      = !qa[1]
  !answers        = !qa[2]
  -- the returned questions for a tee are pbor1, and current bore <PBOR1> - 80mm

  -- get the current stype selection from the option gadget
  !sType = !this.editSTypes.selection()
  if(!sType.empty().not()) then
    !questions.append('STYP')
    !answers.append(!sType)
  endif
  -- appends the current stype to the answers

  !arriveLeave = !this.activeComponent[1].arriveLeave()
  -- Returns the arrive leave points as an array [1],[2],[3]
  -- If check bore is set
  if(!arriveLeave[3] gt 0) then
    -- Get Bore Gadget this returns the number of available bore sizes with the current bore layout
    !boreGadget   = !this.editComponentData.boreGadget(!componentType)
    if(!boreGadget.set()) then
      !selection  = !boreGadget.selection()
      if(!selection.empty().not()) then
        !bore     = object BORE(!selection)
        !questions.append('PBOR' & !arriveLeave[3])
        !answers.append(!bore)
      endif
    endif
  endif

  return  !this.editComponentData.pipingSpecs.getAvailableComponents(!this.editComponentData.pipingSpecs.activeSpecification, !componentType, !questions, !answers)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      questionsAndAnswers
--
-- Description: Returns a 2D array of questions and answers for the passed
--              component object type. The arrive bore is always assumed to
--              be that of the original component.
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      ANY         Component object to derive choices from
-- Return:
--   [Data Type] [Description]
--    ARRAY       2D array [1] Questions [2] Answers
--
------------------------------------------------------------------------
define method .questionsAndAnswers(!componentObject is ANY) is ARRAY

  -- Initialise Variables
  !arriveLeave    = !componentObject.arriveLeave()
  !component      = !componentObject.component()
  !componentType  = !componentObject.type()
  !questions      = ARRAY()
  !answers        = ARRAY()
  !results        = ARRAY()

  -- If there is no check bore given, then we'll always assume PBORE-1
  !boreIndices    = !componentObject.arriveLeave()


  if(!boreIndices[3] lt 0) then
    !questions.append('PBOR1')
  else
    !questions.append('PBOR' & !arriveLeave[1])
  endif

  -- Primary Question is the Bore
  !answers.append(!this.arriveBore)
  !results[1]     = !questions
  !results[2]     = !answers

  -- Return Questions and Answers

  return !results

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:     setBendRadius
--
-- Description: set the bend radius testing against machines and spec
--
--
------------------------------------------------------------------------
define method .setBendRadius(!oldSpecRef is DBREF )

  !this.bendAnswer = TRUE
  --always look for a radius from the spec.
  -- Radius setting can be RADI or RAD
  !oldRadius = !this.editComponent.radius
  !this.bendSaved = !oldRadius
  var !choice choice
  !rad = !choice.after('RAD').after(' ').before(' ').real()
  if (!rad.set()) then
    -- let the spec take care of it
    !this.editComponent.radius = !rad
    return
  endif

  if (!this.editComponent.compType.eq('FIX')) then
    -- if its a zero radius bend compType should be set to FIX or not set at all
    !this.editComponent.radius = 0
    -- we can't go round resetting bends which do not use compType so leave all other bends alone
  endif
  -- test to see if we can get a radius from a bending machine
  !rad = !!ce.dfbrad
  handle ANY
    if (!this.editComponent.compType.eq('VAR')) then
      -- its a variable radius bend
      -- has it got a bending machine set?
      -- if it has go and get the radius
      !!alert.error('Unable to Set Bend Radius from Bending Machine - Please Select a Radius')
      !this.editComponent.radius =   !this.editBendRadius.val
      handle ANY
        !this.editComponent.radius = 0
      endhandle
      return
    endif
  elsehandle NONE
    -- DFBRAD is set so we need to set the component radius
    if (!oldRadius.neq(!rad)) then
      !answer = !!alert.question('Bend Radius is ' & !oldRadius.string(!!distanceFmt) & ' - Do You want to change the Bend Radius to ' & !rad.string(!!distanceFmt) & ' - Machine Defined')
      if (!answer.eq('YES')) then
        !this.editComponent.radius = !rad
      elseif (!answer.eq('CANCEL')) then
        undodb
        !this.bendAnswer = FALSE
        return
      else $* the answer is no
        !this.bendAnswer = FALSE
        return
      endif
      !this.track()
      return
    else
      !this.editComponent.radius = !rad
    endif
    return
  endhandle

  -- we should set the radius to the radius gadget
  !this.editComponent.radius =   !this.editBendRadius.val
  handle ANY
    !this.editComponent.radius = 0
  endhandle

endmethod

------------------------------------------------------------------------
--
-- Method:      displayStypes
--
-- Description: Display the currently available stypes
--
--
------------------------------------------------------------------------
define method .displayStypes()

  -- Initialise Variables
  !componentType  = !this.activeComponent[1].type()
  !unusedComponent      = !this.activeComponent[1].component()

  -- Get bore indices
  !boreIndices    = !this.activeComponent[1].arriveLeave()
  if(!boreIndices[3] lt 0) then
    !pBore        = 1
  else
    !pBore        = !boreIndices[3]
  endif

  --!arriveBore     = !component.ppBore[!pBore]
  !arriveBore     = !this.arriveBore

  -- Get Available sTypes for current active Component

  !sTypes = !this.editComponentData.pipingSpecs.subTypes(!componentType, !pBore, !arriveBore)

  -- Handle No Stype
  if(!sTypes.unset()) then
    if(!this.editSTypes.visible) then
      !this.editSTypes.visible = FALSE
    endif
  else
    if(!this.editSTypes.visible.not()) then
      !this.editSTypes.visible = true
    endif

    -- Define Stype display and replacement
    !display          = ARRAY()
    !replace          = ARRAY()
    if(!sTypes.size() gt 1) then
      !display[1]       = 'unset'
      !replace[1]       = ''
    endif
    --!display.appendArray(!sTypes)
    --!replace.appendArray(!sTypes)
    
    -- TECHNIP CUSTOM Code
    --Filter the Stypes for Valves as per the Fluid Reference
    if (!componentType inset ('VALV', 'FLAN', 'GASK')) then
      !validsTypes        = !this.loadValveXmlData(!componentType) 
      !display.appendArray(!validsTypes)
      !replace.appendArray(!validsTypes)
    else
      !display.appendArray(!sTypes)
      !replace.appendArray(!sTypes)
     endif

    -- Set gadget
    !this.editSTypes.dText  = !display
    !this.editSTypes.rText  = !replace
    !this.editSTypes.active = !sTypes.size().gt(1)

  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      displayBores
--
-- Description: Display the currently available bores
--
--
------------------------------------------------------------------------
define method .displayBores()

  -- Initialise Variables
  !componentType  = !this.activeComponent[1].type()
  !unusedComponent      = !this.activeComponent[1].component()

  -- Determine the Bore information
  !boreGadget     = !this.editComponentData.boreGadget(!componentType)
  if(!boreGadget.set()) then

    -- Get bore indices
    !boreIndices    = !this.activeComponent[1].arriveLeave()

    -- Get Bore information
    !questions[1] = 'PBOR' & !boreIndices[1]
    !answers[1]   = !this.arriveBore

    -- Get Bores
    !question         = 'PBOR' & !boreIndices[3]

    !bores = !this.editComponentData.pipingSpecs.componentData(!componentType, !question, !questions, !answers)
    if(!bores.empty()) then
      !boreGadget.active  = FALSE
      return
    endif

    !bores.sort()
    do !i indices !bores
      !boreString[!i] = !bores[!i].string(!!boreFmt)
    enddo

    if(!boreGadget.active.not()) then
      !boreGadget.active  = true
    endif


    -- Define Bore display and replacement
    !display          = ARRAY()
    !replace          = ARRAY()
    if(!boreString.size() gt 1) then
      !display[1]     = 'unset'
      !replace[1]     = ''
    endif
    !display.appendArray(!boreString)
    !replace.appendArray(!boreString)

    -- Set gadget
    !boreGadget.dText = !display
    !boreGadget.rText = !replace

  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      reconnect
--
-- Description: Re-establish connections of adjacent components
--
-- Method Type: Procedure
--   [#] [R/RW] [Data Type] [Description]
--    1   R      BOOLEAN     Mark database
-- Return:
--   [Data Type] [Description]
--
------------------------------------------------------------------------
define method .reconnect(!mark is BOOLEAN)

  -- Initialise Variables
  !component      = !this.editComponent

  -- Perform reconnection
  !unusedReconnected    = !this.connected.reconnect(!mark)

  -- Display any errors
  !this.errors()

  -- Set reconnection button
  !this.reconnect.active = !this.errorsFrame.selected

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      errors
--
-- Description: Check for errors
--
--
------------------------------------------------------------------------
define method .errors()

  -- Initialise Variables
  !this.errorList.clear()

  -- Check for errors
  !this.connected.checkErrors()

  -- get errors
  !errors     = !this.connected.errors()

  -- Populate error list
  if(!errors.set()) then
    !records  = ARRAY()
    do !i indices !errors
      !records.append('Component : ' & !errors[!i][1].flnn)
      do !j indices !errors[!i][2]
        !records.append('    ' & !errors[!i][2][!j])
      enddo
      !records.append('')
    enddo
    -- Display errors
    !this.errorList.dText     = !records
    !this.setTask('ERRORS')
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      applyLstu
--
-- Description: Apply the changes to selected Lstu
--
--
------------------------------------------------------------------------
define method .applyLstu()

  !this.editComponent.lstube = !this.editLstu.selection('Rtext').dbref()
  -- set the flange allowance
  if (!this.editComponent.type.eq('FLAN')) then
    !this.setFlangeAllowance(!this.editComponent)
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      selectCurrentComponent
--
-- Description: Select Current Component Information
--
--
------------------------------------------------------------------------
define method .selectCurrentComponent()

  -- Initialise Variables
  !componentType  = !this.activeComponent[1].type()
  !component      = !this.activeComponent[1].component()

  -- Select the current specRef
  !this.editChoices.select('RTEXT', !this.specReference.string())
  handle ANY
  endhandle

  -- Determine the radius
  !radiusGadgets  = !this.editComponentData.radiusGadgets(!componentType)
  if(!radiusGadgets.set()) then
    !radius               = !this.activeComponent[1].radius
    if(!radius.unset()) then
      !radius = !this.activeComponent[1].component().owner.phBore.real()
    endif
    !radiusGadgets[2].val = !radius
    !ratio                = !radius / !component.aod
    -- Check if option gadget has valid setting
    !radiusGadgets[1].select('RTEXT', !ratio.string())
    handle ANY
      !radiusGadgets[1].select('RTEXT','')
      !radiusGadgets[2].active  = true
    elsehandle NONE
      !radiusGadgets[2].active  = FALSE
    endhandle
  endif

  -- Determine the angle
  !angleGadgets  = !this.editComponentData.angleGadgets(!componentType)
  if(!angleGadgets.set()) then
    !this.editMinAngle.active = FALSE
    !this.editMaxAngle.active = FALSE
    !componentFrameIndex    = !this.editComponentData.frameIndex(!componentType)
    !this.currentFrameIndex = !componentFrameIndex
    -- Show Component Data Frame
    if(!componentFrameIndex gt 0) then
      !dataFrame            = !this.editComponentData.frameRegister[!componentFrameIndex]
      if (!this.activeComponent[1].isRangeDefined) then
        !dataFrame.visible = true
        !this.activeComponent[1].component(!this.editComponent)
        !angleGadgets[1].val = !this.activeComponent[1].angle
        !angleGadgets[2].val = !this.activeComponent[1].minAngle
        !angleGadgets[3].val = !this.activeComponent[1].maxAngle
        !angleGadgets[1].active = (!this.activeComponent[1].maxAngle gt !this.activeComponent[1].minAngle)
      else
        !dataFrame.visible = FALSE
      endif
    endif
  endif

  -- Tag Position
  if (!this.currentTask.eq('SELECTCOMPONENT')) then
    !this.tag()
  elseif (!this.currentTask.eq('RESELECT')) then
    !this.tagReselect()
  endif

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      selectBore
--
-- Description: Select a check bore for the component type
--
--
------------------------------------------------------------------------
define method .editSelectBore(!gadget is GADGET, !dummySelect is STRING)

  -- Initialise Variables
  !this.checkBore   = object BORE(!gadget.selection())
  -- Filter components
  !this.filterComponents('edit')
  -- check for reduced bores
  --!this.checkComponents('edit')

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      changeEditAngle
--
-- Description: Change angle value
--
--
------------------------------------------------------------------------
define method .changeEditAngle()

  !type = !!ce.type

  !gadgets  = !this.editComponentData.angleGadgets(!type)

  if(!gadgets.set()) then
    !value = !gadgets[1].val
    !minValue = !gadgets[2].val
    !maxValue = !gadgets[3].val
  else
    !!alert.error('Please select a component before setting the angle')
    return
  endif

  !index  = !this.editComponentData.frameIndex(!type)

  --!this.activeComponent[1].angle =!gadgets[1].val
  !this.activeComponent[1].angle =!value
  !this.activeComponent[1].modify()
  handle ANY
    !!alert.warning('Angle ' + string(!value, !!angleFmt) + ' is outside the specified range (expected range ' + string(!minValue, !!angleFmt) + ' to ' +  string(!maxValue, !!angleFmt))
  endhandle

  -- Mark end of change
  !this.undo.endUndoable()

  -- Set last modified time
  var !lastModified LASTM of $!<this.component>
  !this.lastModified  = object DATETIME(!lastModified)

  -- Update Tag
  !this.tag()

endmethod
------------------------------------------------------------------------
--
-- Method:      .setInsulationAndTracing
--
-- Description: sets the insulation and tracing spec to those on the
-- form option gadgets
--
--
------------------------------------------------------------------------
define method .setInsulationAndTracing(!component is DBREF)

  !insul = !this.insulation.selection().dbref()
  handle NONE
    !component.iSpec = !insul
  elsehandle ANY
    !component.iSpec = DBREF()
  endhandle
  !trace = !this.tracing.selection().dbref()
  handle NONE
    !component.tSpec = !trace
  elsehandle ANY
    !component.tSpec = DBREF()
  endhandle

endmethod
------------------------------------------------------------------------
--
-- Method:      .changeSpecConfirm
--
-- Description: This is called when the insulation or tracing is selected
-- Currently nothing happens
------------------------------------------------------------------------
define method .changeSpecConfirm(!type is STRING)

  if (!this.currentTask.eq('SELECTCOMPONENT')) then
    --We are changing the spec of an existing branch so that when we create the next
    -- component we will have the spec set.
  elseif (!this.currentTask.eq('RESELECT')) then
    -- we are in modify mode so we can change the local component ispe or tspe
    if (!type.eq('TRACE')) then
      !selected = !this.tracing.selection().dbref()
      if (!selected.unset()) then
        !selectedText = 'None'
      else
        !selectedText = !selected.namn
      endif
      !current  = !!ce.tSpec
      if (!current.unset()) then
        !spText = 'None'
      else
        !spText = !current.namn
      endif
      if (!!alert.confirm('Ok to change Tracing spec from $!spText to $!selectedText ').eq('YES')) then
        tspec $!selected
        handle ANY
          tspec =0
        endhandle
      else
        !this.tracing.select('dtext',!spText)
      endif
    else
      !selected = !this.insulation.selection().dbref()
      if (!selected.unset()) then
        !selectedText = 'None'
      else
        !selectedText = !selected.namn
      endif
      !current  = !!ce.iSpec
      if (!current.unset()) then
        !spText = 'None'
      else
        !spText = !current.namn
      endif
      if (!!alert.confirm('Ok to change Insulation spec from $!spText to $!selectedText ').eq('YES')) then
        ispec $!selected
        handle ANY
          ispec =0
        endhandle
      else
        !this.insulation.select('dtext',!spText)
      endif
    endif
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      tagBranchHeadTail
--
-- Description: adds or removes tags from the current branch head and tail
--
--
------------------------------------------------------------------------
define method .tagBranchHeadTail(!branch is DBREF, !action is BOOLEAN)
  AID CLEAR ALL $!<this.branchTagID>
  if (!action.not()) then
    -- its a clear (false)
    return
  endif

  -- Mark head and tail of branch

  if(!branch.lHead) then
    !tagPosition = !branch.hPosition
    AID TEXT NUMBER $!<this.branchTagID> 'Head' AT $!<tagPosition>
  endif
  if(!branch.lTail) then
    !tagPosition = !branch.tPosition
    AID TEXT NUMBER $!<this.branchTagID> 'Tail' AT $!<tagPosition>
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      setBranchGadgets
--
-- Description: deactivates the top gadgets if we are in reselect mode
-- on a different pipe
--
--
------------------------------------------------------------------------
define method .setBranchGadgets(!action is BOOLEAN )

  !this.branchTag  .active = !action
  !this.branchName .active = !action
  !this.specTag    .active = !action
  !this.currentSpec.active = !action
  !this.boreTag    .active = !action
  !this.currentBore.active = !action

  -- these are the two tab frames for component creation
  !this.componentFrame.active = !action
  !this.additionalComponents.active = !action

endmethod
------------------------------------------------------------------------
--
-- Method:      undoAdd
--
-- Description: adds an undo to the stack with the passed message
-- saves a line of code each time
--
--
------------------------------------------------------------------------
define method .undoAdd(!message is STRING)

  !this.undo.description(!message)
  !this.undo.add()

endmethod
------------------------------------------------------------------------
--
-- Method:      elementIsComponentOrBranch
--
-- Description: tests to see if the passed element is a piping component
-- returns true or FALSE
--
--
------------------------------------------------------------------------
define method .elementIsComponentOrBranch(!element is DBREF ) is BOOLEAN

  if (!element.ahlist.findFirst('HVAC').set()) then
    return FALSE
    -- Check we have a piping component
  elseif (!element.type.eq('BRAN')) then
    return TRUE
  else
    return !this.elementIsComponent(!element)
  endif

  return FALSE

endmethod

------------------------------------------------------------------------
--
-- Method:      elementIsComponent
--
-- Description: tests to see if the passed element is a piping component
-- returns true or FALSE
--
------------------------------------------------------------------------
define method .elementIsComponent(!element is DBREF ) is BOOLEAN

  if (!element.badRef()) then
    !this.component = object DBREF()
    return FALSE
  endif

  if (!element.attlist.findFirst('SPREF').set()) then
    if (!element.spref.unset()) then
      return TRUE
    endif
  endif
  -- rule out hvac
  if (!element.ahlist.findFirst('HVAC').set()) then
    return FALSE
  elseif(!element.owner.badRef().not()) then
    -- Element is not a piping component
    if (!element.owner.type.eq('BRAN')) then
      return TRUE
    else
      return FALSE
    endif
  endif

  return FALSE

endmethod
------------------------------------------------------------------------
--
-- Method:      .testForComponentErrors
--
-- Description: tests to see if the passed element has connection errors
-- and populates the error tab
--
------------------------------------------------------------------------
define method .testForComponentErrors(!element is DBREF )

  -- Get errors for current component from the reconnection object and populate the error list
  !this.errorList.clear()
  !errors = !this.connected.checkComponent(!element)
  if(!errors.set()) then
    !records  = ARRAY()
    !records.append('Component : ' & !element.flnn)
    do !i indices !errors
      !records.append('    ' & !errors[!i])
    enddo
    !records.append('')
    !this.errorList.dText = !records
  endif

endmethod
------------------------------------------------------------------------
--
-- Method:      .rotateByBoltSpacing
--
-- Description: turns off or turns on rotations that are constrained to bolt hole rotation angles
--
------------------------------------------------------------------------
define method .rotateByBoltSpacing()
  if (!this.boltHoleRotationsMode.eq('FREE')) then
    !tooltip = 'Component rotations are constrained to bolt hole spacing angles'
    !this.boltHoleRotationsMode = 'CONSTRAINED'
    !this.rotateByBoltSpacing.addPixMap('AvevaSharedIcons>ID_BOLTING_ON>32')
  else
    !tooltip = 'Component rotations are not constrained to bolt hole spacing angles'
    !this.boltHoleRotationsMode = 'FREE'
    !this.rotateByBoltSpacing.addPixMap('AvevaSharedIcons>ID_BOLTING_OFF>32')
  endif
  !this.rotateByBoltSpacing.setToolTip(!tooltip)
  !this.directionControlActions.setupBoltHoleRotations(!this.boltHoleRotationsMode)

  --reset control graphics and aids to reset to the zero angle
  !this.directionControlActions.resetAidAxes(TRUE)

endmethod
------------------------------------------------------------------------
--
-- Method:      .setIconList()
--
-- Description: used to build the initial icon list array
--
------------------------------------------------------------------------
define method .setIconList()

  !icons = ARRAY()
  !icons.appendArray(!this.combineIconTexts(|FLAN1|,|AvevaSharedIcons>ID_FLAN>32|))
  !icons.appendArray(!this.combineIconTexts(|FLAN2|,|AvevaSharedIcons>ID_REVERSE_FLANGE>32|))
  !icons.appendArray(!this.combineIconTexts(|ELBO|,|AvevaSharedIcons>ID_ELBO>32|))
  !icons.appendArray(!this.combineIconTexts(|TEE| ,|AvevaSharedIcons>ID_TEE>32|))
  !icons.appendArray(!this.combineIconTexts(|REDU1|,|AvevaSharedIcons>ID_REDU>32|))
  !icons.appendArray(!this.combineIconTexts(|REDU2|,|AvevaSharedIcons>ID_REVERSE_REDUCER>32|))
  !icons.appendArray(!this.combineIconTexts(|VALV|,|AvevaSharedIcons>ID_VALV>32|))
  !icons.appendArray(!this.combineIconTexts(|ATTA|,|AvevaSharedIcons>ID_ATTA>32|))
  !icons.appendArray(!this.combineIconTexts(|PCOM|,|AvevaSharedIcons>ID_PCOM>32|))
  !icons.appendArray(!this.combineIconTexts(|FBLI|,|AvevaSharedIcons>ID_FBLI>32|))
  !icons.appendArray(!this.combineIconTexts(|BEND|,|AvevaSharedIcons>ID_BEND>32|))
  !icons.appendArray(!this.combineIconTexts(|OLET|,|AvevaSharedIcons>ID_OLET>32|))
  !icons.appendArray(!this.combineIconTexts(|PTAP|,|AvevaSharedIcons>ID_PTAP>32|))
  !icons.appendArray(!this.combineIconTexts(|COUP|,|AvevaSharedIcons>ID_COUP>32|))
  !icons.appendArray(!this.combineIconTexts(|INST|,|AvevaSharedIcons>ID_INST>32|))
  !icons.appendArray(!this.combineIconTexts(|CAP|,|AvevaSharedIcons>ID_CAP>32|))
  !icons.appendArray(!this.combineIconTexts(|GASK|,|AvevaSharedIcons>ID_GASK>32|))
  !icons.appendArray(!this.combineIconTexts(|FILT|,|AvevaSharedIcons>ID_FILT>32|))
  !icons.appendArray(!this.combineIconTexts(|WELD|,|AvevaSharedIcons>ID_WELD>32|))
  !icons.appendArray(!this.combineIconTexts(|CROS|,|AvevaSharedIcons>ID_CROS>32|))
  !icons.appendArray(!this.combineIconTexts(|UNIO|,|AvevaSharedIcons>ID_UNIO>32|))
  !icons.appendArray(!this.combineIconTexts(|VTWA|,|AvevaSharedIcons>ID_VTWA>32|))
  !icons.appendArray(!this.combineIconTexts(|CLOS|,|AvevaSharedIcons>ID_CLOS>32|))
  !icons.appendArray(!this.combineIconTexts(|TRAP|,|AvevaSharedIcons>ID_TRAP>32|))
  !icons.appendArray(!this.combineIconTexts(|LJSE|,|AvevaSharedIcons>ID_LJSE>32|))
  !icons.appendArray(!this.combineIconTexts(|FTUB|,|AvevaSharedIcons>ID_FTUB>32|))
  !icons.appendArray(!this.combineIconTexts(|VFWA|,|AvevaSharedIcons>ID_VFWA>32|))
  !icons.appendArray(!this.combineIconTexts(|SHU|,|AvevaSharedIcons>ID_SHU>32|))
  !icons.appendArray(!this.combineIconTexts(|PLAT|,|AvevaSharedIcons>ID_PLAT>32|))
  !icons.appendArray(!this.combineIconTexts(|VENT|,|AvevaSharedIcons>ID_PIPE_VENT>32|))
  !icons.appendArray(!this.combineIconTexts(|BLANK|,|AvevaSharedIcons>ID_MATCHLINES>32|))
  !icons.appendArray(!this.combineIconTexts(|HEAD|,|AvevaSharedIcons>ID_HEAD>32|))
  !icons.appendArray(!this.combineIconTexts(|TAIL|,|AvevaSharedIcons>ID_TAIL>32|))
  !icons.appendArray(!this.combineIconTexts(|TAIL|,|AvevaSharedIcons>ID_BRAN>32|))

  !this.iconlist = !icons

endmethod
------------------------------------------------------------------------
--
-- Method:      .combineIconTexts
--
-- Description: used to build the iconlist array
--
------------------------------------------------------------------------
define method .combineIconTexts(!text1 is STRING, !text2 is STRING)is ARRAY

  !return[1] = !text1
  !return[2] = !text2
  return !return

endmethod
------------------------------------------------------------------------
--
-- Method:      .selectIcon
--
-- Description: This is used by the filmstrip mechanism to select the correct icon
--
------------------------------------------------------------------------
define method .selectIcon(!type is STRING) is STRING

  !index = !this.iconlist.findFirst(!type)
  if (!index.eq(0)) then
    !return = |"AvevaSharedIcons>ID_MATCHLINES>32"|
  else
    !return = !this.iconlist[!index + 1]
  endif
  return !return

endmethod
------------------------------------------------------------------------
--
-- Method:      .autoRoute()
--
-- Description: Calls Router and completes or routes the current branch
--
------------------------------------------------------------------------
define method .autoRoute()

  !this.undoAdd('Auto Route')
  -- method to use router to auto complete a branch

  -- Check if there are any point clouds present in the MDB and if so warn the user
  var !xgeomExists coll all XGEOM
  if (!xgeomExists.empty().not()) then
    if (!!alert.confirm('Autoroute has detected the existence of laser point clouds. This may cause performance to be slow and result in unexpected routes. Do you want to continue?').eq('NO')) then
      return
    endif
  endif

  if (!!ce.type.eq('PIPE')) then
    var !brans coll all bran for ce
  else
    branch
    handle(2,111)
      !!alert.error('You must be at Branch or Pipe Level to run this command.')
      return
    endhandle
    !brans[1] = !!ce.string()
  endif

  !this.setRlocFixed(!brans,0)

  -- setup the bend / elbow configuration
  !dirChange = !this.getDirectionChangeType()

  do !bran values !brans
    $!bran
    router
      config direction $!dirChange
      var !clash config clash
      Config clash off
      route ce
      handle ANY
      endhandle
      -- reset the config
      Config $!clash
    exit
  enddo

  !this.setRlocFixed(!brans,-1)

  -- Mark end of change
  !this.undo.endUndoable()

endmethod

------------------------------------------------------------------------
--
-- Method:      .setRlocFixed
--
-- Description: goes through the list of components and sets the rloc
-- for router.
-- rlock 0 item is positioned Fixed
-- rlock 1 item is positionable but not deletable
-- rlock 2 item is deletable
-- rlock -1 item has been positioned by the user this seems to work like rlock 0
--
--
------------------------------------------------------------------------
define method .setRlocFixed(!branches is ARRAY,!value is REAL)

  do !bran values !branches
    !branch= !bran.dbref()
    handle any
    endhandle
    do !b values !branch.members
      !b.rloc = !value
      handle any
      endhandle
    enddo
  enddo

endmethod

------------------------------------------------------------------------
--
-- Method:      pickPosition
--
-- Description: uses edg to pick a through position
--
------------------------------------------------------------------------
define method .pickPosition()

  if (!!ce.owner.type.neq('BRAN')) then
    !!alert.error('This option can only be used on a valid piping component - Please select a component')
    return
  endif

  !!edgSourceComponent = !!ce
  -- define packet
  !prompt                = 'Pick A Position'
  !packet                = object EDGPACKET()
  !packet.initialisation = '!!componentEditor.pickedPosData  = object EDGPOSITIONDATA()'
  !packet.definePosition(!prompt)
  !packet.description    = 'Pick Position'
  !packet.remove         = TRUE
  !packet.action = '!!componentEditor.pickPosition(!this.return[1] ,!!edgSourceComponent ) '

  -- Add event to system
  !!edgCntrl.add(!packet)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      pickPosition
--
-- Description: this method defines the pick position
--
------------------------------------------------------------------------
define method .pickPosition(!pos is EDGPOSITIONDATA, !comp is DBREF  )

  !!ce = !!edgSourceComponent
  !this.pickReturn = 'Cursor'

  !this.pickedPosData = !pos
  if (!pos.item.badRef().or(!pos.type.eq('TUBING'))) then
    if (!pos.type.eq('TUBING')) then
      !tubing         = object EDGTUBING()
      !throughPosition = !tubing.exact(!pos.item, !pos.pointVector)
      through $!throughPosition
      return
    else
      -- we could be using cursor or screen pick so we only have a position
      !throughPosition = !pos.position
      through $!throughPosition
      !this.pickReturn = 'null'
      return
      -- This piece of code is currently self contained and deals with through Cursor only
    endif
  elseif (!pos.item.owner.type.eq('BRAN').and(!pos.pPoint.eq(0))) then
    -- its a component
    !throughPosition = !pos.item.position.wrt(/* )
  elseif (!pos.item.type inset('PNOD','SNOD')) then
    !!alert.error('Unable to derive a Position from the selected element ($!pos.item.type) - Please reselect')
    return
  endif
  if (!pos.type.eq('PPOINT')) then
    !throughPosition = !pos.item.ppos[!pos.pPoint].wrt(/* )
  elseif (!pos.item.ostype.eq('BRAN').or(!pos.item.type.eq('BRAN')).and(!pos.type.eq('TUBING'))) then
    -- Initialise Variables
    !tubing         = object EDGTUBING()
    !throughPosition  = !tubing.exact(!pos.item, !pos.pointVector)
    --if pick is laser data, and point position, not xgeom origin position, then try to fit cylinder to data and
    --use cylinder centre position if fit successful
  elseif (!pos.type.eq('ELEMENT') and !pos.item.type.eq('XGEOM') and !pos.originalType.unset()) then
    !pipeCentre              = !this.laserPipeCentre(!pos.position)
    handle ANY
      !!alert.warning('Unable to obtain centre-line from picked item')
      !throughPosition = !pos.position
    elsehandle none
      -- using fitted cylinder centre position
      --*** provide graphical aid and alert confirm dialogue?
      !throughPosition            = !pipeCentre[1]
    endhandle
  else
    -- pipe intersection is used to get a graphics intersection anywhere
    !throughPosition = !pos.position.wrt(/* )
  endif

  -- call the method to show the slope plane form instead of above
  !this.positionThrough(!comp, !throughPosition)

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method: .positionThrough(!element is DBREF, !throughPosition is POSITION)
--
-- Description: this method is called to position an element through a passed
-- position. If the current element is sloping the slope form is shown.
-- otherwise it executes a positioning command.
--
------------------------------------------------------------------------
define method .positionThrough(!element is DBREF, !throughPosition is POSITION)

  -- go and get the plane directions based on the leave
  -- this is ok for conventional directions but we need to improve it to deal with leave in up or down
  -------------------------------------------------------!planeDir = !this.planeDirections(!element)
  -- The results of this are ignored and the form works out the plane

  !directions = !this.getLeaveDirection(!element)

  !angle = !directions[1].angle(!directions[2])

  -- we need a limiting factor to stop it showing the form if its not needed

  if (!directions[1].string().length().lt(10).and(!angle inset(0,90,180))) then

    -- don't show the form
    -- is it a group
    !selection = object SELECTION()
    !selection.getCurrent()
    !list = !selection.getSelection()

    if (!list.size().gt(1)) then
      -- is a selection
      !select = TRUE
      -- remove branches
      do !component index !list
        if (!list[!component].type.eq('BRAN')) then
          -- we cannot drag selections containing branches
          !select = FALSE
          break
        endif
      enddo
    else
      !select = FALSE
    endif

    !this.undoAdd('through Cursor')

    var !mode mode

    if (!select) then
      if (!mode.eq('Forwards')) then
        drag move along pa through $!throughPosition
      else
        drag move along pl through $!throughPosition
      endif
    else
      through $!throughPosition
    endif

    !this.undo.endUndoable()

    if (!element.spref.set()) then
      -- reset the direction control axis
      !this.directionControlActions.resetAidAxes(FALSE)
    endif
  else
    -- we need to show the form
    -- calculate the through planes
    --if !planeDir[1].set() then
    if (undefined  (!!componentThroughPlane)) then
      pml load form !!componentThroughPlane
    endif
    -- pass the element to be positioned
    !!componentThroughPlane.component = !element
    -- pass the required through position
    !!componentThroughPlane.throughPosition = !throughPosition
    if (!!componentThroughPlane.shown()) then
      !!componentThroughPlane.setup('')
    else
      !!componentThroughPlane.show('AT', 0.65, 0.4)
    endif
  endif

endmethod

-- End of method definition
------------------------------------------------------------------------
--
-- Method:      getLeaveDirection
--
-- Description: this method finds the constrained centreline from the pl
-- of the previous component
--
------------------------------------------------------------------------
define method .getLeaveDirection(!source is DBREF ) is ARRAY

  !startDirection = object DIRECTION()
  -- we should be at a component before the form is initialised.
  !order = !source.order

  var !mode mode
  if (!mode.eq('Forwards')) then
    !leaveDirection = !source.lDir
    if (!order.gt(1)) then
      -- find the constrained centreline defined by the leave
      !leaveComponent = !source.owner.members[!order - 1]
      !startDirection = !leaveComponent.lDir.wrt(/* )
    else
      -- its a branch
      !leaveComponent = !source.owner
      !startDirection = !leaveComponent.hDir.wrt(/* )
    endif
  else
    -- mode is Backwards
    !leaveDirection = !source.aDir
    if (!order.lt(!source.owner.members.size())) then
      -- find the constrained centreline defined by the arrive of the previous
      !leaveComponent = !source.owner.members[!order + 1]
      !startDirection = !leaveComponent.aDir.wrt(/* )
    else
      -- its a branch
      !leaveComponent = !source.owner
      !startDirection = !leaveComponent.tDir.wrt(/* )
    endif
  endif

  !return[1] = !startDirection
  !return[2] = !leaveDirection

  return !return

endmethod
------------------------------------------------------------------------
--
-- Method:      .setDistanceText()
--
-- Description: called by the distance and clearance buttons to ensure
-- that the distance field has a value.
--
------------------------------------------------------------------------
define method .setDistanceText( )

  !element = !!ce
  if (!this.elementIsComponent(!!ce).not()) then
    !this.distance.val = 0
    return
  endif

  var !mode mode
  if (!this.dist.val) then
    -- its a clearance
    !this.dist.setToolTip('Clearance - Click to use Distance')
    if (!mode.eq('Forwards')) then
      !prevPos = prevpp position
      !this.distance.val = !prevPos.distance(!!ce.apos)
    else
      !nextPos = nextpp position
      !this.distance.val = !nextPos.distance(!!ce.lpos)
    endif
  else
    -- its a Distance
    !this.dist.setToolTip('Distance - Click to use Clearance')

    if (!mode.eq('Forwards')) then
      if (!element.order.eq(1)) then
        !this.distance.val = !element.owner.hpos.distance(!element.position)
      else
        !this.distance.val = !element.position.distance(!element.owner.members[!element.order - 1].position)
        handle(2,759)
          -- we need the distance from the tail
          !this.distance.val = !element.owner.tpos.distance(!element.position)
        endhandle
      endif
    endif
    if (!mode.eq('Backwards')) then
      -- its backwards mode
      if (!element.order.eq(!element.owner.members.size())) then
        !this.distance.val = !element.owner.tpos.distance(!element.position)
      else
        !this.distance.val = !element.position.distance(!element.owner.members[!element.order + 1].position)
      endif
    endif
  endif
endmethod

------------------------------------------------------------------------
--
-- Method:      .positionDistance
--
-- Description: called by the distance and clearance buttons to ensure
-- that the distance field has a value.
--
------------------------------------------------------------------------
define method .positionDistance(!distance is REAL)
  if (!distance.unset()) then
    !!alert.error('Please enter a distance value')
    return
  endif

  !this.undoAdd('distance-clearance')
  -- Determine if we are going to add a distance or spool
  if (!this.dist.val) then
    -- its a clearance
    -- now changed to reflect obstruction values
    var !mode mode
    if !mode.eq('Forwards') then
      if !!ce.order.gt(1) then
        pos pa dist $!distance from pl of prev
      else
        pos pa dist $!distance from ph
      endif
    else
      -- its backwards
      if !!ce.order.lt(!!ce.owner.mcount) then
        pos pl dist $!distance from pa of prev
      else
        pos pl dist $!distance from pt
      endif
    endif
  else
    -- its a distance
    distance $!distance
  endif
  !this.undo.endUndoable()

endmethod

------------------------------------------------------------------------
--
-- Method:      setIsoMode
--
-- Description: allows the direction control iso mode to be set
-- to the defaults value held in !!pipingSettings
--
------------------------------------------------------------------------
define method .setIsoMode()
  !this.dirCont.setIsoMode(!!pipingSettings.isoMode)
endmethod
------------------------------------------------------------------------
--
-- Method:      createCopy
--
-- Description: creates a copy of the current component and positions it
-- at the arrive/leave of previous depending on mode
--
------------------------------------------------------------------------
define method .createCopy()

  if (!this.elementIsComponent(!!ce).not()) then
    !!alert.error('This function can only be used for copying piping components')
    return
  endif
  !type = !!ce.type
  new $!type Copy Prev
  handle any
    !!alert.error(|$!!error.text|)
    return
  endhandle
  ori
  var !mode mode
  if (!mode.eq('Backwards')) then
    pos pl at pa of prev
    !leaveDirection = !!ce.aDir
  else
    pos pa at pl of prev
    !leaveDirection = !!ce.lDir
  endif

  if (!this.dirCont.slope().neq(0).and(!!ce.type inset('ELBO','BEND','TEE','OLET'))) then

    !this.applySlopeDirection(!leaveDirection)

  endif

endmethod

------------------------------------------------------------------------
--
-- Method:     .applySlopeDirection(!leaveDirection)
--
-- Description: adds the slope to new component if required
--
--
------------------------------------------------------------------------

define method .applySlopeDirection(!leaveDirection is DIRECTION)

  -- the direction control gadget is either sloping up or down
  -- get the appropriate direction from the slopeList
  --!direction = !this.slopeList.getNewDirection(!leaveDirection,!this.dirCont.slope(),!this.slopeList.getSlope())
  !direction = !this.slopeList.combineSlope(!leaveDirection,!this.dirCont.slope(),!this.slopeList.getSlope())
  if (!direction.set()) then
    if (!!ce.type inset('ELBO','BEND')) then
      dir $!direction
      handle ANY
        --q var !!error
        --q var !direction
      endhandle
    else
      ori and p3 is $!direction
      handle ANY
        --q var !!error
        --q var !direction
      endhandle
    endif
  endif


endmethod

------------------------------------------------------------------------
--
-- Method:      setIconTypeVisibility
--
-- Description: sets the active property of the creation icons
-- according to the spec contents
--
------------------------------------------------------------------------
define method .setIconTypeVisibility(!types is ARRAY)

  !this.flangeType .active = !types.findFirst('FLAN').set()
  !this.elbowType  .active = !types.findFirst('ELBO').set()
  !this.teeType    .active = !types.findFirst('TEE') .set()
  !this.reduType   .active = !types.findFirst('REDU').set()
  !this.valveType  .active = !types.findFirst('VALV').set()
  !this.attaType   .active = !types.findFirst('ATTA').set()
  !this.pcomType   .active = !types.findFirst('PCOM').set()
  !this.aWeldType  .active = !types.findFirst('WELD').set()
  !this.bendType   .active = !types.findFirst('BEND').set()
  !this.oletType   .active = !types.findFirst('OLET').set()
  !this.coupType   .active = !types.findFirst('COUP').set()
  !this.instType   .active = !types.findFirst('INST').set()
  !this.capType    .active = !types.findFirst('CAP') .set()
  !this.gasketType .active = !types.findFirst('GASK').set()
  !this.afilttype  .active = !types.findFirst('FILT').set()
  !this.aCrossType .active = !types.findFirst('CROS').set()
  !this.aUnionType .active = !types.findFirst('UNIO').set()
  !this.aVTWAtype  .active = !types.findFirst('VTWA').set()
  !this.aClosType  .active = !types.findFirst('CLOS').set()
  !this.fbliType   .active = !types.findFirst('FBLI').set()
  !this.aTrapType  .active = !types.findFirst('TRAP').set()
  !this.aLJSEtype  .active = !types.findFirst('LJSE').set()
  !this.aFTUBpe    .active = !types.findFirst('FTUB').set()
  !this.aVFWApe    .active = !types.findFirst('VFWA').set()
  !this.aSHUype    .active = !types.findFirst('SHU') .set()
  !this.aPLATType  .active = !types.findFirst('PLAT').set()
  !this.aVENTType  .active = !types.findFirst('VENT').set()
  !this.aASSYType  .active = !types.findFirst('ASSY').set()

endmethod

------------------------------------------------------------------------
--
-- Method:      .setModifyGadgets
--
-- Description: activates or deactivates the modify tab gadgets
-- called if we are at a branch and we can't use the direction control
-- or any positioning and orientation gadgets
--
------------------------------------------------------------------------
define method .setModifyGadgets(!show is BOOLEAN)

  if (!show) then
    !this.modifycomponents.selected = true
  endif
  !this.tHead             .active = !show
  !this.tPrevious         .active = !show
  !this.tCE               .active = !show
  !this.tNext             .active = !show
  !this.tTail             .active = !show
  !this.tCursor           .active = !show
  !this.dist              .active = !show
  !this.distance          .active = !show
  !this.repeat            .active = !show
  !this.connect1          .active = !show
  !this.dirContFrame      .active = !show
  !this.direction         .active = !show
  !this.modifyTab         .active = !show
  !this.tpod              .active = !show
  !this.tpom              .active = !show
  !this.changeflow        .active = !show
  !this.tpo               .active = !show
  !this.mode              .active = !show

  if (!show.not().and(!!ce.type.eq('BRAN'))) then
    !this.tpod          .active = TRUE
    !this.tpom          .active = TRUE
  endif

  !this.setSlopeGadgets()
  --!this.setSlopeGadgets(!show)
  !this.setDistanceText( )

endmethod

------------------------------------------------------------------------
--
-- Method:      .setSlopeGadgets
--
-- Description: activates or deactivates the modify slope Gadgets
-- abstracted from the above to try and separate some slope activities
--
------------------------------------------------------------------------
define method .setSlopeGadgets()

  if (!this.branch.badRef()) then
    return
  endif

  -- if the branch has no slope ref then turn everything off
  if (!this.branch.sloref.badRef()) then
    !show = FALSE
  else
    !show = true
  endif

  !this.pipeSlopeList     .visible = !show
  !this.slopeText         .visible = !show
  !this.pointDirection    .visible = !this.multislope
  !this.points            .visible = !this.pointDirection.visible.and(!this.pointDirection.val)
  if (!show.not()) then
    !this.dirCont.slope(0)
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:      trackModify
--
-- Description: Track with respect to passed element
-- This should only be called when we are in modify mode
--
--
------------------------------------------------------------------------
define method .trackModify(!passedElement is DBREF)

 -- this gets called when we navigate to a new component whilst in modify mode
  -- check if the current component is from a piping spec
  !current = !passedElement.spown
  handle any
    -- no spec
  elsehandle NONE
    -- we need to do something more here because this is only part of the story
    if (!current.unset().not()) then
      !test = !this.editComponentData.pipingSpecs.specIndex(!current)
      if (!test.unset()) then
        --!prompt = !passedElement.flnn & ' is not from a piping spec and cannot be modified by this form'
        --prompt '$!prompt'
        --!this.setModifyGadgets(false)
        --!this.setTask('SELECTCOMPONENT')
        --!this.setBranch(!!ce)
        return
      else
        prompt dismiss
      endif
    endif
  endhandle

endmethod
-- end of trackModify method
------------------------------------------------------------------------
--
-- Method:      .laserPipeCentre
--
-- Description: Wrapper to the LFM extension interface to find a pipe centre.
--
-- Method Type: Procedure
-- Arguments: None
-- Return: None
--
------------------------------------------------------------------------
define method .laserPipeCentre(!position   is POSITION) is ARRAY

  !east                   = !position.east.convertUnits('mm').string().before('mm')
  !north                  = !position.north.convertUnits('mm').string().before('mm')
  !up                     = !position.up.convertUnits('mm').string().before('mm')

  -- Go and find a pipe
  VAR !result LMI DRIVER 'aveva' EXT 'fitPipe $!east $!north $!up 20'

  !point       = object POSITION(!result.after('POS').before('ORI').replace('X', 'E').replace('Y', 'mm N').replace('Z', 'mm U') & 'mm WRT /*')
  !orientation = object ORIENTATION(!result.after('ORI').before('DIAM'))
  !diameter    = !result.after('DIAM').before('HEIG') & 'mm'

  !pointVector = object POINTVECTOR(!point, !orientation.zDir())
  !plane       = object PLANE(!position, !orientation)

  !newPoint    = !pointVector.intersection(!plane)

  !returnArray = object ARRAY()
  !returnArray.append(!newPoint)
  !returnArray.append(!diameter)
  !returnArray.append(!orientation)

  return !returnArray

endmethod

------------------------------------------------------------------------
--
-- Method:      pickDirection
--
-- Description: uses edg to pick a position to direction component towards
--
------------------------------------------------------------------------
define method .pickDirection()

  if (!!ce.owner.type.neq('BRAN')) then
    !!alert.error('This option can only be used on a valid piping component - Please select a component')
    return
  endif

  !!edgSourceComponent = !!ce
  -- define packet
  !prompt                = 'Pick A Position To Direct Component Towards'
  !packet                = object EDGPACKET()
  !packet.initialisation = '!!componentEditor.pickedPosDirData  = object EDGPOSITIONDATA()'
  !packet.definePosition(!prompt)
  !packet.description    = 'Pick Position for Direction'
  !packet.remove         = TRUE
  !packet.action = '!!componentEditor.pickDirection(!this.return[1] ,!!edgSourceComponent ) '

  -- Add event to system
  !!edgCntrl.add(!packet)

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      pickDirection
--
-- Description: this method defines the direction from origin of component to picked position
--
------------------------------------------------------------------------
define method .pickDirection(!pos is EDGPOSITIONDATA, !comp is DBREF  )

  !!ce = !!edgSourceComponent

  !this.pickedPosDirData = !pos

  if (!pos.type.eq('ELEMENT') and !pos.item.type.eq('XGEOM') and !pos.originalType.unset()) then
    --laser pick so try to fit
    !pipeCentre              = !this.laserPipeCentre(!pos.position)
    handle ANY
      !!alert.warning('Unable to obtain centre-line from picked item')
      !pickedPosition = !pos.position
    elsehandle none
      -- using fitted cylinder centre position
      --*** provide graphical aid and alert confirm dialogue?
      !pickedPosition            = !pipeCentre[1]
    endhandle
  else
    !pickedPosition = !pos.position
  endif

  --calculate direction from origin of component to picked position

  !direction = !comp.position.direction(!pickedPosition)

  !roundToOrthogonal = !!pipingSettings.roundLaserToOrthogonal
  if (!roundToOrthogonal) then
    !tolerance = !!pipingSettings.roundLaserTolerance.value()
    !direction = !this.roundToOrthogonal(!direction,!tolerance)
  endif

  !this.direction.val = !direction.string()

  !this.directionControlActions.direction(!this.direction,'DUMMY')

endmethod
-- End of method definition
------------------------------------------------------------------------
--
-- Method:      roundToOrthogonal
--
-- Description: this method rounds each component of direction to E/N/U if within tolerance given
--
------------------------------------------------------------------------
define method .roundToOrthogonal(!direction is DIRECTION,!tolerance is REAL) is DIRECTION

  !roundedDirection = !direction
  -- if the direction is already orthogonal then return
  !sum = abs(!direction.east + !direction.north +!direction.up)
  if (!sum.eq(1)) then
    return !direction
  endif

  --E

  !eDirection = !direction
  !eDirection.north = 0
  !eDirection.up = 0

  !angle = !direction.angle(!eDirection)
  handle none
    if (!angle.between(0,!tolerance) OR !angle.between((90 - !tolerance),(90 + !tolerance)) OR !angle.between((180 - !tolerance),180)) then
      !roundedDirection.east = !direction.east.nint()
    endif
  elsehandle any
  endhandle

  --N

  !nDirection = !direction
  !nDirection.east = 0
  !nDirection.up = 0

  !angle = !direction.angle(!nDirection)
  handle none
    if (!angle.between(0,!tolerance) OR !angle.between((90 - !tolerance),(90 + !tolerance)) OR !angle.between((180 - !tolerance),180)) then
      !roundedDirection.north = !direction.north.nint()
    endif
  elsehandle any
  endhandle

  --U

  !uDirection = !direction
  !uDirection.east = 0
  !uDirection.north = 0

  !angle = !direction.angle(!uDirection)
  handle none
    if (!angle.between(0,!tolerance) OR !angle.between((90 - !tolerance),(90 + !tolerance)) OR !angle.between((180 - !tolerance),180)) then
      !roundedDirection.up = !direction.up.nint()
    endif
  elsehandle any
  endhandle

  if (defined(!roundedDirection)) then
    return !roundedDirection
  else
    prompt 'unable to set direction'
  endif

endmethod


------------------------------------------------------------------------
--
-- Method:     testForOffLine
--
-- Description: test to se if there is an offline flag set in the spec
-- and set the value
--
--
------------------------------------------------------------------------
define method .setOffLineFlag(!element is DBREF)

  !!ce = !element

  !index = !element.attlist.findFirst('LOFF')
  if (!index.unset()) then
    return
  endif

  -- if we get here we have a loff attribute
  var !s choice loff
  handle ANY
    -- no loff or loff not set
    return
  endhandle
  if (!s.set()) then
    !loff = !s.boolean()
    handle ANY
      return
    elsehandle NONE
      !!ce.loff  = !loff
    endhandle
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:    ShowPipeEditor
--
-- Description: show the pipe editor form from the branch linklabel
-- and set the value
--
--
------------------------------------------------------------------------
define method .showPipeEditor()

  !!ce = !this.branch
  handle any
    !!alert.error('Cannot find selected branch')
    return
  endhandle
  same

  if (undefined(!!pipeEditor)) then
    pml load form !!pipeEditor
  endif
  !this.close()
  !!pipeEditor.modify(!!ce)
  !this.hide()

endmethod
------------------------------------------------------------------------
--
-- Method:  slopeChange()
--
-- Description: this method is called if the user selects a new slope
-- from the list. If we are at the branch it prompts to change the branch
-- slopeReference otherwise it changes the current slope angle to the new
-- selected angle
--
------------------------------------------------------------------------
define method .slopeChange()

  if (!this.pointDirection.val) then
    -- this is the method that is called when we change the slope selection
  endif

endmethod
-- End of method definition

------------------------------------------------------------------------
--
-- Method:  .selectPoint(!point is STRING )
--
-- Description: This method is the method to make the current selected point
-- into a rotation point for sloping purposes. In this instance it changes the
-- interpretation of the direction gadget into a fixed point orientation
--
------------------------------------------------------------------------
define method .selectPoint(!point is STRING )

  !this.componentFeedBack.clear()
  !direction = !this.component.pDir[!point.real()].wrt(/* )
  -- error handle for the initial loading of the slopelist object
  handle ANY
    return
  endhandle
  if (!this.dirCont.pointActive()) then
    if (!this.dirCont.pointMode().eq(0)  ) then
      -- we are dealing with the actual ppoint
      !direction = !this.component.pActdir[!point.real()].wrt(/* )
      handle(2,201) (2,779)
        !direction = !this.component.pDir[!point.real()].wrt(/* )
      endhandle
    else
      !direction = !this.component.pDir[!point.real()].wrt(/* )
    endif
  endif
  !this.direction.val = !direction.string()
  !this.componentFeedBack.showPoint(!this.component, !point.real())

endmethod

------------------------------------------------------------------------
--
-- Method:  .configureArriveLeave(!on is BOOLEAN)
--
-- Description: this method is the result of clicking the fixed point toggle
-- it changes the context of the directionControl direction gadget
-- the standard callback is call|!this.directionControlActions.direction(|
------------------------------------------------------------------------

define method .configureArriveLeave()

  if (!this.slopeList.component.neq(!!ce)) then
    if (!this.elementIsComponent(!!ce)) then
      !this.slopeList.setComponent(!!ce)
    endif
  endif
  if (!this.directionControlActions.checkBranchSlope().not()) then
    !this.pointDirection.val = FALSE
  endif
  if (!this.pointDirection.val.not()) then
    -- change the context to standard
    !this.points.visible = FALSE
    --!this.direction.callback = |!this.directionControlActions.direction(|
    !this.componentFeedBack.mode = FALSE
    !this.dirCont.pointActive(FALSE)
    !a[0] = true
    !this.directionControlActions.onFocusChange(!a)
    !this.directionText.val = 'Direction'
    return
  endif

  if (!this.dirCont.pointMode().eq(0)) then
    -- we are in fixed point mode
    -- change the context
    !this.points.visible = TRUE
    !this.points.active = TRUE
    !this.selectPoint(!this.points.selection())
    --!this.direction.callback = |!this.fixedDirectionCallback(|
    !this.componentFeedBack.mode = TRUE
    !this.dirCont.pointActive(TRUE)
    !this.dirCont.pointMode(0)
    !this.directionText.val = 'Component Direction'
  else
    !this.points.visible = TRUE
    !this.points.active = TRUE
    !this.selectPoint(!this.points.selection())
    --!this.direction.callback = |!this.fixedDirectionCallback(|
    !this.componentFeedBack.mode = TRUE
    !this.dirCont.pointActive(TRUE)
    !this.dirCont.pointMode(1)
    !this.directionText.val = 'Point Direction'
  endif

endmethod

------------------------------------------------------------------------
--
-- Method:  .getComponentText(!type is STRING)
--
-- Description: This method gets the extended component type from
-- the componentList pseudo gadget object
------------------------------------------------------------------------
define method .getComponentText(!type is STRING) is STRING

!this.componentList.select('rtext',!type)
handle none
   return !this.componentList.selection('dtext')
elsehandle any
   return 'unset'
endhandle

endmethod
------------------------------------------------------------------------
--
-- Method:  .executeCommand(!command is STRING)
--
-- Description: This method adds an undo for a lot of button actions
-- direction
------------------------------------------------------------------------
define method .executeCommand(!command is STRING)

  !this.undoAdd(!command)

  $!command
  handle any
    !!alert.error(!!error.text)
  endhandle

  -- Set end mark for UNDO
  !this.undo.endUndoable()

endmethod

------------------------------------------------------------------------
--
-- Method: .getDirectionChangeType()
--
-- Description: .check the router default direction change
-- direction
------------------------------------------------------------------------
define method .getDirectionChangeType() is STRING

   if undefined(!!rtrdefaults) then
     pml load form !!rtrdefaults
   endif
     !!runSynonym('CALLR ULOADDEF OLDFILE')
     handle any
         return 'ELBO'
     endhandle
     !val = !!rtrdefaults.dirChange.val
     handle any
        return 'ELBO'
     endhandle
     if !val.eq(1) then
       return 'BEND'
     else
       return 'ELBO'
     endif

  endmethod
  
-- ===================================================================== --
-- ===================================================================== --
-- Ajout des méthodes pour les Branch Table
-- Client: TECHNIP-FMC
-- Auteurs: Jean François Houen - AVEVA
--          Alain Saudemont
-- Date : Novembre 2019
-- ===================================================================== --
-- ===================================================================== --
------------------------------------------------------------------------
--
-- Method: .setbranConn()
--
-- Description: Hide the icon TEE and OLET to Unhide the BRANCONN icon
-- direction
------------------------------------------------------------------------
define method .setbranConn(!option is boolean)
	-- code JFH-AS
	if !option eq true then
		-- cache les icones tee et olet natives
		--!this.teeType.setsize(0, 32)
		!this.teeType.settooltip('Branch connector')
		!this.teeType.addpixmap(!!pml.getpathname(|branconn.png|))
		!this.oletType.visible = false
		!this.BranTxt.visible = true
		!this.teeType.callback = |!this.setbranConnFromIcon()|
		if !this.componentType.val.eq(|Olet|) then 
			!this.setbranConnFromIcon()
		endif
	else
		-- affiche les icones tee et olet natives
		!this.oletType.visible = true
		!this.BranTxt.visible = false
		!this.teeType.settooltip('Tee')
		!this.teeType.addpixmap('AvevaSharedIcons>ID_TEE>32')
		!this.teeType.callback = |!this.setFromIcon('TEE')|		
		
	endif
	
endmethod

------------------------------------------------------------------------
--
-- Method: .setbranConnFromIcon()
--
-- Description: Construct the list from XML File
-- direction
------------------------------------------------------------------------
define method .setbranConnFromIcon()
    -- code JFH-AS
	
	-- namespace
	using namespace 'PMLXmlDocument.PMLXmlDocument'

	-- se mettre en mode tee
	!this.setFromIcon('TEE')
	-- $p vider/griser le stype
	!this.sTypes.clear()
	!this.sTypes.active = false
	-- $p unset du bore
	!this.teeBore.clear()
	-- !this.teeBore.add(|Select outlet Dia|,||)
	!this.teeBore.add(|Unset|,||)
	
	!spec = !this.specList.selection().dbref().namn
	$P $!spec
	!headDiam = !!ce.lbore.string().before('in')
	HANDLE ANY
    !headDiam = !!ce.tbore.string().before('in')
	ENDHANDLE
	$P $!headDiam
	
	!specnode = !this.branchtablexmldoc.selectnodes(|//BranchTable[@value='| + !spec + |']|)
	if !specnode.set() then
	!!diamheadernode = !specnode[1].selectnodes(|DiamHeader[@value='| + !headDiam + |']|)
	else
	  !!alert.error(|The Piping specification does not exist in the Branch Table. Contact your administrator !|)
	  -- $p la spec n'existe pas '
	  !this.branConn.val = false
	  !this.setbranConn(false)
	  return
	endif
	!nodes = !!diamheadernode[1].childnodes()

	var !UNITS UNITS
	
	do !node values !nodes
		-- gestion des unités : si on le proj est en mm, on affiche la liste en mm ( fichiers MARIAN en INCH uniquement )
		if (MATCH(|$!UNITS|,|MM Bore|) neq 0) THEN
			-- dans le cas des mm, on construit la liste sans les MM à partir des diamètres en INCH
			!tpselbore = object bore()
			!textdiamIN = !node.value('@value') + 'in'
			!tpselbore.bore(!textdiamIN)
			!textdiamMM = !tpselbore.string().replace('mm','')
			!this.teeBore.add(!textdiamMM,!textdiamMM)
		else
			-- dans le cas des INCH, on construit la liste avec les leading zeroes
			!tpselbore = object bore()
			!textdiamIN = !node.value('@value') + 'in'
			--!tpselbore.bore(!textdiamIN)
			--!textdiamIN = !tpselbore.string().replace('in','')
			!this.teeBore.add(!textdiamIN,!textdiamIN)
		endif
	enddo
	
	!this.teeBore.val = 1
	
	
	-- set componet type
    !this.componentList.rtext[29] = 'BRANCONN'
	!this.componentList.dtext[29] = 'Bran Conn.'
	!!componentEditor.componentList.select('Rtext','BRANCONN')
	!this.choices.clear()
	-- Q VAR !this.componentList.DTEXT
	-- Q VAR !this.componentList.RTEXT
	
	
endmethod



-------------------------------------------------------------------------------------------------
-- TECHNIP CUSTOM METHODS - Valve Filtering
-------------------------------------------------------------------------------------------------
$(---------------------------------------------------------------------------
-- Method:      .loadValveXmlData()
--
-- Description: Load the Valve data from the XML file available in Project Defaults and  validate the information and
--              returns valid Stypes of the component for the Selected Pipe Spec and Fluid reference set for Pipe
--
-- Method Type: Procedure
--
-- Arguments:
--  [#] [R/RW] [Data Type] [Description]
-- Return:
--             [Data Type] [Description]
--              ARRAY        List of Valid Stypes for selected component accroding to Spec and Fluid
---------------------------------------------------------------------------$)

define method .loadValveXmlData(!componentType is STRING) is ARRAY
  
  using namespace 'PMLXmlDocument.PMLXmlDocument'
  
  !validStypes              = ARRAY()
  !validStypes.clear()
  !this.validsTypes.clear()
  
  -- Get Pipe / Branch Spec selected
  !spec                     = !this.specList.selection().dbref().namn
 -- $P $!spec
  !eleType                  = !componentType 

  -- Get Fluid Reference of Pipe
  !fluidRef                 = !this.branch.owner.fluref
 -- $P $!fluidRef.NAMN

  if (UNSET(!fluidRef)) then
    !!alert.message('Fluid Reference is not set for the Pipe. Please set it and select valves')
    return
  else
    !fluidName          = !fluidRef.namn  
  endif
  !specNode                = !this.valveTableXmlDoc.selectnodes(|//PipeSpecTable[@value='| + !spec + |']|)

  --!ComponentNode           = !specNode.selectnodes(|ComponentType[@value='$!componentType]|)
  if !specNode.set() then
	!componentNode         = !specNode[1].selectnodes(|ComponentType[@value='| + !eleType + |']|)
	else
	  !!alert.error(|The selected component type $!eleType doesnt exist in Table. Contact your administrator !|)
	  return
  endif
  -- Check the Fluid reference
  if !componentNode.set() then
	!fluidNode         = !componentNode[1].selectnodes(|FluidReference[@value='| + !fluidName + |']|)
	else
	  !!alert.error(|The selected Fluid type $!fluidName doesnt exist in Table. Contact your administrator !|)
	  return
  endif
  -- Get the child node information
  --q var !fluidNode
  
  -- Get the stypes values that are valid for the selected Spref and Fluid code
  do !node index !fluidNode
    !validStypes[!node]         = !fluidNode[!node].value('@stype') 
    !this.validsTypes.append(!validStypes[!node])
    
  enddo
  !validStypes.unique()
  !this.validStypes.unique()

  return !validStypes
 
endmethod


$(---------------------------------------------------------------------------
-- Method:      .filterValidComponents()
--
-- Description: Filter the avaiilabe components (for creation / reselection) as per the valid stypes defined in the XML file for the Pspec and Fluid reference
--              The Options available for the selection to users will be limited to the required stypes and hence chance of reducing the error of selecting a mismatching spref for the component
--              Currently the method filters Valve components only. 
--
-- Method Type: Procedure
--
-- Arguments:
--  [#] [R/RW] [Data Type] [Description]
--   1    R      STRING      Mode of operation (create / edit)
--   2    R      STRING      Type of Component (Valve, Fitting, Elbow etc.)
-- Return:
--             [Data Type] [Description]
--              ARRAY        List of Valid Stypes for selected component accroding to Spec and Fluid
---------------------------------------------------------------------------$)


define method .filterValidComponents(!mode is STRING, !componentType is STRING)
  -- define variables
  !validComponents = ARRAY()
  !validComponents.clear()
  
  -- check the mode of operation and filter the components according to the selected mode
  if (!mode.eq('create')) then
    
    if (!componentType inset ('VALV','GASK','FLAN')) then
    -- Filter Available components with Valid Stypes and return only valid available components
    do !i index !this.availableComponents
      -- Get the sType of component
      !compsType              = !this.availableComponents[!i].stype
      do !j index !this.validsTypes
        !validsType             = !this.validsTypes[!j]
        -- Check whether the current component stype is available in the valid stype list
        if (!compsType EQ !validsType) then
          !validComponents.append(!this.availableComponents[!i])
        endif       
      enddo
    enddo
     !this.availableComponents = !validComponents
     
    endif   
  endif
  
  if (!mode.eq('edit')) then

    if (!componentType inset ('VALV','GASK','FLAN')) then
    -- Filter Available components with Valid Stypes and return only valid available components
    do !i index !this.editAvailableComponents
      -- Get the sType of component
      !compsType              = !this.editAvailableComponents[!i].stype
      do !j index !this.validsTypes
        !validsType             = !this.validsTypes[!j]
        -- Check whether the current component stype is available in the valid stype list
        if (!compsType EQ !validsType) then
          !validComponents.append(!this.editAvailableComponents[!i])
        endif       
      enddo
    enddo
     !this.editAvailableComponents = !validComponents
     
    endif   
  endif
  
endmethod

